(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.coffeelex = global.coffeelex || {})));
}(this, (function (exports) { 'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set = function set(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var BufferedStream = function () {
  function BufferedStream(stream) {
    classCallCheck(this, BufferedStream);
    this.pending = [];

    this._getNextLocation = stream;
  }

  createClass(BufferedStream, [{
    key: 'shift',
    value: function shift() {
      return this.pending.shift() || this._getNextLocation();
    }
  }, {
    key: 'hasNext',
    value: function hasNext() {
      var _this = this;

      var locationsToPutBack = [];

      for (var _len = arguments.length, types = Array(_len), _key = 0; _key < _len; _key++) {
        types[_key] = arguments[_key];
      }

      var result = types.every(function (type) {
        var next = _this.shift();
        locationsToPutBack.push(next);
        return next.type === type;
      });
      this.unshift.apply(this, locationsToPutBack);
      return result;
    }
  }, {
    key: 'peek',
    value: function peek() {
      var result = this.shift();
      this.unshift(result);
      return result;
    }
  }, {
    key: 'unshift',
    value: function unshift() {
      var _pending;

      (_pending = this.pending).unshift.apply(_pending, arguments);
    }
  }]);
  return BufferedStream;
}();

/**
 * Represents a change in source code type at a particular index.
 */
var SourceLocation = function SourceLocation(type, index) {
  classCallCheck(this, SourceLocation);

  this.type = type;
  this.index = index;
};

var SourceToken = function SourceToken(type, start, end) {
  classCallCheck(this, SourceToken);

  this.type = type;
  this.start = start;
  this.end = end;
};

/**
 * Represents a token at a particular index within a list of tokens.
 */

var SourceTokenListIndex = function () {
  function SourceTokenListIndex(sourceTokenList, index) {
    classCallCheck(this, SourceTokenListIndex);

    this._sourceTokenList = sourceTokenList;
    this._index = index;
  }

  /**
   * Get a new index offset from this one, if the resulting offset is within
   * the list range.
   */


  createClass(SourceTokenListIndex, [{
    key: 'advance',
    value: function advance(offset) {
      var newIndex = this._index + offset;
      if (newIndex < 0 || this._sourceTokenList.length < newIndex) {
        return null;
      }
      return this._sourceTokenList._getIndex(newIndex);
    }

    /**
     * Get the index of the token after this one, if it's not the last one.
     */

  }, {
    key: 'next',
    value: function next() {
      return this.advance(1);
    }

    /**
     * Get the index of the token before this one, if it's not the first one.
     */

  }, {
    key: 'previous',
    value: function previous() {
      return this.advance(-1);
    }

    /**
     * Determines whether this index comes before another.
     */

  }, {
    key: 'isBefore',
    value: function isBefore(other) {
      return this.compare(other) > 0;
    }

    /**
     * Determines whether this index comes after another.
     */

  }, {
    key: 'isAfter',
    value: function isAfter(other) {
      return this.compare(other) < 0;
    }

    /**
     * Compare this index to another, returning 0 for equality, a negative number
     * if this is less than `other`, and a positive number otherwise.
     */

  }, {
    key: 'compare',
    value: function compare(other) {
      return this.distance(other);
    }

    /**
     * Returns an int of the relative distance between this index and the other
     * index (positive if the other one is later, negative if the other one is
     * earlier).
     */

  }, {
    key: 'distance',
    value: function distance(other) {
      if (other._sourceTokenList !== this._sourceTokenList) {
        throw new Error('cannot compare indexes from different lists');
      }
      return other._index - this._index;
    }
  }]);
  return SourceTokenListIndex;
}();

/**
 * Represents a particular type of CoffeeScript code.
 */
var SourceType = function () {
  function SourceType(name) {
    classCallCheck(this, SourceType);

    this.name = name;
  }

  createClass(SourceType, [{
    key: "toString",
    value: function toString() {
      return this.name;
    }
  }]);
  return SourceType;
}();

/**
 * Represents a list of tokens and provides various utility functions for
 * finding tokens within it.
 */
var SourceTokenList = function () {
  function SourceTokenList(tokens) {
    classCallCheck(this, SourceTokenList);

    this._tokens = tokens;
    this._indexCache = new Array(tokens.length);
    this.length = tokens.length;
    this.startIndex = this._getIndex(0);
    this.endIndex = this._getIndex(tokens.length);
  }

  /**
   * Iterate over each token.
   */


  createClass(SourceTokenList, [{
    key: 'forEach',
    value: function forEach(iterator) {
      var _this = this;

      this._tokens.forEach(function (token, i) {
        return iterator(token, _this._getIndex(i), _this);
      });
    }

    /**
     * Map each token to an element of an array.
     */

  }, {
    key: 'map',
    value: function map(mapper) {
      var result = [];
      this.forEach(function (token, index, list) {
        result.push(mapper(token, index, list));
      });
      return result;
    }

    /**
     * Filter tokens by a predicate.
     */

  }, {
    key: 'filter',
    value: function filter(predicate) {
      var result = [];
      this.forEach(function (token, index, list) {
        if (predicate(token, index, list)) {
          result.push(token);
        }
      });
      return new SourceTokenList(result);
    }

    /**
     * Get a slice of this token list using the given indexes.
     */

  }, {
    key: 'slice',
    value: function slice(start, end) {
      if (start._sourceTokenList !== this || end._sourceTokenList !== this) {
        throw new Error('cannot slice a list using indexes from another list');
      }
      return new SourceTokenList(this._tokens.slice(start._index, end._index));
    }

    /**
     * Get the token at the given index, if it exists.
     *
     * NOTE: The only value for which this should return `null` is this list's
     * `endIndex`.
     */

  }, {
    key: 'tokenAtIndex',
    value: function tokenAtIndex(index) {
      this._validateIndex(index);
      return this._tokens[index._index] || null;
    }

    /**
     * Get the range of tokens representing an interpolated string that contains
     * the token at `index`. This will return the innermost interpolated string in
     * the case of nesting.
     */

  }, {
    key: 'rangeOfInterpolatedStringTokensContainingTokenIndex',
    value: function rangeOfInterpolatedStringTokensContainingTokenIndex(index) {
      var bestRange = null;
      var _arr = [[DSTRING_START, DSTRING_END], [TDSTRING_START, TDSTRING_END], [HEREGEXP_START, HEREGEXP_END]];
      for (var _i = 0; _i < _arr.length; _i++) {
        var _arr$_i = slicedToArray(_arr[_i], 2),
            startType = _arr$_i[0],
            endType = _arr$_i[1];

        var range = this.rangeOfMatchingTokensContainingTokenIndex(startType, endType, index);
        if (bestRange === null || bestRange === undefined || range !== null && range !== undefined && range[0].distance(range[1]) < bestRange[0].distance(bestRange[1])) {
          bestRange = range;
        }
      }
      return bestRange;
    }

    /**
     * Get the range of tokens starting with a token of type `startType` and
     * ending one past a token of type `endType`, ensuring that the tokens match.
     * That is, it ensures they are balanced and properly account for nesting.
     * This range will contain `index`. If no such range can be found, `null` is
     * returned.
     */

  }, {
    key: 'rangeOfMatchingTokensContainingTokenIndex',
    value: function rangeOfMatchingTokensContainingTokenIndex(startType, endType, index) {
      var _this2 = this;

      this._validateIndex(index);

      var token = this.tokenAtIndex(index);
      if (!token) {
        return null;
      }

      switch (token.type) {
        case startType:
          {
            var _ret = function () {
              var level = 0;
              var start = index;

              var endIndex = _this2.indexOfTokenMatchingPredicate(function (token) {
                if (token.type === startType) {
                  level += 1;
                } else if (token.type === endType) {
                  level -= 1;
                  if (level === 0) {
                    return true;
                  }
                }
                return false;
              }, start);

              if (!endIndex) {
                return {
                  v: null
                };
              } else {
                var rangeEnd = endIndex.next();
                if (!rangeEnd) {
                  return {
                    v: null
                  };
                }
                return {
                  v: [start, rangeEnd]
                };
              }
            }();

            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
          }

        case endType:
          {
            var _ret2 = function () {
              var level = 0;
              var endIndex = index;

              var startIndex = _this2.lastIndexOfTokenMatchingPredicate(function (token) {
                if (token.type === startType) {
                  level -= 1;
                  if (level === 0) {
                    return true;
                  }
                } else if (token.type === endType) {
                  level += 1;
                }
                return false;
              }, endIndex);

              if (!startIndex) {
                return {
                  v: null
                };
              } else {
                var rangeEnd = endIndex.next();
                if (!rangeEnd) {
                  return {
                    v: null
                  };
                } else {
                  return {
                    v: [startIndex, rangeEnd]
                  };
                }
              }
            }();

            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
          }

        default:
          {
            var _ret3 = function () {
              var level = 0;
              var startIndex = _this2.lastIndexOfTokenMatchingPredicate(function (token) {
                if (token.type === startType) {
                  if (level === 0) {
                    return true;
                  }
                  level -= 1;
                } else if (token.type === endType) {
                  level += 1;
                }
                return false;
              }, index);

              if (!startIndex) {
                return {
                  v: null
                };
              } else {
                return {
                  v: _this2.rangeOfMatchingTokensContainingTokenIndex(startType, endType, startIndex)
                };
              }
            }();

            if ((typeof _ret3 === 'undefined' ? 'undefined' : _typeof(_ret3)) === "object") return _ret3.v;
          }
      }
    }

    /**
     * Finds the index of the token whose source range includes the given index.
     */

  }, {
    key: 'indexOfTokenContainingSourceIndex',
    value: function indexOfTokenContainingSourceIndex(index) {
      this._validateSourceIndex(index);
      return this.indexOfTokenMatchingPredicate(function (_ref) {
        var start = _ref.start,
            end = _ref.end;
        return start <= index && index < end;
      });
    }

    /**
     * Finds the index of the token whose source range starts at the given index.
     */

  }, {
    key: 'indexOfTokenStartingAtSourceIndex',
    value: function indexOfTokenStartingAtSourceIndex(index) {
      this._validateSourceIndex(index);
      return this.indexOfTokenMatchingPredicate(function (_ref2) {
        var start = _ref2.start;
        return start === index;
      });
    }

    /**
     * Finds the index of the token whose source range ends at the given index.
     */

  }, {
    key: 'indexOfTokenEndingAtSourceIndex',
    value: function indexOfTokenEndingAtSourceIndex(index) {
      this._validateSourceIndex(index);
      return this.indexOfTokenMatchingPredicate(function (_ref3) {
        var end = _ref3.end;
        return end === index;
      });
    }

    /**
     * Finds the index of the first token matching a predicate.
     */

  }, {
    key: 'indexOfTokenMatchingPredicate',
    value: function indexOfTokenMatchingPredicate(predicate) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (!start) {
        start = this.startIndex;
      }
      this._validateIndex(start);

      var endIndex = this.endIndex;

      for (var i = start; i && i !== endIndex; i = i.next()) {
        var _token = this.tokenAtIndex(i);
        if (!_token) {
          break;
        } else if (predicate(_token)) {
          return i;
        }
      }

      return null;
    }

    /**
     * Finds the index of the first token matching a predicate.
     */

  }, {
    key: 'lastIndexOfTokenMatchingPredicate',
    value: function lastIndexOfTokenMatchingPredicate(predicate) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (!start) {
        start = this.endIndex.previous();
        if (!start) {
          return null;
        }
      }
      this._validateIndex(start);

      var i = start;
      do {
        var _token2 = this.tokenAtIndex(i);
        if (!_token2) {
          break;
        } else if (predicate(_token2)) {
          return i;
        } else if (i) {
          i = i.previous();
        }
      } while (i);

      return null;
    }

    /**
     * Allow iterating over the tokens in this list using e.g. `for (… of …)`.
     *
     * $FlowIssue (see facebook/flow#252)
     */

  }, {
    key: Symbol.iterator,
    value: function value() {
      var _this3 = this;

      var index = this.startIndex;
      var endIndex = this.endIndex;

      return function () {
        if (index === endIndex) {
          return { done: true, value: undefined };
        } else {
          var result = { done: false, value: _this3.tokenAtIndex(index) };
          index = index.next();
          return result;
        }
      };
    }

    /**
     * @internal
     */

  }, {
    key: '_validateIndex',
    value: function _validateIndex(index) {
      if (!index) {
        throw new Error('unexpected \'null\' index, perhaps you forgot to check the result of ' + '\'indexOfTokenContainingSourceIndex\'?');
      }
      if (typeof index === 'number') {
        throw new Error('to get a token at index ' + index + ', ' + ('use list.tokenAtIndex(list.startIndex.advance(' + index + '))'));
      }
      if (index._sourceTokenList !== this) {
        throw new Error('cannot get token in one list using an index from another');
      }
    }

    /**
     * @internal
     */

  }, {
    key: '_validateSourceIndex',
    value: function _validateSourceIndex(index) {
      if (typeof index !== 'number') {
        throw new Error('expected source index to be a number, got: ' + index);
      }
    }

    /**
     * @internal
     */

  }, {
    key: '_getIndex',
    value: function _getIndex(index) {
      var cached = this._indexCache[index];

      if (!cached) {
        cached = new SourceTokenListIndex(this, index);
        this._indexCache[index] = cached;
      }

      return cached;
    }

    /**
     * Get the list of tokens.
     */

  }, {
    key: 'toArray',
    value: function toArray() {
      return this._tokens.slice();
    }
  }]);
  return SourceTokenList;
}();

/**
 * Helper class for defining the padding (characters to remove, typically
 * whitespace) in a string or heregexp. Also tracks "line separators", which are
 * newline characters in multiline single and double quoted strings that should
 * be turned into space characters.
 *
 * Example usage:
 *
 * let paddingTracker = new PaddingTracker(source, stream, SSTRING_END);
 *
 * // Examine underlying code to see what padding to add.
 * paddingTracker.fragments[0].content;
 *
 * // Mark padding for each fragment, indexed relative to the fragment content.
 * paddingTracker.fragments[0].markPadding(3, 5);
 * paddingTracker.fragments[1].markPadding(1, 4);
 * paddingTracker.fragments[1].markLineSeparator(5);
 *
 * // Compute the replacement source locations for the entire string/heregexp.
 * paddingTracker.computeSourceLocations();
 */
var PaddingTracker = function () {
  function PaddingTracker(source, stream$$1, endType) {
    classCallCheck(this, PaddingTracker);

    this.fragments = [];
    this._originalLocations = [];

    var interpolationLevel = 0;
    var location = void 0;
    do {
      location = stream$$1.shift();
      this._originalLocations.push(location);
      if (interpolationLevel === 0 && location.type === STRING_CONTENT) {
        var _start = location.index;
        var _end = stream$$1.peek().index;
        var content = source.slice(_start, _end);
        var index = this.fragments.length;
        this.fragments.push(new TrackedFragment(content, _start, _end, index));
      } else if (location.type === INTERPOLATION_START) {
        interpolationLevel += 1;
      } else if (location.type === INTERPOLATION_END) {
        interpolationLevel -= 1;
      }
    } while (interpolationLevel > 0 || location.type !== endType);
  }

  createClass(PaddingTracker, [{
    key: 'computeSourceLocations',
    value: function computeSourceLocations() {
      var resultLocations = [];
      var rangeIndex = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._originalLocations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _location = _step.value;

          var currentRange = this.fragments[rangeIndex];
          if (_location.type === STRING_CONTENT && currentRange && _location.index === currentRange.start) {
            resultLocations.push.apply(resultLocations, toConsumableArray(currentRange.computeSourceLocations()));
            rangeIndex++;
          } else {
            resultLocations.push(_location);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (rangeIndex !== this.fragments.length) {
        throw new Error('Expected ranges to correspond to original locations.');
      }
      return resultLocations;
    }
  }]);
  return PaddingTracker;
}();

var TrackedFragment = function () {
  function TrackedFragment(content, start, end, index) {
    classCallCheck(this, TrackedFragment);

    this.content = content;
    this.start = start;
    this.end = end;
    this.index = index;
    this._paddingRanges = [];
    this._lineSeparators = [];
  }

  createClass(TrackedFragment, [{
    key: 'markPadding',
    value: function markPadding(startIndex, endIndex) {
      this._paddingRanges.push({ start: startIndex, end: endIndex });
    }
  }, {
    key: 'markLineSeparator',
    value: function markLineSeparator(index) {
      this._lineSeparators.push(index);
    }
  }, {
    key: 'computeSourceLocations',
    value: function computeSourceLocations() {
      if (this.start === this.end) {
        return [new SourceLocation(STRING_CONTENT, this.start)];
      }

      // Break the marked ranges down into events, similar to how you might count
      // paren nesting. At each index, we can then know if we're inside padding,
      // a line separator, or neither.
      var eventsByIndex = [];
      for (var i = 0; i < this.end - this.start + 1; i++) {
        eventsByIndex.push([]);
      }
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._paddingRanges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var range = _step2.value;

          eventsByIndex[range.start].push('START_PADDING');
          eventsByIndex[range.end].push('END_PADDING');
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this._lineSeparators[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var separatorIndex = _step3.value;

          eventsByIndex[separatorIndex].push('START_LINE_SEPARATOR');
          eventsByIndex[separatorIndex + 1].push('END_LINE_SEPARATOR');
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var resultLocations = [];
      var lastSourceType = null;
      var paddingDepth = 0;
      var lineSeparatorDepth = 0;
      for (var sourceIndex = this.start; sourceIndex < this.end; sourceIndex++) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = eventsByIndex[sourceIndex - this.start][Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var event = _step4.value;

            if (event === 'START_PADDING') {
              paddingDepth += 1;
            } else if (event === 'END_PADDING') {
              paddingDepth -= 1;
            } else if (event === 'START_LINE_SEPARATOR') {
              lineSeparatorDepth += 1;
            } else if (event === 'END_LINE_SEPARATOR') {
              lineSeparatorDepth -= 1;
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        if (paddingDepth < 0 || lineSeparatorDepth < 0 || paddingDepth > 0 && lineSeparatorDepth > 0) {
          throw new Error('Illegal padding state: paddingDepth: ' + paddingDepth + ', lineSeparatorDepth: ' + lineSeparatorDepth);
        }

        var sourceType = void 0;
        if (paddingDepth > 0) {
          sourceType = STRING_PADDING;
        } else if (lineSeparatorDepth > 0) {
          sourceType = STRING_LINE_SEPARATOR;
        } else {
          sourceType = STRING_CONTENT;
        }
        if (sourceType !== lastSourceType) {
          resultLocations.push(new SourceLocation(sourceType, sourceIndex));
          lastSourceType = sourceType;
        }
      }
      return resultLocations;
    }
  }]);
  return TrackedFragment;
}();

/**
 * Compute the whitespace to remove in a multiline single or double quoted
 * string. The algorithm naturally handles handles the case of a string without
 * newlines, so we don't need a special case for that. We also generally need to
 * mark newlines as "line separators" so that later they will be turned into
 * spaces, and extra whitespace at the start and end of each line (except the
 * start of the first line and the end of the last line) is ignored.
 */
function calculateNormalStringPadding(source, stream$$1) {
  var paddingTracker = void 0;
  if (stream$$1.hasNext(SSTRING_START)) {
    paddingTracker = new PaddingTracker(source, stream$$1, SSTRING_END);
  } else if (stream$$1.hasNext(DSTRING_START)) {
    paddingTracker = new PaddingTracker(source, stream$$1, DSTRING_END);
  } else {
    return [];
  }

  // The general strategy is to find each newline character and mark it as a
  // line separator and mark all surrounding whitespace as padding.
  for (var fragmentIndex = 0; fragmentIndex < paddingTracker.fragments.length; fragmentIndex++) {
    var fragment = paddingTracker.fragments[fragmentIndex];
    var content = fragment.content;
    var lastNonWhitespace = -1;
    var pos = 0;

    while (pos < content.length) {
      if (content[pos] === '\n') {
        var startIndex = lastNonWhitespace + 1;
        fragment.markPadding(lastNonWhitespace + 1, pos);
        var newlinePos = pos;
        pos++;
        // Search forward until the next non-whitespace character. Even skip
        // newlines, so that two or more newlines with only spaces between them
        // will result in a single line separator.
        while (pos < content.length && (content[pos] === ' ' || content[pos] === '\t' || content[pos] === '\n')) {
          pos++;
        }
        var endIndex = pos;
        if (isNewlineEscaped(content, newlinePos)) {
          // Escaped newlines behave a bit strangely: whitespace is removed from
          // the right side but not the left side, and the newline and its
          // escape character are removed.
          var backslashPos = content.lastIndexOf('\\', newlinePos);
          fragment.markPadding(backslashPos, endIndex);
        } else if (fragmentIndex === 0 && startIndex === 0 || fragmentIndex === paddingTracker.fragments.length - 1 && endIndex === content.length) {
          // We only want spaces between, not around, lines, so if we're up
          // against the left side or right side of the string, mark the newline
          // as padding.
          fragment.markPadding(startIndex, endIndex);
        } else {
          // Otherwise, the newline should be a line separator that will become
          // a space and everything else should be padding.
          fragment.markPadding(startIndex, newlinePos);
          fragment.markLineSeparator(newlinePos);
          fragment.markPadding(newlinePos + 1, endIndex);
        }
        lastNonWhitespace = pos;
      } else {
        if (content[pos] !== ' ' && content[pos] !== '\t') {
          lastNonWhitespace = pos;
        }
        pos++;
      }
    }
  }
  return paddingTracker.computeSourceLocations();
}

/**
 * A newline character is escaped if it's preceded by an odd number of
 * backslashes. Spaces are allowed between the backslashes and the newline.
 */
function isNewlineEscaped(content, newlinePos) {
  var numSeenBackslashes = 0;
  var prevPos = newlinePos - 1;
  while (prevPos >= 0) {
    var char = content[prevPos];
    if (numSeenBackslashes === 0 && (char === ' ' || char === '\t')) {
      prevPos--;
    } else if (char === '\\') {
      numSeenBackslashes++;
      prevPos--;
    } else {
      break;
    }
  }
  return numSeenBackslashes % 2 == 1;
}

/**
 * Compute the whitespace to remove in a heregexp. All unescaped whitespace
 * characters are removed, and comments are respected.
 */
function calculateHeregexpPadding(source, stream$$1) {
  if (!stream$$1.hasNext(HEREGEXP_START)) {
    return [];
  }
  var paddingTracker = new PaddingTracker(source, stream$$1, HEREGEXP_END);

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = paddingTracker.fragments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var fragment = _step.value;

      var content = fragment.content;
      var pos = 0;
      while (pos < content.length) {
        if (/\s/.test(content[pos])) {
          if (isWhitespaceEscaped(content, pos)) {
            // The escape character should be removed instead of the space.
            fragment.markPadding(pos - 1, pos);
          } else {
            fragment.markPadding(pos, pos + 1);
          }
          pos++;
        } else if (content[pos] === '#' && (pos === 0 || /\s/.test(content[pos - 1]))) {
          var commentStart = pos;
          while (pos < content.length && content[pos] !== '\n') {
            pos++;
          }
          fragment.markPadding(commentStart, pos);
        } else {
          pos++;
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return paddingTracker.computeSourceLocations();
}

/**
 * A space, tab, or newline is escaped if it is preceded by an odd number of
 * backslashes.
 */
function isWhitespaceEscaped(content, whitespacePos) {
  var prevPos = whitespacePos - 1;
  while (prevPos >= 0 && content[prevPos] === '\\') {
    prevPos--;
  }
  return (whitespacePos - prevPos) % 2 == 0;
}

/**
 * Compute the padding (the extra spacing to remove) for the given herestring.
 *
 * CoffeeScript removes spacing in the following situations:
 * - If the first or last line is completely blank, it is removed.
 * - The "common leading whitespace" is removed from each line if possible. This
 *   is computed by taking the smallest nonzero amount of leading whitespace
 *   among all lines except the partial line immediately after the open quotes
 *   and except lines that consist only of whitespace. Note that this "smallest
 *   nonzero amount" behavior doesn't just ignore blank lines; *any* line with
 *   no leading whitespace will be ignored when calculating this value. Even
 *   though the initial partial line has no effect when computing leading
 *   whitespace, the common leading whitespace is still removed from that line
 *   if possible.
 * - Due to a bug in CoffeeScript, if the first full line (the one after the
 *   partial line) is nonempty and has indent zero, the entire string is
 *   considered to have "common leading whitespace" zero.
 * - Due to another bug in CoffeeScript, if the herestring has exactly two lines
 *   that both consist of only whitespace, the whitespace and newline is removed
 *   from the first line, but the second line keeps all of its whitespace.
 *
 * See the stringToken function in lexer.coffee in the CoffeeScript source code
 * for CoffeeScript's implementation of this.
 */
function calculateTripleQuotedStringPadding(source, stream$$1) {
  var paddingTracker = void 0;
  if (stream$$1.hasNext(TSSTRING_START)) {
    paddingTracker = new PaddingTracker(source, stream$$1, TSSTRING_END);
  } else if (stream$$1.hasNext(TDSTRING_START)) {
    paddingTracker = new PaddingTracker(source, stream$$1, TDSTRING_END);
  } else {
    return [];
  }

  var firstFragment = paddingTracker.fragments[0];
  var firstContent = firstFragment.content;
  var lastFragment = paddingTracker.fragments[paddingTracker.fragments.length - 1];
  var lastContent = lastFragment.content;

  var sharedIndent = getIndentForFragments(paddingTracker.fragments);

  if (firstContent.indexOf('\n') > -1 && isWhitespace(firstContent.split('\n')[0])) {
    firstFragment.markPadding(0, firstContent.indexOf('\n') + 1);
  }
  if (!shouldSkipRemovingLastLine(paddingTracker)) {
    var lastLines = lastContent.split('\n');
    if (lastLines.length > 1) {
      var lastLine = lastLines[lastLines.length - 1];
      if (isWhitespace(lastLine)) {
        lastFragment.markPadding(lastFragment.content.length - lastLine.length - 1, lastFragment.content.length);
      }
    }
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = paddingTracker.fragments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var fragment = _step.value;

      for (var i = 0; i < fragment.content.length; i++) {
        var isStartOfLine = i > 0 && fragment.content[i - 1] === '\n';
        var isStartOfString = fragment.index === 0 && i == 0;
        if (isStartOfLine || isStartOfString) {
          var paddingStart = i;
          var paddingEnd = i + sharedIndent.length;
          if (fragment.content.slice(paddingStart, paddingEnd) === sharedIndent) {
            fragment.markPadding(paddingStart, paddingEnd);
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return paddingTracker.computeSourceLocations();
}

function getIndentForFragments(fragments) {
  var hasSeenLine = false;
  var smallestIndent = null;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = fragments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var fragment = _step2.value;

      var lines = fragment.content.split('\n');
      for (var i = 1; i < lines.length; i++) {
        var line = lines[i];
        var indent = getLineIndent(line);

        // Replicate a bug in CoffeeScript: if the first line considered has
        // indentation zero and is nonempty, the empty indentation isn't ignored
        // like it should be, so the empty string is used as the indentation.
        if (!hasSeenLine && indent.length === 0 && line.length > 0) {
          return '';
        }
        hasSeenLine = true;

        if (indent.length === 0 || indent === line) {
          continue;
        }
        if (smallestIndent === null || indent.length < smallestIndent.length) {
          smallestIndent = indent;
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  if (smallestIndent === null) {
    return '';
  }
  return smallestIndent;
}

/**
 * Replicate a bug in CoffeeScript: if the string is whitespace-only with
 * exactly two lines, we run the code to remove the first line but not the last
 * line.
 */
function shouldSkipRemovingLastLine(paddingTracker) {
  if (paddingTracker.fragments.length !== 1) {
    return false;
  }
  var lines = paddingTracker.fragments[0].content.split('\n');
  return lines.length === 2 && isWhitespace(lines[0]) && isWhitespace(lines[1]);
}

function getLineIndent(line) {
  return (/[^\n\S]*/.exec(line)[0]
  );
}

function isWhitespace(line) {
  return (/^[^\n\S]*$/.test(line)
  );
}

/**
 * Generate a list of tokens from CoffeeScript source code.
 */
function lex(source) {
  var location = void 0;
  var previousLocation = void 0;
  var tokens = [];
  var pending = new BufferedStream(stream(source));
  do {
    pending.unshift.apply(pending, toConsumableArray(calculateNormalStringPadding(source, pending)));
    pending.unshift.apply(pending, toConsumableArray(calculateTripleQuotedStringPadding(source, pending)));
    pending.unshift.apply(pending, toConsumableArray(calculateHeregexpPadding(source, pending)));
    pending.unshift.apply(pending, toConsumableArray(combinedLocationsForMultiwordOperators(pending, source)));
    location = pending.shift();
    if (previousLocation && previousLocation.type !== SPACE) {
      tokens.push(new SourceToken(previousLocation.type, previousLocation.index, location.index));
    }
    previousLocation = location;
  } while (location.type !== EOF);
  return new SourceTokenList(tokens);
}

function combinedLocationsForMultiwordOperators(stream, source) {
  if (!stream.hasNext(OPERATOR, SPACE, OPERATOR) && !stream.hasNext(OPERATOR, SPACE, RELATION)) {
    return [];
  }

  var not = stream.shift();
  var space = stream.shift();
  var operator = stream.shift();
  var next = stream.peek();

  if (source.slice(not.index, space.index) === 'not') {
    var op = source.slice(operator.index, next.index);
    switch (op) {
      case 'in':
      case 'of':
        return [new SourceLocation(RELATION, not.index)];

      case 'instanceof':
        return [new SourceLocation(OPERATOR, not.index)];
    }
  }

  // Doesn't match, so put them back.
  return [not, space, operator];
}

var REGEXP_FLAGS = ['i', 'g', 'm', 'y'];

var AT = new SourceType('AT');
var BOOL = new SourceType('BOOL');
var BREAK = new SourceType('BREAK');
var CATCH = new SourceType('CATCH');
var CALL_END = new SourceType('CALL_END');
var CALL_START = new SourceType('CALL_START');
var CLASS = new SourceType('CLASS');
var COLON = new SourceType('COLON');
var COMMA = new SourceType('COMMA');
var COMMENT = new SourceType('COMMENT');
var CONTINUATION = new SourceType('CONTINUATION');
var CONTINUE = new SourceType('CONTINUE');
var DELETE = new SourceType('DELETE');
var DO = new SourceType('DO');
var DOT = new SourceType('DOT');
var DSTRING_START = new SourceType('DSTRING_START');
var DSTRING_END = new SourceType('DSTRING_END');
var ELSE = new SourceType('ELSE');
var EOF = new SourceType('EOF');
var EXISTENCE = new SourceType('EXISTENCE');
var FINALLY = new SourceType('FINALLY');
var FOR = new SourceType('FOR');
var FUNCTION = new SourceType('FUNCTION');
var HERECOMMENT = new SourceType('HERECOMMENT');
var HEREGEXP_START = new SourceType('HEREGEXP_START');
var HEREGEXP_END = new SourceType('HEREGEXP_END');
var IF = new SourceType('IF');
var INTERPOLATION_START = new SourceType('INTERPOLATION_START');
var INTERPOLATION_END = new SourceType('INTERPOLATION_END');
var JS = new SourceType('JS');
var LBRACE = new SourceType('LBRACE');
var LBRACKET = new SourceType('LBRACKET');
var LOOP = new SourceType('LOOP');
var LPAREN = new SourceType('LPAREN');
var NEWLINE = new SourceType('NEWLINE');
var NORMAL = new SourceType('NORMAL');
var NULL = new SourceType('NULL');
var NUMBER = new SourceType('NUMBER');
var OPERATOR = new SourceType('OPERATOR');
var OWN = new SourceType('OWN');
var PROTO = new SourceType('PROTO');
var RANGE = new SourceType('RANGE');
var REGEXP = new SourceType('REGEXP');
var RBRACE = new SourceType('RBRACE');
var RBRACKET = new SourceType('RBRACKET');
var RELATION = new SourceType('RELATION');
var RETURN = new SourceType('RETURN');
var RPAREN = new SourceType('RPAREN');
var SEMICOLON = new SourceType('SEMICOLON');
var SPACE = new SourceType('SPACE');
var SUPER = new SourceType('SUPER');
var SWITCH = new SourceType('SWITCH');
var SSTRING_START = new SourceType('SSTRING_START');
var SSTRING_END = new SourceType('SSTRING_END');
var STRING_CONTENT = new SourceType('STRING_CONTENT');
var STRING_LINE_SEPARATOR = new SourceType('STRING_LINE_SEPARATOR');
var STRING_PADDING = new SourceType('STRING_PADDING');
var TDSTRING_START = new SourceType('TDSTRING_START');
var TDSTRING_END = new SourceType('TDSTRING_END');
var THEN = new SourceType('THEN');
var THIS = new SourceType('THIS');
var TRY = new SourceType('TRY');
var TSSTRING_START = new SourceType('TSSTRING_START');
var TSSTRING_END = new SourceType('TSSTRING_END');
var UNDEFINED = new SourceType('UNDEFINED');
var UNKNOWN = new SourceType('UNKNOWN');
var WHEN = new SourceType('WHEN');
var WHILE = new SourceType('WHILE');
var IDENTIFIER = new SourceType('IDENTIFIER');
var YIELD = new SourceType('YIELD');
var YIELDFROM = new SourceType('YIELDFROM');

/**
 * Borrowed, with tweaks, from CoffeeScript's lexer.coffee.
 */
var STRING = [SSTRING_END, DSTRING_END, TSSTRING_END, TDSTRING_END];
var CALLABLE = [IDENTIFIER, CALL_END, RPAREN, RBRACKET, EXISTENCE, AT, THIS, SUPER];
var INDEXABLE = CALLABLE.concat([NUMBER].concat(STRING, [REGEXP, BOOL, NULL, UNDEFINED, RBRACE, PROTO]));
var NOT_REGEXP = INDEXABLE; // .concat(['++', '--'])

var IDENTIFIER_PATTERN = /^(?!\d)((?:(?!\s)[$\w\x7f-\uffff])+)/;
var NUMBER_PATTERN = /^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;
var SPACE_PATTERN = /^[^\n\r\S]+/;
var REGEXP_PATTERN = /^\/(?!\/)((?:[^[\/\n\\]|\\[^\n]|\[(?:\\[^\n]|[^\]\n\\])*\])*)(\/)?/;
var YIELDFROM_PATTERN = /^yield[^\n\r\S]+from/;

var OPERATORS = [
// equality
'===', '==', '!==', '!=',
// assignment
'=', '+=', '-=', '/=', '*=', '%=', '%%=', '||=', '&&=', '^=', 'or=', 'and=', '?=', '|=', '&=', '~=', '<<=', '>>>=', '>>=',
// increment/decrement
'++', '--',
// math
'+', '-', '//', '/', '*', '%', '%%',
// logical
'||', '&&', '^', '!',
// existence
'?',
// bitwise
'|', '&', '~', '<<', '>>>', '>>',
// comparison
'<=', '<', '>=', '>',
// prototype access
'::'];

/**
 * Provides a stream of source type change locations.
 */
function stream(source) {
  var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  var location = new SourceLocation(NORMAL, index);
  var interpolationStack = [];
  var braceStack = [];
  var parenStack = [];
  var stringStack = [];
  var start = index;
  var locations = [];
  return function step() {
    var lastLocation = location;
    var shouldStepAgain = false;

    do {
      start = index;
      if (index >= source.length) {
        setType(EOF);
      }

      switch (location.type) {
        case NORMAL:
        case SPACE:
        case IDENTIFIER:
        case DOT:
        case NUMBER:
        case OPERATOR:
        case COMMA:
        case LPAREN:
        case RPAREN:
        case CALL_START:
        case CALL_END:
        case LBRACE:
        case RBRACE:
        case LBRACKET:
        case RBRACKET:
        case NEWLINE:
        case COLON:
        case FUNCTION:
        case THIS:
        case AT:
        case SEMICOLON:
        case IF:
        case ELSE:
        case THEN:
        case FOR:
        case OWN:
        case WHILE:
        case BOOL:
        case NULL:
        case UNDEFINED:
        case REGEXP:
        case SSTRING_END:
        case DSTRING_END:
        case TSSTRING_END:
        case TDSTRING_END:
        case INTERPOLATION_START:
        case SUPER:
        case TRY:
        case CATCH:
        case FINALLY:
        case SWITCH:
        case WHEN:
        case BREAK:
        case CONTINUE:
        case EXISTENCE:
        case CLASS:
        case PROTO:
        case RANGE:
        case DELETE:
        case RETURN:
        case RELATION:
        case LOOP:
        case DO:
        case YIELD:
        case YIELDFROM:
        case CONTINUATION:
          if (consume(SPACE_PATTERN)) {
            setType(SPACE);
          } else if (consume('\n')) {
            setType(NEWLINE);
          } else if (consume('...') || consume('..')) {
            setType(RANGE);
          } else if (consume('.')) {
            setType(DOT);
          } else if (consume('"""')) {
            stringStack.push({
              allowInterpolations: true,
              endingDelimiter: '"""',
              endSourceType: TDSTRING_END
            });
            setType(TDSTRING_START);
          } else if (consume('"')) {
            stringStack.push({
              allowInterpolations: true,
              endingDelimiter: '"',
              endSourceType: DSTRING_END
            });
            setType(DSTRING_START);
          } else if (consume('\'\'\'')) {
            stringStack.push({
              allowInterpolations: false,
              endingDelimiter: '\'\'\'',
              endSourceType: TSSTRING_END
            });
            setType(TSSTRING_START);
          } else if (consume('\'')) {
            stringStack.push({
              allowInterpolations: false,
              endingDelimiter: '\'',
              endSourceType: SSTRING_END
            });
            setType(SSTRING_START);
          } else if (consume(/^###[^#]/)) {
            setType(HERECOMMENT);
          } else if (consume('#')) {
            setType(COMMENT);
          } else if (consume('///')) {
            stringStack.push({
              allowInterpolations: true,
              endingDelimiter: '///',
              endSourceType: HEREGEXP_END
            });
            setType(HEREGEXP_START);
          } else if (consume('(')) {
            if (CALLABLE.indexOf(location.type) >= 0) {
              parenStack.push(CALL_START);
              setType(CALL_START);
            } else {
              parenStack.push(LPAREN);
              setType(LPAREN);
            }
          } else if (consume(')')) {
            if (parenStack.length === 0) {
              throw new Error('unexpected \')\' at ' + start);
            } else {
              var lparen = parenStack.pop();
              switch (lparen) {
                case LPAREN:
                  setType(RPAREN);
                  break;

                case CALL_START:
                  setType(CALL_END);
                  break;

                default:
                  throw new Error('unexpected token type for \'(\' matching \')\' at ' + start + ': ' + lparen.toString());
              }
            }
          } else if (consume('[')) {
            setType(LBRACKET);
          } else if (consume(']')) {
            setType(RBRACKET);
          } else if (consume('{')) {
            braceStack.push(start);
            setType(LBRACE);
          } else if (consume('}')) {
            if (braceStack.length === 0) {
              popInterpolation();
            } else {
              braceStack.pop();
              setType(RBRACE);
            }
          } else if (consumeAny(['->', '=>'])) {
            setType(FUNCTION);
          } else if (consumeRegexp()) {
            setType(REGEXP);
          } else if (consume('::')) {
            setType(PROTO);
          } else if (consume(':')) {
            setType(COLON);
          } else if (consume(',')) {
            setType(COMMA);
          } else if (consume('@')) {
            setType(AT);
          } else if (consume(';')) {
            setType(SEMICOLON);
          } else if (consume('`')) {
            setType(JS);
          } else if (consumeAny(OPERATORS)) {
            if (consumed() === '?') {
              setType(EXISTENCE);
            } else {
              setType(OPERATOR);
            }
          } else if (consume(YIELDFROM_PATTERN)) {
            setType(YIELDFROM);
          } else if (consume(IDENTIFIER_PATTERN)) {
            var prevLocationIndex = locations.length - 1;
            while (prevLocationIndex > 0 && locations[prevLocationIndex].type === NEWLINE) {
              prevLocationIndex--;
            }
            var prev = locations[prevLocationIndex];
            if (prev && (prev.type === DOT || prev.type === PROTO || prev.type === AT)) {
              setType(IDENTIFIER);
            } else {
              switch (consumed()) {
                case 'if':
                case 'unless':
                  setType(IF);
                  break;

                case 'else':
                  setType(ELSE);
                  break;

                case 'return':
                  setType(RETURN);
                  break;

                case 'for':
                  setType(FOR);
                  break;

                case 'own':
                  setType(OWN);
                  break;

                case 'while':
                case 'until':
                  setType(WHILE);
                  break;

                case 'loop':
                  setType(LOOP);
                  break;

                case 'then':
                  setType(THEN);
                  break;

                case 'switch':
                  setType(SWITCH);
                  break;

                case 'when':
                  setType(WHEN);
                  break;

                case 'null':
                  setType(NULL);
                  break;

                case 'undefined':
                  setType(UNDEFINED);
                  break;

                case 'this':
                  setType(THIS);
                  break;

                case 'super':
                  setType(SUPER);
                  break;

                case 'true':
                case 'false':
                case 'yes':
                case 'no':
                case 'on':
                case 'off':
                  setType(BOOL);
                  break;

                case 'and':
                case 'or':
                case 'not':
                case 'is':
                case 'isnt':
                case 'instanceof':
                  setType(OPERATOR);
                  break;

                case 'class':
                  setType(CLASS);
                  break;

                case 'break':
                  setType(BREAK);
                  break;

                case 'continue':
                  setType(CONTINUE);
                  break;

                case 'try':
                  setType(TRY);
                  break;

                case 'catch':
                  setType(CATCH);
                  break;

                case 'finally':
                  setType(FINALLY);
                  break;

                case 'delete':
                  setType(DELETE);
                  break;

                case 'in':
                case 'of':
                  setType(RELATION);
                  break;

                case 'do':
                  setType(DO);
                  break;

                case 'yield':
                  setType(YIELD);
                  break;

                default:
                  setType(IDENTIFIER);
              }
            }
          } else if (consume(NUMBER_PATTERN)) {
            setType(NUMBER);
          } else if (consume('\\')) {
            setType(CONTINUATION);
          } else {
            setType(UNKNOWN);
          }
          break;

        case SSTRING_START:
        case DSTRING_START:
        case TSSTRING_START:
        case TDSTRING_START:
        case HEREGEXP_START:
          setType(STRING_CONTENT);
          break;

        case STRING_CONTENT:
          {
            var stringOptions = stringStack[stringStack.length - 1];
            if (!stringOptions) {
              throw new Error('Unexpected STRING_CONTENT without anything on the string stack.');
            }
            if (consume('\\')) {
              index++;
            } else if (consume(stringOptions.endingDelimiter)) {
              stringStack.pop();
              setType(stringOptions.endSourceType);
            } else if (stringOptions.allowInterpolations && consume('#{')) {
              pushInterpolation();
            } else {
              index++;
            }
            break;
          }

        case COMMENT:
          if (consume('\n')) {
            setType(NEWLINE);
          } else {
            index++;
          }
          break;

        case HERECOMMENT:
          if (consume('###')) {
            setType(NORMAL);
          } else {
            index++;
          }
          break;

        case INTERPOLATION_END:
          var _interpolationStack$p = interpolationStack.pop(),
              _type = _interpolationStack$p.type,
              _braces = _interpolationStack$p.braces;

          setType(_type);
          braceStack = _braces;
          break;

        case HEREGEXP_END:
          while (consumeAny(REGEXP_FLAGS)) {}
          setType(NORMAL);
          break;

        case JS:
          if (consume('\\')) {
            index++;
          } else if (consume('`')) {
            setType(NORMAL);
          } else {
            index++;
          }
          break;

        case EOF:
          if (braceStack.length !== 0) {
            throw new Error('unexpected EOF while looking for \'}\' to match \'{\' ' + ('at ' + braceStack[braceStack.length - 1]));
          }
          if (stringStack.length !== 0) {
            throw new Error('unexpected EOF while parsing a string');
          }
          break;

        case UNKNOWN:
          // Jump to the end.
          index = source.length;
          break;

        default:
          throw new Error('unknown source type at offset ' + location.index + ': ' + location.type.name);
      }

      shouldStepAgain =
      // Don't report on going back to "normal" source code.
      location.type === NORMAL ||
      // Don't report if nothing has changed, unless we're at the end.
      location === lastLocation && location.type !== EOF;
    } while (shouldStepAgain);

    locations.push(location);
    return location;
  };

  function consumeAny(strings) {
    return strings.some(function (string) {
      return consume(string);
    });
  }

  function consume(value) {
    var matchData = match(value);
    if (matchData) {
      index += matchData[0].length;
      return true;
    } else {
      return false;
    }
  }

  function consumeRegexp() {
    var matchData = match(REGEXP_PATTERN);
    if (!matchData) {
      return false;
    }

    var _matchData = slicedToArray(matchData, 3),
        regex = _matchData[0],
        body = _matchData[1],
        closed = _matchData[2];

    var prev = locations[locations.length - 1];
    if (prev) {
      var spaced = false;
      if (prev.type === SPACE) {
        spaced = true;
        prev = locations[locations.length - 2];
      }
      if (spaced && CALLABLE.indexOf(prev.type) >= 0) {
        if (!closed || /^\/=?\s/.test(regex)) {
          return false;
        }
      } else if (NOT_REGEXP.indexOf(prev.type) >= 0) {
        return false;
      }
    }
    if (!closed) {
      throw new Error('missing / (unclosed regex)');
    }
    index += regex.length;
    return true;
  }

  function consumed() {
    return source.slice(start, index);
  }

  function setType(newType) {
    location = new SourceLocation(newType, start);
  }

  function match(value) {
    if (typeof value === 'string') {
      var matches = source.slice(index, index + value.length) === value;
      return matches ? [value] : null;
    } else {
      return source.slice(index).match(value);
    }
  }

  function pushInterpolation() {
    interpolationStack.push({ type: location.type, braces: braceStack });
    setType(INTERPOLATION_START);
    braceStack = [];
  }

  function popInterpolation() {
    if (interpolationStack.length === 0) {
      throw new Error('unexpected \'}\' found in string at ' + index + ': ' + JSON.stringify(source));
    }
    setType(INTERPOLATION_END);
  }
}

function consumeStream(lexer) {
  var result = [];
  var location = void 0;
  do {
    location = lexer();
    result.push(location);
  } while (location.type !== EOF);
  return result;
}

exports['default'] = lex;
exports.AT = AT;
exports.BOOL = BOOL;
exports.BREAK = BREAK;
exports.CATCH = CATCH;
exports.CALL_END = CALL_END;
exports.CALL_START = CALL_START;
exports.CLASS = CLASS;
exports.COLON = COLON;
exports.COMMA = COMMA;
exports.COMMENT = COMMENT;
exports.CONTINUATION = CONTINUATION;
exports.CONTINUE = CONTINUE;
exports.DELETE = DELETE;
exports.DO = DO;
exports.DOT = DOT;
exports.DSTRING_START = DSTRING_START;
exports.DSTRING_END = DSTRING_END;
exports.ELSE = ELSE;
exports.EOF = EOF;
exports.EXISTENCE = EXISTENCE;
exports.FINALLY = FINALLY;
exports.FOR = FOR;
exports.FUNCTION = FUNCTION;
exports.HERECOMMENT = HERECOMMENT;
exports.HEREGEXP_START = HEREGEXP_START;
exports.HEREGEXP_END = HEREGEXP_END;
exports.IF = IF;
exports.INTERPOLATION_START = INTERPOLATION_START;
exports.INTERPOLATION_END = INTERPOLATION_END;
exports.JS = JS;
exports.LBRACE = LBRACE;
exports.LBRACKET = LBRACKET;
exports.LOOP = LOOP;
exports.LPAREN = LPAREN;
exports.NEWLINE = NEWLINE;
exports.NORMAL = NORMAL;
exports.NULL = NULL;
exports.NUMBER = NUMBER;
exports.OPERATOR = OPERATOR;
exports.OWN = OWN;
exports.PROTO = PROTO;
exports.RANGE = RANGE;
exports.REGEXP = REGEXP;
exports.RBRACE = RBRACE;
exports.RBRACKET = RBRACKET;
exports.RELATION = RELATION;
exports.RETURN = RETURN;
exports.RPAREN = RPAREN;
exports.SEMICOLON = SEMICOLON;
exports.SPACE = SPACE;
exports.SUPER = SUPER;
exports.SWITCH = SWITCH;
exports.SSTRING_START = SSTRING_START;
exports.SSTRING_END = SSTRING_END;
exports.STRING_CONTENT = STRING_CONTENT;
exports.STRING_LINE_SEPARATOR = STRING_LINE_SEPARATOR;
exports.STRING_PADDING = STRING_PADDING;
exports.TDSTRING_START = TDSTRING_START;
exports.TDSTRING_END = TDSTRING_END;
exports.THEN = THEN;
exports.THIS = THIS;
exports.TRY = TRY;
exports.TSSTRING_START = TSSTRING_START;
exports.TSSTRING_END = TSSTRING_END;
exports.UNDEFINED = UNDEFINED;
exports.UNKNOWN = UNKNOWN;
exports.WHEN = WHEN;
exports.WHILE = WHILE;
exports.IDENTIFIER = IDENTIFIER;
exports.YIELD = YIELD;
exports.YIELDFROM = YIELDFROM;
exports.stream = stream;
exports.consumeStream = consumeStream;

Object.defineProperty(exports, '__esModule', { value: true });

})));
