{"version":3,"file":null,"sources":["../src/utils/debug.js","../src/stages/add-variable-declarations/index.js","../src/stages/semicolons/index.js","../src/stages/esnext/index.js","../src/utils/printTable.js","../src/utils/PatchError.js","../src/utils/determineIndent.js","../src/utils/getStartOfLine.js","../src/utils/getIndent.js","../src/utils/adjustIndent.js","../src/utils/types.js","../src/patchers/NodePatcher.js","../src/stages/main/patchers/ArrayInitialiserPatcher.js","../src/stages/main/patchers/ExpansionPatcher.js","../src/stages/main/patchers/AssignOpPatcher.js","../src/stages/main/patchers/BinaryOpPatcher.js","../src/stages/main/patchers/FunctionApplicationPatcher.js","../src/stages/main/patchers/FunctionPatcher.js","../src/stages/main/patchers/ReturnPatcher.js","../src/stages/main/patchers/BlockPatcher.js","../src/stages/main/patchers/BoolPatcher.js","../src/patchers/PassthroughPatcher.js","../src/stages/main/patchers/IdentifierPatcher.js","../src/stages/main/patchers/ManuallyBoundFunctionPatcher.js","../src/stages/main/patchers/MemberAccessOpPatcher.js","../src/stages/main/patchers/BoundGeneratorFunctionPatcher.js","../src/stages/main/patchers/GeneratorFunctionPatcher.js","../src/utils/escape.js","../src/stages/main/patchers/InterpolatedPatcher.js","../src/stages/main/patchers/StringPatcher.js","../src/stages/main/patchers/ObjectBodyMemberPatcher.js","../src/stages/main/patchers/ThisPatcher.js","../src/stages/main/patchers/ObjectInitialiserMemberPatcher.js","../src/stages/main/patchers/ObjectInitialiserPatcher.js","../src/utils/isObjectInitialiserBlock.js","../src/utils/traverse.js","../src/stages/main/patchers/BoundFunctionPatcher.js","../src/stages/main/patchers/ChainedComparisonOpPatcher.js","../src/stages/main/patchers/ClassBoundMethodFunctionPatcher.js","../src/stages/main/patchers/ClassAssignOpPatcher.js","../src/stages/main/patchers/ConstructorPatcher.js","../src/stages/main/patchers/ClassBlockPatcher.js","../src/stages/main/patchers/ClassPatcher.js","../src/stages/main/patchers/CompoundAssignOpPatcher.js","../src/stages/main/patchers/ConditionalPatcher.js","../src/stages/main/patchers/DefaultParamPatcher.js","../src/stages/main/patchers/DoOpPatcher.js","../src/stages/main/patchers/DynamicMemberAccessOpPatcher.js","../src/stages/main/patchers/EqualityPatcher.js","../src/stages/main/patchers/ExpOpPatcher.js","../src/stages/main/patchers/ExistsOpCompoundAssignOpPatcher.js","../src/stages/main/patchers/ExistsOpPatcher.js","../src/stages/main/patchers/ExtendsOpPatcher.js","../src/stages/main/patchers/FloorDivideOpPatcher.js","../src/stages/main/patchers/LoopPatcher.js","../src/stages/main/patchers/ForPatcher.js","../src/stages/main/patchers/RangePatcher.js","../src/stages/main/patchers/ForInPatcher.js","../src/stages/main/patchers/ForOfPatcher.js","../src/stages/main/patchers/HeregexPatcher.js","../src/stages/main/patchers/InOpPatcher.js","../src/stages/main/patchers/NegatableBinaryOpPatcher.js","../src/stages/main/patchers/InstanceofOpPatcher.js","../src/stages/main/patchers/JavaScriptPatcher.js","../src/stages/main/patchers/UnaryOpPatcher.js","../src/stages/main/patchers/LogicalNotOpPatcher.js","../src/stages/main/patchers/LogicalOpCompoundAssignOpPatcher.js","../src/stages/main/patchers/LogicalOpPatcher.js","../src/stages/main/patchers/ModuloOpPatcher.js","../src/stages/main/patchers/NewOpPatcher.js","../src/stages/main/patchers/OfOpPatcher.js","../src/utils/blank.js","../src/stages/main/patchers/ProgramPatcher.js","../src/stages/main/patchers/ProtoMemberAccessOpPatcher.js","../src/stages/main/patchers/RegExpPatcher.js","../src/stages/main/patchers/SpreadPatcher.js","../src/stages/main/patchers/RestPatcher.js","../src/stages/main/patchers/SeqOpPatcher.js","../src/stages/main/patchers/SlicePatcher.js","../src/stages/main/patchers/SoakedMemberAccessOpPatcher.js","../src/stages/main/patchers/SoakedFunctionApplicationPatcher.js","../src/utils/findSoakContainer.js","../src/stages/main/patchers/SoakedDynamicMemberAccessOpPatcher.js","../src/stages/main/patchers/SuperPatcher.js","../src/stages/main/patchers/SwitchCasePatcher.js","../src/stages/main/patchers/SwitchPatcher.js","../src/stages/main/patchers/ThrowPatcher.js","../src/utils/array/find.js","../src/utils/flatMap.js","../src/utils/leftHandIdentifiers.js","../src/utils/Scope.js","../src/utils/parse.js","../src/stages/TransformCoffeeScriptStage.js","../src/stages/main/patchers/TryPatcher.js","../src/stages/main/patchers/UnaryExistsOpPatcher.js","../src/stages/main/patchers/UnaryMathOpPatcher.js","../src/stages/main/patchers/UnaryTypeofOpPatcher.js","../src/stages/main/patchers/WhilePatcher.js","../src/stages/main/patchers/YieldPatcher.js","../src/stages/main/patchers/YieldFromPatcher.js","../src/stages/main/index.js","../src/stages/normalize/patchers/ArrayInitialiserPatcher.js","../src/stages/normalize/patchers/BlockPatcher.js","../src/stages/normalize/patchers/AssignOpPatcher.js","../src/stages/normalize/patchers/ClassPatcher.js","../src/stages/normalize/patchers/ConditionalPatcher.js","../src/stages/normalize/patchers/ForPatcher.js","../src/stages/normalize/patchers/ForInPatcher.js","../src/stages/normalize/patchers/ForOfPatcher.js","../src/stages/normalize/patchers/FunctionApplicationPatcher.js","../src/stages/normalize/patchers/ObjectInitialiserPatcher.js","../src/stages/normalize/patchers/ObjectInitialiserMemberPatcher.js","../src/stages/normalize/patchers/ProgramPatcher.js","../src/stages/normalize/patchers/WhilePatcher.js","../src/stages/normalize/patchers/DefaultParamPatcher.js","../src/stages/normalize/patchers/MemberAccessOpPatcher.js","../src/stages/normalize/patchers/FunctionPatcher.js","../src/stages/normalize/index.js","../src/utils/convertNewlines.js","../src/utils/detectNewlineStr.js","../src/utils/formatRange.js","../src/utils/formatCoffeeLexTokens.js","../src/utils/formatCoffeeScriptLocationData.js","../src/utils/formatCoffeeScriptAst.js","../src/utils/formatCoffeeScriptLexerTokens.js","../src/utils/formatDecaffeinateParserAst.js","../src/utils/resolveToPatchError.js","../src/cli.js","../src/index.js"],"sourcesContent":["/* @flow */\n\nexport function logger(name: string): (...args: Array<any>) => void {\n  if (isLoggingEnabled(name)) {\n    return (...args) => console.log(name, ...args);\n  } else {\n    return () => {};\n  }\n}\n\nfunction isLoggingEnabled(name: string): boolean {\n  return !!process.env[`DEBUG:${name}`] || !!process.env['DEBUG:*'];\n}\n","import addVariableDeclarations from 'add-variable-declarations';\nimport MagicString from 'magic-string';\nimport { basename } from 'path';\nimport { logger } from '../../utils/debug.js';\n\nexport default class AddVariableDeclarationsStage {\n  static run(content: string, filename: string): { code: string, map: Object } {\n    let log = logger(this.name);\n    log(content);\n\n    let editor = new MagicString(content);\n    addVariableDeclarations(content, editor);\n    return {\n      code: editor.toString(),\n      map: editor.generateMap({\n        source: filename,\n        file: `${basename(filename, '.js')}-${this.name}.js`,\n        includeContent: true\n      })\n    };\n  }\n}\n","import MagicString from 'magic-string';\nimport asi from 'automatic-semicolon-insertion';\nimport buildConfig from 'ast-processor-babylon-config';\nimport { basename } from 'path';\nimport { logger } from '../../utils/debug.js';\nimport { parse } from 'babylon';\n\nconst BABYLON_PLUGINS = [\n  'flow',\n  'jsx',\n  'asyncFunctions',\n  'asyncGenerators',\n  'classConstructorCall',\n  'classProperties',\n  'decorators',\n  'doExpressions',\n  'exponentiationOperator',\n  'exportExtensions',\n  'functionBind',\n  'functionSent',\n  'objectRestSpread',\n  'trailingFunctionCommas'\n];\n\nexport default class SemicolonsStage {\n  static run(content: string, filename: string): { code: string, map: Object } {\n    let log = logger(this.name);\n    log(content);\n\n    let editor = new MagicString(content);\n    let ast = parse(content, { sourceType: 'module', plugins: BABYLON_PLUGINS });\n    let config = buildConfig(content, ast);\n\n    asi(config);\n\n    config.insertions.forEach(({ index, content }) => editor.appendLeft(index, content));\n    config.removals.forEach(({ start, end }) => editor.remove(start, end));\n\n    return {\n      code: editor.toString(),\n      map: editor.generateMap({\n        source: filename,\n        file: `${basename(filename, '.js')}-${this.name}.js`,\n        includeContent: true\n      })\n    };\n  }\n}\n","import { convert } from 'esnext';\nimport { logger } from '../../utils/debug.js';\n\nexport default class EsnextStage {\n  static run(content: string): { code: string } {\n    let log = logger(this.name);\n    log(content);\n\n    let { code } = convert(content, {\n      'declarations.block-scope': {\n        disableConst({ node, parent }): boolean {\n          return (\n            // Only use `const` for top-level variables…\n            parent && parent.type !== 'Program' ||\n            // … as the only variable in its declaration …\n            node.declarations.length !== 1 ||\n            // … without any sort of destructuring …\n            node.declarations[0].id.type !== 'Identifier' ||\n            // … starting with a capital letter.\n            !/^[$_]?[A-Z]+$/.test(node.declarations[0].id.name)\n          );\n        }\n      }\n    });\n    return { code, map: {} };\n  }\n}\n","/* @flow */\n\nimport repeat from 'repeating';\n\ntype Table = {\n  rows: Array<Array<string>>,\n  columns: Array<{ id: string, align: 'left' | 'right' }>\n};\n\nexport default function printTable(table: Table, buffer: string=' '): string {\n  let widths = [];\n  table.rows.forEach(row => {\n    row.forEach((cell, i) => {\n      if (widths.length <= i) {\n        widths[i] = cell.length;\n      }\n      else if (widths[i] < cell.length) {\n        widths[i] = cell.length;\n      }\n    });\n  });\n  let output = '';\n  table.rows.forEach(row => {\n    row.forEach((cell, i) => {\n      let column = table.columns[i];\n      if (column.align === 'left') {\n        output += cell;\n      } else if (column.align === 'right') {\n        output += repeat(' ', widths[i] - cell.length) + cell;\n      }\n      if (i < row.length - 1) {\n        output += buffer;\n      }\n    });\n    output += '\\n';\n  });\n  return output;\n}\n","/* @flow */\n\nimport LinesAndColumns from 'lines-and-columns';\nimport printTable from './printTable.js';\nimport repeat from 'repeating';\n\nexport default class PatchError extends Error {\n  message: string;\n  source: string;\n  start: number;\n  end: number;\n  error: ?Error;\n\n  constructor(message: string, source: string, start: number, end: number, error: ?Error) {\n    super(message);\n    this.message = message;\n    this.source = source;\n    this.start = start;\n    this.end = end;\n    this.error = error;\n  }\n\n  toString(): string {\n    return this.message;\n  }\n\n  /**\n   * Due to babel's inability to simulate extending native types, we have our\n   * own method for determining whether an object is an instance of\n   * `PatchError`.\n   *\n   * @see http://stackoverflow.com/a/33837088/549363\n   */\n  static detect(error: Error): boolean {\n    return (\n      error instanceof Error &&\n      'source' in error &&\n      'start' in error &&\n      'end' in error\n    );\n  }\n\n  static prettyPrint(error: PatchError): string {\n    let { source, start, end, message } = error;\n    let lineMap = new LinesAndColumns(source);\n    let startLoc = lineMap.locationForIndex(start);\n    let endLoc = lineMap.locationForIndex(end);\n\n    if (!startLoc || !endLoc) {\n      throw new Error(`unable to find locations for range: [${start}, ${end})`);\n    }\n\n    let displayStartLine = Math.max(0, startLoc.line - 2);\n    let displayEndLine = endLoc.line + 2;\n\n    let rows = [];\n\n    for (let line = displayStartLine; line <= displayEndLine; line++) {\n      let startOfLine = lineMap.indexForLocation({ line, column: 0 });\n      let endOfLine = lineMap.indexForLocation({ line: line + 1, column: 0 });\n      if (startOfLine === null) {\n        break;\n      }\n      if (endOfLine === null) {\n        endOfLine = source.length;\n      }\n      let lineSource = trimRight(source.slice(startOfLine, endOfLine));\n      if (startLoc.line !== endLoc.line) {\n        if (line >= startLoc.line && line <= endLoc.line) {\n          rows.push(\n            [`>`, `${line + 1} |`, lineSource]\n          );\n        } else {\n          rows.push(\n            [``, `${line + 1} |`, lineSource]\n          );\n        }\n      } else if (line === startLoc.line) {\n        let highlightLength = Math.max(endLoc.column - startLoc.column, 1);\n        rows.push(\n          [`>`, `${line + 1} |`, lineSource],\n          [``, `|`, repeat(' ', startLoc.column) + repeat('^', highlightLength)]\n        );\n      } else {\n        rows.push(\n          [``, `${line + 1} |`, lineSource]\n        );\n      }\n    }\n\n    let columns = [\n      { id: 'marker', align: 'right' },\n      { id: 'line', align: 'right' },\n      { id: 'source', align: 'left' }\n    ];\n\n    return `${message}\\n${printTable({ rows, columns })}`;\n  }\n}\n\nfunction trimRight(string: string): string {\n  return string.replace(/\\s+$/, '');\n}\n","/* @flow */\n\nimport detectIndent from 'detect-indent';\n\nconst DEFAULT_INDENT = '  ';\n\nexport default function determineIndent(source: string): string {\n  let indent = detectIndent(source);\n  if (indent.type === 'space' && indent.amount % 2 === 1) {\n    return DEFAULT_INDENT;\n  }\n  return indent.indent || DEFAULT_INDENT;\n}\n","/* @flow */\n\n/**\n * Finds the start of the line for the character at offset.\n */\nexport default function getStartOfLine(source: string, offset: number): number {\n  let lfIndex = source.lastIndexOf('\\n', offset - 1);\n  if (lfIndex < 0) {\n    return 0;\n  }\n  return lfIndex + 1;\n}\n","/* @flow */\nimport getStartOfLine from './getStartOfLine.js';\n\n/**\n * Gets the indent string for the line containing offset.\n */\nexport default function getIndent(source: string, offset: number): string {\n  let startOfLine = getStartOfLine(source, offset);\n  let indentOffset = startOfLine;\n  let indentCharacter;\n\n  switch (source[indentOffset]) {\n    case ' ':\n    case '\\t':\n      indentCharacter = source[indentOffset];\n      break;\n\n    default:\n      return '';\n  }\n\n  while (source[indentOffset] === indentCharacter) {\n    indentOffset++;\n  }\n\n  return source.slice(startOfLine, indentOffset);\n}\n","/* @flow */\n\nimport determineIndent from './determineIndent.js';\nimport getIndent from './getIndent.js';\n\n/**\n * Adjust an indent in source at a specific offset by an amount.\n */\nexport default function adjustIndent(source: string, offset: number, adjustment: number): string {\n  let currentIndent = getIndent(source, offset);\n  let determinedIndent = determineIndent(source);\n\n  if (adjustment > 0) {\n    while (adjustment--) {\n      currentIndent += determinedIndent;\n    }\n  } else if (adjustment < 0) {\n    currentIndent = currentIndent.slice(determinedIndent.length * -adjustment);\n  }\n\n  return currentIndent;\n}\n","/* @flow */\n\nimport type { Node, SourceToken } from '../patchers/types.js';\nimport { COMMENT, HERECOMMENT, NEWLINE } from 'coffee-lex';\nimport { inspect } from 'util';\n\n/**\n * Determines whether the node is a boolean, optionally with the given value.\n */\nexport function isBool(node: Node, value?: ?(boolean | string)=undefined): boolean {\n  if (node.type !== 'Bool') {\n    return false;\n  }\n\n  switch (typeof value) {\n    case 'undefined':\n      return true;\n\n    case 'boolean':\n      return node.data === value;\n\n    case 'string':\n      return node.raw === value;\n\n    default:\n      throw new Error(`Invalid boolean test value: ${inspect(value)}. Expected a boolean or string.`);\n  }\n}\n\n/**\n * Determines whether a node is a member access operation.\n */\nexport function isMemberAccessOp(node: Node): boolean {\n  return isStaticMemberAccessOp(node) || isDynamicMemberAccessOp(node);\n}\n\n/**\n * Determines whether a node is a static member access, e.g. `a.b`.\n */\nexport function isStaticMemberAccessOp(node: Node): boolean {\n  switch (node.type) {\n    case 'MemberAccessOp':\n    case 'ProtoMemberAccessOp':\n    case 'SoakedMemberAccessOp':\n    case 'SoakedProtoMemberAccessOp':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\n/**\n * Determines whether a node is a dynamic member access, e.g. `a[b]`.\n */\nexport function isDynamicMemberAccessOp(node: Node): boolean {\n  switch (node.type) {\n    case 'DynamicMemberAccessOp':\n    case 'DynamicProtoMemberAccessOp':\n    case 'SoakedDynamicMemberAccessOp':\n    case 'SoakedDynamicProtoMemberAccessOp':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\n/**\n * Determines whether a node represents a function, i.e. `->` or `=>`.\n */\nexport function isFunction(node: Node, allowBound: boolean=true): boolean {\n  return node.type === 'Function' || node.type === 'GeneratorFunction' || (allowBound && node.type === 'BoundFunction');\n}\n\n/**\n * Determines  whether a node is the body of a function.\n *\n * @example\n *\n *   -> 1  # the literal `1` is the function body\n *\n *   ->\n *     2   # the block containing `2` as a statement is the function body\n */\nexport function isFunctionBody(node: Node, allowBound: boolean=true): boolean {\n  let { parentNode } = node;\n\n  if (!parentNode) {\n    return false;\n  }\n\n  return isFunction(parentNode, allowBound) && parentNode.body === node;\n}\n\n/**\n * Determines whether the node is a conditional (i.e. `if` or `unless`).\n */\nexport function isConditional(node: Node): boolean {\n  return node.type === 'Conditional';\n}\n\n/**\n * Determines whether a node represents a `for` loop.\n */\nexport function isForLoop(node: Node): boolean {\n  return node.type === 'ForIn' || node.type === 'ForOf';\n}\n\n/**\n * Determines whether a node represents a `while` loop.\n */\nexport function isWhile(node: Node): boolean {\n  return node.type === 'While';\n}\n\n/**\n * Determines whether a node is the true-part or false-part of a conditional.\n */\nexport function isConsequentOrAlternate(node: Node): boolean {\n  let { parentNode } = node;\n  return parentNode && parentNode.type === 'Conditional' && (\n    parentNode.consequent === node ||\n    parentNode.alternate === node\n  );\n}\n\nexport function isBinaryOperator(node: Node): boolean {\n  switch (node.type) {\n    case 'BitAndOp':\n    case 'BitOrOp':\n    case 'BitXorOp':\n    case 'DivideOp':\n    case 'EQOp':\n    case 'ExistsOp':\n    case 'GTEOp':\n    case 'GTOp':\n    case 'InOp':\n    case 'InstanceofOp':\n    case 'LTEOp':\n    case 'LTOp':\n    case 'LeftShiftOp':\n    case 'LogicalAndOp':\n    case 'LogicalOrOp':\n    case 'ModuloOp':\n    case 'MultiplyOp':\n    case 'NEQOp':\n    case 'OfOp':\n    case 'PlusOp':\n    case 'RemOp':\n    case 'SeqOp':\n    case 'SignedRightShiftOp':\n    case 'SubtractOp':\n    case 'UnsignedRightShiftOp':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nexport function isCall(node: Node): boolean {\n  switch (node && node.type) {\n    case 'FunctionApplication':\n    case 'NewOp':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nexport function isCallArgument(node: Node): boolean {\n  if (node && isCall(node.parentNode)) {\n    return node.parentNode.arguments.indexOf(node) >= 0;\n  } else {\n    return false;\n  }\n}\n\nexport function isShorthandThisObjectMember(node: Node): boolean {\n  return node.type === 'ObjectInitialiserMember' && /^@\\w+$/.test(node.raw);\n}\n\nexport function isStaticMethod(node: Node): boolean {\n  if (node.type !== 'AssignOp') {\n    return false;\n  }\n\n  if (!node.parentNode.parentNode || node.parentNode.parentNode.type !== 'Class') {\n    return false;\n  }\n\n  let { assignee } = node;\n\n  if (assignee.type !== 'MemberAccessOp') {\n    return false;\n  }\n\n  if (node.expression.type !== 'Function') {\n    return false;\n  }\n\n  if (node.expression.type !== 'GeneratorFunction') {\n    return false;\n  }\n\n  return assignee.expression.type === 'This' || (\n    assignee.expression.type === 'Identifier' &&\n    assignee.expression.data === node.parentNode.parentNode.name.data\n  );\n}\n\nconst NON_SEMANTIC_SOURCE_TOKEN_TYPES = [COMMENT, HERECOMMENT, NEWLINE];\n\n/**\n * This isn't a great name because newlines do have semantic meaning in\n * CoffeeScript, but it's close enough.\n */\nexport function isSemanticToken(token: SourceToken): boolean {\n  return NON_SEMANTIC_SOURCE_TOKEN_TYPES.indexOf(token.type) < 0;\n}\n","import PatcherError from '../utils/PatchError.js';\nimport adjustIndent from '../utils/adjustIndent.js';\nimport repeat from 'repeating';\nimport type { SourceType, SourceToken, SourceTokenListIndex, Editor, Node, ParseContext, SourceTokenList } from './types.js';\nimport { CALL_START, CALL_END, LPAREN, RPAREN } from 'coffee-lex';\nimport { isSemanticToken } from '../utils/types.js';\nimport { logger } from '../utils/debug.js';\n\nexport default class NodePatcher {\n  node: Node;\n  context: ParseContext;\n  editor: Editor;\n  log: (...args: Array<any>) => void;\n  parent: ?NodePatcher;\n\n  contentStart: number;\n  contentEnd: number;\n  contentStartTokenIndex: SourceTokenListIndex;\n  contentEndTokenIndex: SourceTokenListIndex;\n  innerStart: number;\n  innerEnd: number;\n  innerStartTokenIndex: SourceTokenListIndex;\n  innerEndTokenIndex: SourceTokenListIndex;\n  outerStart: number;\n  outerEnd: number;\n  outerStartTokenIndex: SourceTokenListIndex;\n  outerEndTokenIndex: SourceTokenListIndex;\n\n  adjustedIndentLevel: number = 0;\n\n  constructor(node: Node, context: ParseContext, editor: Editor) {\n    this.log = logger(this.constructor.name);\n\n    this.node = node;\n    this.context = context;\n    this.editor = editor;\n\n    this.withPrettyErrors(() => this.setupLocationInformation());\n  }\n\n  /**\n   * Allow patcher classes to override the class used to patch their children.\n   */\n  static patcherClassForChildNode(/* node: Node, property: string */): ?Class<NodePatcher> {\n    return null;\n  }\n\n  /**\n   * Allow patcher classes that would patch a node to chose a different class.\n   */\n  static patcherClassOverrideForNode(node: Node): ?Class<NodePatcher> { // eslint-disable-line no-unused-vars\n    return null;\n  }\n\n  /**\n   * @private\n   */\n  setupLocationInformation() {\n    let { node, context } = this;\n\n    if (node.virtual) {\n      return;\n    }\n\n    /**\n     * `contentStart` and `contentEnd` is the exclusive range within the original source that\n     * composes this patcher's node. For example, here's the contentStart and contentEnd of\n     * `a + b` in the expression below:\n     *\n     *   console.log(a + b)\n     *               ^    ^\n     */\n    this.contentStart = node.range[0];\n    this.contentEnd = node.range[1];\n\n    if (this.shouldTrimContentRange()) {\n      this.trimContentRange();\n    }\n\n    let tokens = context.sourceTokens;\n    let firstSourceTokenIndex = tokens.indexOfTokenStartingAtSourceIndex(this.contentStart);\n    let lastSourceTokenIndex = tokens.indexOfTokenEndingAtSourceIndex(this.contentEnd);\n\n    if (!firstSourceTokenIndex || !lastSourceTokenIndex) {\n      if (node.type === 'Program') {\n        // Just an empty program.\n        return;\n      }\n\n      throw this.error(`cannot find first or last token in ${node.type} node`);\n    }\n\n    this.contentStartTokenIndex = firstSourceTokenIndex;\n    this.contentEndTokenIndex = lastSourceTokenIndex;\n\n    let outerStartTokenIndex = firstSourceTokenIndex;\n    let outerEndTokenIndex = lastSourceTokenIndex;\n\n    let innerStartTokenIndex = firstSourceTokenIndex;\n    let innerEndTokenIndex = lastSourceTokenIndex;\n\n    for (;;) {\n      let previousSurroundingTokenIndex = tokens.lastIndexOfTokenMatchingPredicate(\n        isSemanticToken,\n        outerStartTokenIndex.previous()\n      );\n      let nextSurroundingTokenIndex = tokens.indexOfTokenMatchingPredicate(\n        isSemanticToken,\n        outerEndTokenIndex.next()\n      );\n\n      if (!previousSurroundingTokenIndex || !nextSurroundingTokenIndex) {\n        break;\n      }\n\n      let previousSurroundingToken = tokens.tokenAtIndex(previousSurroundingTokenIndex);\n      let nextSurroundingToken = tokens.tokenAtIndex(nextSurroundingTokenIndex);\n\n      if (!previousSurroundingToken || (previousSurroundingToken.type !== LPAREN && previousSurroundingToken.type !== CALL_START)) {\n        break;\n      }\n\n      if (!nextSurroundingToken || (nextSurroundingToken.type !== RPAREN && nextSurroundingToken.type !== CALL_END)) {\n        break;\n      }\n\n      if (innerStartTokenIndex === firstSourceTokenIndex) {\n        innerStartTokenIndex = previousSurroundingTokenIndex;\n      }\n\n      if (innerEndTokenIndex === lastSourceTokenIndex) {\n        innerEndTokenIndex = nextSurroundingTokenIndex;\n      }\n\n      outerStartTokenIndex = previousSurroundingTokenIndex;\n      outerEndTokenIndex = nextSurroundingTokenIndex;\n    }\n\n    this.innerStartTokenIndex = innerStartTokenIndex;\n    this.innerEndTokenIndex = innerEndTokenIndex;\n\n    this.outerStartTokenIndex = outerStartTokenIndex;\n    this.outerEndTokenIndex = outerEndTokenIndex;\n\n    /**\n     * `innerStart`, `innerEnd`, `outerStart` and `outerEnd` refer to the\n     * positions around surrounding parentheses. In most nodes they are the same\n     * as `contentStart` and `contentEnd`. For example:\n     *\n     *              innerStart\n     *                  |\n     *       outerStart | contentStart\n     *                | | |\n     *                ▼ ▼ ▼\n     *            1 * ((  2 + 3  ))\n     *                         ▲ ▲ ▲\n     *                         | | |\n     *                contentEnd | outerEnd\n     *                           |\n     *                        innerEnd\n     */\n    if (innerStartTokenIndex === firstSourceTokenIndex) {\n      this.innerStart = this.contentStart;\n    } else {\n      this.innerStart = tokens.tokenAtIndex(innerStartTokenIndex).end;\n    }\n    if (innerEndTokenIndex === lastSourceTokenIndex) {\n      this.innerEnd = this.contentEnd;\n    } else {\n      this.innerEnd = tokens.tokenAtIndex(innerEndTokenIndex).start;\n    }\n    this.outerStart = tokens.tokenAtIndex(outerStartTokenIndex).start;\n    this.outerEnd = tokens.tokenAtIndex(outerEndTokenIndex).end;\n  }\n\n  /**\n   * Called to trim the range of content for this node. Override in subclasses\n   * to customize its behavior, or override `shouldTrimContentRange` to enable\n   * or disable it.\n   */\n  trimContentRange() {\n    let context = this.context;\n\n    for (;;) {\n      let startChar = context.source[this.contentStart];\n\n      if (startChar === ' ' || startChar === '\\t') {\n        this.contentStart++;\n      } else {\n        break;\n      }\n    }\n\n    for (;;) {\n      let lastChar = context.source[this.contentEnd - 1];\n\n      if (lastChar === ' ' || lastChar === '\\t') {\n        this.contentEnd--;\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Decides whether to trim the content range of this node.\n   */\n  shouldTrimContentRange() {\n    return false;\n  }\n\n  /**\n   * Called when the patcher tree is complete so we can do any processing that\n   * requires communication with other patchers.\n   */\n  initialize() {}\n\n  /**\n   * Calls methods on `editor` to transform the source code represented by\n   * `node` from CoffeeScript to JavaScript. By default this method delegates\n   * to other patcher methods which can be overridden individually.\n   */\n  patch(options={}) {\n    this.withPrettyErrors(() => {\n      if (this.forcedToPatchAsExpression()) {\n        this.patchAsForcedExpression(options);\n      } else if (this.willPatchAsExpression()) {\n        this.patchAsExpression(options);\n      } else {\n        this.patchAsStatement(options);\n      }\n    });\n  }\n\n  /**\n   * Patch the given expression and get the underlying generated code. This is\n   * more robust than calling patch and slice directly, since it also includes\n   * code inserted at contentStart (which normally isn't picked up by slice\n   * because it's inserted to the left of the index boundary). To accomplish\n   * this, we look at the range from contentStart - 1 to contentStart before and\n   * after patching and include anything new that was added.\n   */\n  patchAndGetCode(options={}) {\n    let sliceStart = this.contentStart > 0 ? this.contentStart - 1 : 0;\n    let beforeCode = this.slice(sliceStart, this.contentStart);\n    this.patch(options);\n    let code = this.slice(sliceStart, this.contentEnd);\n    let startIndex = 0;\n    while (startIndex < beforeCode.length &&\n        startIndex < code.length &&\n        beforeCode[startIndex] === code[startIndex]) {\n      startIndex++;\n    }\n    return code.substr(startIndex);\n  }\n\n  /**\n   * Catch errors and throw them again annotated with the current node.\n   */\n  withPrettyErrors(body: () => void) {\n    try {\n      body();\n    } catch (err) {\n      if (!PatcherError.detect(err)) {\n        throw this.error(\n          err.message,\n          this.contentStart,\n          this.contentEnd,\n          err\n        );\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Override this to patch the node as an expression.\n   */\n  patchAsExpression() {\n    throw this.error(`'patchAsExpression' must be overridden in subclasses`);\n  }\n\n  /**\n   * Override this to patch the node as a statement.\n   */\n  patchAsStatement(options={}) {\n    let addParens = this.statementShouldAddParens();\n    if (addParens) {\n      this.insert(this.outerStart, '(');\n    }\n    this.patchAsExpression(options);\n    if (addParens) {\n      this.insert(this.outerEnd, ')');\n    }\n  }\n\n  /**\n   * Override this to patch the node as an expression that would not normally be\n   * an expression, often by wrapping it in an immediately invoked function\n   * expression (IIFE).\n   */\n  patchAsForcedExpression() {\n    this.patchAsExpression();\n  }\n\n  /**\n   * Insert content at the specified index.\n   */\n  insert(index: number, content: string) {\n    if (typeof index !== 'number') {\n      throw new Error(\n        `cannot insert ${JSON.stringify(content)} at non-numeric index ${index}`\n      );\n    }\n    this.log(\n      'INSERT RIGHT',\n      index,\n      JSON.stringify(content),\n      'BEFORE',\n      JSON.stringify(this.context.source.slice(index, index + 8))\n    );\n\n    this.adjustBoundsToInclude(index);\n    this.editor.appendLeft(index, content);\n  }\n\n  allowPatchingOuterBounds(): boolean {\n    return false;\n  }\n\n  /**\n   * @protected\n   */\n  getEditingBounds(): [number, number] {\n    let boundingPatcher = this.getBoundingPatcher();\n    // When we're a function arg, there isn't a great patcher to use to\n    // determine our bounds (we're allowed to patch from the previous\n    // comma/paren to the next comma/paren), so loosen the restriction to the\n    // entire function.\n    if (boundingPatcher.parent &&\n        this.isNodeFunctionApplication(boundingPatcher.parent.node)) {\n      boundingPatcher = boundingPatcher.parent;\n    }\n    if (this.allowPatchingOuterBounds()) {\n      return [boundingPatcher.outerStart, boundingPatcher.outerEnd];\n    } else {\n      return [boundingPatcher.innerStart, boundingPatcher.innerEnd];\n    }\n  }\n\n  /**\n   * @protected\n   */\n  isIndexEditable(index: number): boolean {\n    let [ start, end ] = this.getEditingBounds();\n    return index >= start && index <= end;\n  }\n\n  /**\n   * @protected\n   */\n  assertEditableIndex(index: number) {\n    if (!this.isIndexEditable(index)) {\n      let [ start, end ] = this.getEditingBounds();\n      throw this.error(\n        `cannot edit index ${index} because it is not editable (i.e. outside [${start}, ${end}))`,\n        start,\n        end\n      );\n    }\n  }\n\n  /**\n   * When editing outside a node's bounds we expand the bounds to fit, if\n   * possible. Note that if a node or a node's parent is wrapped in parentheses\n   * we cannot adjust the bounds beyond the inside of the parentheses.\n   *\n   * @private\n   */\n  adjustBoundsToInclude(index: number) {\n    this.assertEditableIndex(index);\n\n    if (index < this.innerStart) {\n      this.log('Moving `innerStart` from', this.innerStart, 'to', index);\n      this.innerStart = index;\n    }\n\n    if (index > this.innerEnd) {\n      this.log('Moving `innerEnd` from', this.innerEnd, 'to', index);\n      this.innerEnd = index;\n    }\n\n    if (index < this.outerStart) {\n      this.log('Moving `outerStart` from', this.outerStart, 'to', index);\n      this.outerStart = index;\n    }\n\n    if (index > this.outerEnd) {\n      this.log('Moving `outerEnd` from', this.outerEnd, 'to', index);\n      this.outerEnd = index;\n    }\n\n    if (this.parent) {\n      this.parent.adjustBoundsToInclude(index);\n    }\n  }\n\n  /**\n   * Replace the content between the start and end indexes with new content.\n   */\n  overwrite(start: number, end: number, content: string) {\n    if (typeof start !== 'number' || typeof end !== 'number') {\n      throw new Error(\n        `cannot overwrite non-numeric range [${start}, ${end}) ` +\n        `with ${JSON.stringify(content)}`\n      );\n    }\n    this.log(\n      'OVERWRITE', `[${start}, ${end})`,\n      JSON.stringify(this.context.source.slice(start, end)),\n      '→', JSON.stringify(content)\n    );\n    this.editor.overwrite(start, end, content);\n  }\n\n  /**\n   * Remove the content between the start and end indexes.\n   */\n  remove(start: number, end: number) {\n    if (typeof start !== 'number' || typeof end !== 'number') {\n      throw new Error(\n        `cannot remove non-numeric range [${start}, ${end})`\n      );\n    }\n    this.log(\n      'REMOVE', `[${start}, ${end})`,\n      JSON.stringify(this.context.source.slice(start, end))\n    );\n    this.editor.remove(start, end);\n  }\n\n  /**\n   * Moves content in a range to another index.\n   */\n  move(start: number, end: number, index: number) {\n    if (typeof start !== 'number' || typeof end !== 'number') {\n      throw this.error(\n        `cannot remove non-numeric range [${start}, ${end})`\n      );\n    }\n    if (typeof index !== 'number') {\n      throw this.error(\n        `cannot move to non-numeric index: ${index}`\n      );\n    }\n    this.log(\n      'MOVE', `[${start}, ${end}) → ${index}`,\n      JSON.stringify(this.context.source.slice(start, end)),\n      'BEFORE', JSON.stringify(this.context.source.slice(index, index + 8))\n    );\n    this.editor.move(start, end, index);\n  }\n\n  /**\n   * Get the current content between the start and end indexes.\n   */\n  slice(start: number, end: number): string {\n    return this.editor.slice(start, end);\n  }\n\n  /**\n   * Determines whether this node starts with a string.\n   */\n  startsWith(string: string): boolean {\n    return this.context.source.slice(this.contentStart, this.contentStart + string.length) === string;\n  }\n\n  /**\n   * Determines whether this node ends with a string.\n   */\n  endsWith(string: string): boolean {\n    return this.context.source.slice(this.contentEnd - string.length, this.contentEnd) === string;\n  }\n\n  /**\n   * Tells us to force this patcher to generate an expression, or else throw.\n   */\n  setRequiresExpression() {\n    this.setExpression(true);\n  }\n\n  /**\n   * Tells us to try to patch as an expression, returning whether it can.\n   */\n  setExpression(force=false): boolean {\n    if (force) {\n      if (!this.canPatchAsExpression()) {\n        throw this.error(`cannot represent ${this.node.type} as an expression`);\n      }\n    } else if (!this.prefersToPatchAsExpression()) {\n      return false;\n    }\n    this._expression = true;\n    return true;\n  }\n\n  /**\n   * Override this to express whether the patcher prefers to be represented as\n   * an expression. By default it's simply an alias for `canPatchAsExpression`.\n   */\n  prefersToPatchAsExpression(): boolean {\n    return this.canPatchAsExpression();\n  }\n\n  /**\n   * Override this if a node cannot be represented as an expression.\n   */\n  canPatchAsExpression(): boolean {\n    return true;\n  }\n\n  /**\n   * Gets whether this patcher is working on a statement or an expression.\n   */\n  willPatchAsExpression(): boolean {\n    return this._expression;\n  }\n\n  /**\n   * Gets whether this patcher was forced to patch its node as an expression.\n   */\n  forcedToPatchAsExpression(): boolean {\n    return this.willPatchAsExpression() && !this.prefersToPatchAsExpression();\n  }\n\n  /**\n   * Gets whether this patcher's node implicitly returns.\n   */\n  implicitlyReturns(): boolean {\n    return this._implicitlyReturns || false;\n  }\n\n  /**\n   * Causes the node to be returned from its function.\n   */\n  setImplicitlyReturns() {\n    this._implicitlyReturns = true;\n  }\n\n  /**\n   * Gets the ancestor that can make implicit returns explicit. Classes that\n   * override this method should override `implicitReturnWillBreak`.\n   */\n  implicitReturnPatcher(): NodePatcher {\n    return this.parent.implicitReturnPatcher();\n  }\n\n  /**\n   * Patch the beginning of an implicitly-returned descendant.\n   */\n  patchImplicitReturnStart(patcher: NodePatcher) {\n    patcher.setRequiresExpression();\n    this.insert(patcher.outerStart, 'return ');\n  }\n\n  /**\n   * Determines whether the implicit return code will stop execution of\n   * statements in the current block. Classes that override this method should\n   * also override `implicitReturnPatcher`.\n   */\n  implicitReturnWillBreak(): boolean {\n    return this.parent.implicitReturnWillBreak();\n  }\n\n  /**\n   * Patch the end of an implicitly-returned descendant.\n   */\n  patchImplicitReturnEnd(patcher: NodePatcher) { // eslint-disable-line no-unused-vars\n    // Nothing to do.\n  }\n\n  /**\n   * Gets whether this patcher's node returns explicitly from its function.\n   */\n  explicitlyReturns(): boolean {\n    return this._returns || false;\n  }\n\n  /**\n   * Marks this patcher's as containing a node that explicitly returns.\n   */\n  setExplicitlyReturns() {\n    this._returns = true;\n    if (this.parent) {\n      this.parent.setExplicitlyReturns();\n    }\n  }\n\n  /**\n   * Determines whether this patcher's node needs a semicolon after it. This\n   * should be overridden in subclasses as appropriate.\n   */\n  statementNeedsSemicolon(): boolean {\n    return true;\n  }\n\n  /**\n   * Determines whether, when appearing as a statement, this patcher's node\n   * needs to be surrounded by parentheses.\n   *\n   * Subclasses should override this and, typically, delegate to their leftmost\n   * child patcher. Subclasses may return `false` when they will insert text at\n   * the start of the node.\n   */\n  statementNeedsParens(): boolean {\n    return false;\n  }\n\n  /**\n   * Determines whether this patcher's node should add parentheses when used in\n   * a statement context.\n   */\n  statementShouldAddParens(): boolean {\n    return this.statementNeedsParens() && !this.isSurroundedByParentheses();\n  }\n\n  /**\n   * Gets the tokens for the whole program.\n   */\n  getProgramSourceTokens(): SourceTokenList {\n    return this.context.sourceTokens;\n  }\n\n  /**\n   * Gets the index of the token starting at a particular source index.\n   */\n  indexOfSourceTokenStartingAtSourceIndex(index: number): ?SourceTokenListIndex {\n    return this.getProgramSourceTokens().indexOfTokenStartingAtSourceIndex(index);\n  }\n\n  /**\n   * Gets the index of the token between left and right patchers that matches\n   * a predicate function.\n   */\n  indexOfSourceTokenBetweenPatchersMatching(left: NodePatcher, right: NodePatcher, predicate: (token: SourceToken) => boolean): ?SourceTokenListIndex {\n    return this.indexOfSourceTokenBetweenSourceIndicesMatching(left.outerEnd, right.outerStart, predicate);\n  }\n\n  /**\n   * Gets the index of the token between source locations that matches a\n   * predicate function.\n   */\n  indexOfSourceTokenBetweenSourceIndicesMatching(left: number, right: number, predicate: (token: SourceToken) => boolean): ?SourceTokenListIndex {\n    return this.getProgramSourceTokens().indexOfTokenMatchingPredicate(token => {\n      return (\n        token.start >= left &&\n        token.start <= right &&\n        predicate(token)\n      );\n    });\n  }\n\n\n  /**\n   * Gets the token at a particular index.\n   */\n  sourceTokenAtIndex(index: SourceTokenListIndex): ?SourceToken {\n    return this.getProgramSourceTokens().tokenAtIndex(index);\n  }\n\n  /**\n   * Gets the source encompassed by the given token.\n   */\n  sourceOfToken(token: SourceToken): string {\n    return this.context.source.slice(token.start, token.end);\n  }\n\n  /**\n   * Gets the first token in the content of this node.\n   */\n  firstToken() {\n    return this.sourceTokenAtIndex(this.contentStartTokenIndex);\n  }\n\n  /**\n   * Gets the last token in the content of this node.\n   */\n  lastToken() {\n    return this.sourceTokenAtIndex(this.contentEndTokenIndex);\n  }\n\n  /**\n   * Gets the original source of this patcher's node.\n   */\n  getOriginalSource(): string {\n    return this.context.source.slice(this.contentStart, this.contentEnd);\n  }\n\n  /**\n   * Determines whether this patcher's node spanned multiple lines.\n   */\n  isMultiline(): boolean {\n    return !this.node.virtual && /\\n/.test(this.getOriginalSource());\n  }\n\n  /**\n   * Gets the patched source of this patcher's node.\n   */\n  getPatchedSource(): string {\n    return this.slice(this.contentStart, this.contentEnd);\n  }\n\n  /**\n   * Gets the index of a token after `contentStart` with the matching type, ignoring\n   * non-semantic types by default.\n   */\n  indexOfSourceTokenAfterSourceTokenIndex(start: SourceTokenListIndex, type: SourceType, predicate: (token: SourceToken) => boolean=isSemanticToken): ?SourceTokenListIndex {\n    let index = this.getProgramSourceTokens()\n      .indexOfTokenMatchingPredicate(predicate, start.next());\n    if (!index) {\n      return null;\n    }\n    let token = this.sourceTokenAtIndex(index);\n    if (!token || token.type !== type) {\n      return null;\n    }\n    return index;\n  }\n\n  /**\n   * Determines whether this patcher's node is followed by a particular token.\n   */\n  hasSourceTokenAfter(type: SourceType, predicate: (token: SourceToken) => boolean=isSemanticToken): boolean {\n    return this.indexOfSourceTokenAfterSourceTokenIndex(this.outerEndTokenIndex, type, predicate) !== null;\n  }\n\n  /**\n   * Determines whether this patcher's node is surrounded by parentheses.\n   * Also check if these parents are matching, to avoid false positives on things like `(a) && (b)`\n   */\n  isSurroundedByParentheses(): boolean {\n    let beforeToken = this.sourceTokenAtIndex(this.outerStartTokenIndex);\n    let afterToken = this.sourceTokenAtIndex(this.outerEndTokenIndex);\n\n    if (!beforeToken || !afterToken) {\n      return false;\n    }\n\n    let leftTokenType = LPAREN;\n    let rightTokenType = RPAREN;\n\n    if (beforeToken.type === LPAREN && afterToken.type === RPAREN) {\n      // nothing\n    } else if (beforeToken.type === CALL_START && afterToken.type === CALL_END) {\n      leftTokenType = CALL_START;\n      rightTokenType = CALL_END;\n    } else {\n      return false;\n    }\n\n    let parenRange = this.getProgramSourceTokens()\n      .rangeOfMatchingTokensContainingTokenIndex(\n        leftTokenType,\n        rightTokenType,\n        this.outerStartTokenIndex\n      );\n    if (!parenRange) return false;\n    let rparenIndex = parenRange[1].previous();\n    let rparen = this.sourceTokenAtIndex(rparenIndex);\n    return rparen === afterToken;\n  }\n\n  surroundInParens() {\n    if (!this.isSurroundedByParentheses()) {\n      this.insert(this.outerStart, '(');\n      this.insert(this.outerEnd, ')');\n    }\n  }\n\n  getBoundingPatcher(): ?NodePatcher {\n    if (this.isSurroundedByParentheses()) {\n      return this;\n    } else if (this.parent) {\n      if (this.isNodeFunctionApplication(this.parent.node) &&\n          this.parent.node.arguments.some(arg => arg === this.node)) {\n        return this;\n      }\n      return this.parent.getBoundingPatcher();\n    } else {\n      return this;\n    }\n  }\n\n  isNodeFunctionApplication(node) {\n    return node.type === 'FunctionApplication' ||\n        node.type === 'SoakedFunctionApplication' ||\n        node.type === 'NewOp';\n  }\n\n  /**\n   * Determines whether this patcher's node can be negated without prepending\n   * a `!`, which turns it into a unary operator node.\n   */\n  canHandleNegationInternally(): boolean {\n    return false;\n  }\n\n  /**\n   * Negates this patcher's node when patching.\n   */\n  negate() {\n    this.insert(this.outerStart, '!');\n  }\n\n  /**\n   * Gets the indent string for the line that starts this patcher's node.\n   */\n  getIndent(offset: number=0): string {\n    return adjustIndent(\n      this.context.source,\n      this.contentStart,\n      this.getAdjustedIndentLevel() + offset\n    );\n  }\n\n  /**\n   * Force the indentation level of this node, adjusting it forward or backward\n   * if necessary. This also sets the \"adjusted indent\" level, so that later\n   * calls to getIndent will return this value.\n   */\n  setIndent(indentStr: string) {\n    let currentIndent = this.getIndent();\n    let indentLength = this.getProgramIndentString().length;\n    let currentIndentLevel = currentIndent.length / indentLength;\n    let desiredIndentLevel = indentStr.length / indentLength;\n    this.indent(desiredIndentLevel - currentIndentLevel);\n  }\n\n  /**\n   * Get the amount the adjusted indent level differs from the original level.\n   */\n  getAdjustedIndentLevel(): number {\n    return (\n      this.adjustedIndentLevel +\n      (this.parent ? this.parent.getAdjustedIndentLevel() : 0)\n    );\n  }\n\n  /**\n   * Gets the indent string used for each indent in this program.\n   */\n  getProgramIndentString(): string {\n    return this.parent.getProgramIndentString();\n  }\n\n  /**\n   * Indent this node a number of times. To unindent, pass a negative number.\n   *\n   * Note that because this method inserts indents immediately before the first\n   * non-whitespace character of each line in the node's source, it should be\n   * called *before* any other editing is done to the node's source to ensure\n   * that strings inserted before child nodes appear after the indent, not\n   * before.\n   */\n  indent(offset: number=1) {\n    if (offset === 0) {\n      return;\n    }\n\n    this.adjustedIndentLevel += offset;\n    let indentString = this.getProgramIndentString();\n    let indentToChange = repeat(indentString, Math.abs(offset));\n    let start = this.outerStart;\n    let end = this.outerEnd;\n    let { source } = this.context;\n\n    // See if there are already non-whitespace characters before the start. If\n    // so, skip the start to the next line, since we don't want to put\n    // indentation in the middle of a line.\n    for (let i = start - 1; i >= 0 && source[i] !== '\\n'; i--) {\n      if (source[i] !== '\\t' && source[i] !== ' ') {\n        while (start < end && source[start] !== '\\n') {\n          start++;\n        }\n        break;\n      }\n    }\n\n    let hasIndentedThisLine = false;\n    for (let i = start; i < end; i++) {\n      switch (source[i]) {\n        case '\\n':\n          hasIndentedThisLine = false;\n          break;\n\n        case ' ':\n        case '\\t':\n          break;\n\n        default:\n          if (!hasIndentedThisLine) {\n            if (offset > 0) {\n              this.insert(i, indentToChange);\n            } else if (source.slice(i - indentToChange.length, i) === indentToChange) {\n              this.remove(i - indentToChange.length, i);\n            } else {\n              throw this.error(\n                `cannot unindent line by ${offset} without enough indent`,\n                i - indentToChange.length,\n                i\n              );\n            }\n            hasIndentedThisLine = true;\n          }\n          break;\n      }\n    }\n  }\n\n  /**\n   * Gets the index ending the line following this patcher's node.\n   *\n   * @private\n   */\n  getEndOfLine(): number {\n    let { source } = this.context;\n    for (let i = this.outerEnd - '\\n'.length; i < source.length; i++) {\n      if (source[i] === '\\n') {\n        return i;\n      }\n    }\n    return source.length;\n  }\n\n  /**\n   * Appends the given content on a new line after the end of the current line.\n   */\n  appendLineAfter(content: string, indentOffset: number=0) {\n    let boundingPatcher = this.getBoundingPatcher();\n    let endOfLine = this.getEndOfLine();\n    this.insert(\n      Math.min(endOfLine, boundingPatcher.innerEnd),\n      `\\n${this.getIndent(indentOffset)}${content}`\n    );\n  }\n\n  /**\n   * Appends the given content at the end of the current line.\n   */\n  appendToEndOfLine(content: string) {\n    let boundingPatcher = this.getBoundingPatcher();\n    let endOfLine = this.getEndOfLine();\n    this.insert(Math.min(endOfLine, boundingPatcher.innerEnd), content);\n  }\n\n  /**\n   * Generate an error referring to a particular section of the source.\n   */\n  error(message: string, start: number=this.contentStart, end: number=this.contentEnd, error: ?Error=null): PatcherError {\n    let patcherError = new PatcherError(message, this.context.source, start, end, error);\n    if (error) { patcherError.stack = error.stack; }\n    return patcherError;\n  }\n\n  /**\n   * Register a helper to be reused in several places.\n   */\n  registerHelper(name: string, code: string): string {\n    return this.parent.registerHelper(name, code);\n  }\n\n  /**\n   * Determines whether this node can be repeated without side-effects. Most\n   * nodes are not repeatable, so that is the default. Subclasses should\n   * override this to indicate whether they are repeatable without any changes.\n   */\n  isRepeatable(): boolean {\n    return false;\n  }\n\n  /**\n   * Alter this node to enable it to be repeated without side-effects. Though\n   * a default implementation is provided, subclasses should override this to\n   * provide a more appropriate version for their particular node type.\n   */\n  makeRepeatable(parens: boolean, ref: ?string=null): string {\n    if (this.isRepeatable()) {\n      // If we can repeat it, just return the original source.\n      return this.getOriginalSource();\n    } else {\n      // Can't repeat it, so we assign it to a free variable and return that,\n      // i.e. `a + b` → `(ref = a + b)`.\n      if (parens) {\n        this.insert(this.innerStart, '(');\n      }\n      ref = this.claimFreeBinding(ref);\n      this.insert(this.innerStart, `${ref} = `);\n      if (parens) {\n        this.insert(this.innerEnd, ')');\n      }\n      return ref;\n    }\n  }\n\n  /**\n   * Claim a binding that is unique in the current scope.\n   */\n  claimFreeBinding(ref: ?string|Array<string>=null): string {\n    return this.node.scope.claimFreeBinding(this.node, ref);\n  }\n\n  /**\n   * Determines whether all the possible code paths in this node are present.\n   */\n  allCodePathsPresent(): boolean {\n    return true;\n  }\n\n  yields() {\n    let receiver = this.parent;\n    while (receiver) {\n      if (receiver.yieldController) {\n        return receiver.yieldController();\n      }\n      receiver = receiver.parent;\n    }\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Editor, Node, ParseContext } from './../../../patchers/types.js';\nimport { COMMA } from 'coffee-lex';\n\nexport default class ArrayInitialiserPatcher extends NodePatcher {\n  members: Array<NodePatcher>;\n  \n  constructor(node: Node, context: ParseContext, editor: Editor, members: Array<NodePatcher>) {\n    super(node, context, editor);\n    this.members = members;\n  }\n\n  initialize() {\n    this.members.forEach(member => member.setRequiresExpression());\n  }\n\n  patchAsExpression() {\n    this.members.forEach((member, i, members) => {\n      let isLast = i === members.length - 1;\n      let needsComma = !isLast && !member.hasSourceTokenAfter(COMMA);\n      member.patch();\n      if (needsComma) {\n        this.insert(member.outerEnd, ',');\n      }\n    });\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\n\nexport default class ExpansionPatcher extends NodePatcher {\n  patchAsExpression() {\n    // Any code handling expansions should process them without calling patch.\n    // If patch ends up being called, then that means that we've hit an\n    // unsupported case that's trying to treat this node as a normal expression.\n    throw this.error(\n      'expansions (e.g. `[a, ..., b] = c`) are not supported yet in all ' +\n      'cases, see https://github.com/decaffeinate/decaffeinate/issues/268'\n    );\n  }\n}\n","import ArrayInitialiserPatcher from './ArrayInitialiserPatcher.js';\nimport ExpansionPatcher from './ExpansionPatcher.js';\nimport NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Node, ParseContext, Editor } from './../../../patchers/types.js';\n\nexport default class AssignOpPatcher extends NodePatcher {\n  assignee: NodePatcher;\n  expression: NodePatcher;\n  \n  constructor(node: Node, context: ParseContext, editor: Editor, assignee: NodePatcher, expression: NodePatcher) {\n    super(node, context, editor);\n    this.assignee = assignee;\n    this.expression = expression;\n  }\n\n  initialize() {\n    this.assignee.setRequiresExpression();\n    this.expression.setRequiresExpression();\n  }\n\n  /**\n   * Assignment operators have lower precedence than negation, so we need to add\n   * parens.\n   */\n  negate() {\n    this.insert(this.innerStart, '!(');\n    this.insert(this.innerEnd, ')');\n  }\n\n  patchAsExpression() {\n    if (this.isExpansionAssignment()) {\n      this.patchExpansionAssignment();\n    } else {\n      this.assignee.patch();\n      this.expression.patch();\n    }\n  }\n\n  statementNeedsParens(): boolean {\n    if (this.isExpansionAssignment()) {\n      return this.expansionAssignmentNeedsParens();\n    } else {\n      // The assignment needs parentheses when the LHS needs parens.\n      return this.assignee.statementShouldAddParens();\n    }\n  }\n\n  expansionAssignmentNeedsParens(): boolean {\n    if (!this.expression.isRepeatable()) {\n      // The left side will be an \"array\" variable.\n      return false;\n    }\n    let expansionIndex = this.getExpansionIndex();\n    if (expansionIndex === this.assignee.members.length - 1) {\n      // Simple case where we leave the array assignment mostly intact.\n      return this.assignee.statementShouldAddParens();\n    } else if (expansionIndex === 0) {\n      // The first non-expansion assignee will end up on the left side.\n      return this.assignee.members[1].statementShouldAddParens();\n    } else {\n      return this.assignee.members[0].statementShouldAddParens();\n    }\n  }\n\n  isExpansionAssignment(): boolean {\n    return this.getExpansionIndex() !== -1;\n  }\n\n  /**\n   * If there is an expansion assignment, return the index of the expansion node.\n   * Otherwise, return -1.\n   */\n  getExpansionIndex(): number {\n    if (!(this.assignee instanceof ArrayInitialiserPatcher)) {\n      return -1;\n    }\n    for (let i = 0; i < this.assignee.members.length; i++) {\n      if (this.assignee.members[i] instanceof ExpansionPatcher) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  patchExpansionAssignment() {\n    let expansionIndex = this.getExpansionIndex();\n    let assignees = this.assignee.members;\n    let expansionNode = assignees[expansionIndex];\n\n    assignees.forEach((assignee, i) => {\n      // Patch everything but the expansion node, since expansion nodes expect\n      // to not be patched.\n      if (i !== expansionIndex) {\n        assignee.patch();\n      }\n    });\n    this.expression.patch();\n    let expressionCode = this.slice(this.expression.contentStart, this.expression.contentEnd);\n\n    // Easy case: [a, b, ...] = c  ->  [a, b] = c\n    if (expansionIndex === assignees.length - 1) {\n      let assigneeBeforeExpansion = assignees[assignees.length - 2];\n      this.remove(assigneeBeforeExpansion.outerEnd, expansionNode.outerEnd);\n      return;\n    }\n\n    // Split into independent assignments. For example, the transformation from\n    // [a, ..., b, c] = d()\n    // to\n    // array = d(), a = array[0], b = array[array.length - 2], c = array[array.length - 1];\n    //\n    // takes these steps:\n    // * Remove the \"...,\".\n    // * Insert \"array = d(), \" on the left.\n    // * Remove \"[\"\n    // * Insert \" = array[index]\" after each assignment (the comma is already there).\n    // * Remove \"] = d()\"\n\n    // Remove \"...,\". We know there's an assignee after the expansion because\n    // otherwise we would have returned above.\n    this.remove(expansionNode.outerStart, assignees[expansionIndex + 1].outerStart);\n\n    let arrReference;\n    if (this.expression.isRepeatable()) {\n      arrReference = expressionCode;\n    } else {\n      arrReference = this.claimFreeBinding('array');\n      this.insert(this.outerStart, `${arrReference} = ${expressionCode}, `);\n    }\n\n    // Remove opening \"[\".\n    this.remove(this.contentStart, assignees[0].outerStart);\n\n    assignees.forEach((assignee, i) => {\n      if (i === expansionIndex) {\n        return;\n      }\n      let key;\n      if (i < expansionIndex) {\n        key = `${i}`;\n      } else {\n        key = `${arrReference}.length - ${assignees.length - i}`;\n      }\n      this.insert(assignee.outerEnd, ` = ${arrReference}[${key}]`);\n    });\n\n    // Remove closing \"]\" and right-side expression.\n    this.remove(assignees[assignees.length - 1].outerEnd, this.contentEnd);\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { SourceToken, Node, ParseContext, Editor } from './../../../patchers/types.js';\nimport { EXISTENCE, OPERATOR } from 'coffee-lex';\n\nexport default class BinaryOpPatcher extends NodePatcher {\n  left: NodePatcher;\n  right: NodePatcher;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, left: NodePatcher, right: NodePatcher) {\n    super(node, context, editor);\n    this.left = left;\n    this.right = right;\n  }\n\n  initialize() {\n    this.left.setRequiresExpression();\n    this.right.setRequiresExpression();\n  }\n\n  /**\n   * Binary operators have lower precedence than negation, so we need to add\n   * parens.\n   */\n  negate() {\n    this.insert(this.innerStart, '!(');\n    this.insert(this.innerEnd, ')');\n  }\n\n  /**\n   * LEFT OP RIGHT\n   */\n  patchAsExpression({ needsParens=false }={}) {\n    let addParens = needsParens && !this.isSurroundedByParentheses();\n    if (addParens) {\n      this.insert(this.outerStart, '(');\n    }\n    if (this.left instanceof BinaryOpPatcher) {\n      this.left.patch({ needsParens: this.getOperator() !== this.left.getOperator() });\n    } else {\n      this.left.patch({ needsParens: true });\n    }\n    this.patchOperator();\n    if (this.right instanceof BinaryOpPatcher) {\n      this.right.patch({ needsParens: this.getOperator() !== this.right.getOperator() });\n    } else {\n      this.right.patch({ needsParens: true });\n    }\n    if (addParens) {\n      this.insert(this.outerEnd, ')');\n    }\n  }\n\n  patchOperator() {\n    // override point for subclasses\n  }\n\n  getOperator(): string {\n    return this.sourceOfToken(this.getOperatorToken());\n  }\n\n  getOperatorToken(): SourceToken {\n    let operatorTokenIndex = this.indexOfSourceTokenBetweenPatchersMatching(\n      this.left,\n      this.right,\n      this.operatorTokenPredicate()\n    );\n    if (!operatorTokenIndex) {\n      throw this.error('expected operator between binary operands');\n    }\n    return this.sourceTokenAtIndex(operatorTokenIndex);\n  }\n\n  operatorTokenPredicate(): (token: SourceToken) => boolean {\n    return (token: SourceToken) => token.type === OPERATOR || token.type === EXISTENCE;\n  }\n\n  /**\n   * IF `LEFT` needs parens then `LEFT + RIGHT` needs parens.\n   */\n  statementNeedsParens(): boolean {\n    return this.left.statementShouldAddParens();\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Editor, Node, ParseContext } from './../../../patchers/types.js';\nimport { COMMA } from 'coffee-lex';\nimport { isSemanticToken } from '../../../utils/types.js';\n\nexport default class FunctionApplicationPatcher extends NodePatcher {\n  fn: NodePatcher;\n  args: Array<NodePatcher>;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, fn: NodePatcher, args: Array<NodePatcher>) {\n    super(node, context, editor);\n    this.fn = fn;\n    this.args = args;\n  }\n\n  initialize() {\n    this.fn.setRequiresExpression();\n    this.args.forEach(arg => arg.setRequiresExpression());\n  }\n\n  /**\n   * Note that we don't need to worry about implicit function applications,\n   * since the normalize stage would have already added parens.\n   */\n  patchAsExpression() {\n    let { args, outerEndTokenIndex } = this;\n\n    this.fn.patch();\n\n    args.forEach((arg, i) => {\n      arg.patch();\n      let isLast = i === args.length - 1;\n      let commaTokenIndex = arg.node.virtual ? null : this.indexOfSourceTokenAfterSourceTokenIndex(\n        arg.outerEndTokenIndex,\n        COMMA,\n        isSemanticToken\n      );\n      // Ignore commas after the end of the function call.\n      if (commaTokenIndex && commaTokenIndex.compare(outerEndTokenIndex) <= 0) {\n        commaTokenIndex = null;\n      }\n      let commaToken = commaTokenIndex && this.sourceTokenAtIndex(commaTokenIndex);\n      if (isLast && commaToken) {\n        this.remove(arg.outerEnd, commaToken.end);\n      } else if (!isLast && !commaToken) {\n        this.insert(arg.outerEnd, ',');\n      }\n    });\n  }\n\n  /**\n   * Probably can't happen, but just for completeness.\n   */\n  statementNeedsParens(): boolean {\n    return this.fn.statementShouldAddParens();\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport FunctionApplicationPatcher from './FunctionApplicationPatcher.js';\nimport type BlockPatcher from './BlockPatcher.js';\nimport type { Node, ParseContext, Editor, SourceToken } from './../../../patchers/types.js';\nimport { CALL_END, COMMA, FUNCTION, LPAREN, RPAREN } from 'coffee-lex';\n\nexport default class FunctionPatcher extends NodePatcher {\n  parameters: Array<NodePatcher>;\n  body: ?BlockPatcher;\n  \n  constructor(node: Node, context: ParseContext, editor: Editor, parameters: Array<NodePatcher>, body: ?NodePatcher) {\n    super(node, context, editor);\n    this.parameters = parameters;\n    this.body = body;\n  }\n\n  initialize() {\n    if (this.body && !this.implicitReturnsDisabled()) {\n      this.body.setImplicitlyReturns();\n    }\n    this.parameters.forEach(param => param.setRequiresExpression());\n  }\n\n  patchAsStatement(options={}) {\n    this.insert(this.innerStart, '(');\n    this.patchAsExpression(options);\n    this.insert(this.innerEnd, ')');\n  }\n\n  patchAsExpression({ method=false }={}) {\n    this.patchFunctionStart({ method });\n    this.parameters.forEach((parameter, i) => {\n      let isLast = i === this.parameters.length - 1;\n      let needsComma = !isLast && !parameter.hasSourceTokenAfter(COMMA);\n      parameter.patch();\n      if (needsComma) {\n        this.insert(parameter.outerEnd, ',');\n      }\n    });\n    this.patchFunctionBody({ method });\n  }\n\n  patchFunctionStart({ method=false }) {\n    let arrow = this.getArrowToken();\n\n    if (!method) {\n      this.insert(this.contentStart, 'function');\n    }\n\n    if (!this.hasParamStart()) {\n      this.insert(this.contentStart, '() ');\n    }\n\n    this.overwrite(arrow.start, arrow.end, '{');\n  }\n\n  patchFunctionBody() {\n    if (this.body) {\n      if (this.isSurroundedByParentheses()) {\n        this.body.patch({ leftBrace: false, rightBrace: false });\n        this.insert(this.innerEnd, this.body.inline() ? ' }' : '}');\n      } else if (this.parent instanceof FunctionApplicationPatcher &&\n          this.parent.args[this.parent.args.length - 1] === this) {\n        // If we're the last argument to a function, place the } just before the\n        // close-paren. There will always be a close-paren because all implicit\n        // parentheses were added in the normalize stage.\n        this.body.patch({ leftBrace: false, rightBrace: false });\n        let closeParenIndex = this.parent.indexOfSourceTokenBetweenSourceIndicesMatching(\n          this.contentEnd, this.parent.contentEnd, token => token.type === CALL_END\n        );\n        let closeParen = this.sourceTokenAtIndex(closeParenIndex);\n        this.insert(closeParen.start, this.body.inline() ? ' }' : '}');\n      } else {\n        this.body.patch({ leftBrace: false });\n      }\n    } else {\n      // No body, so BlockPatcher can't insert it for us.\n      this.insert(this.innerEnd, '}');\n    }\n  }\n\n  getArrowToken(): SourceToken {\n    let arrowIndex = this.contentStartTokenIndex;\n    if (this.hasParamStart()) {\n      let parenRange = this.getProgramSourceTokens()\n        .rangeOfMatchingTokensContainingTokenIndex(\n          LPAREN,\n          RPAREN,\n          this.contentStartTokenIndex\n        );\n      let rparenIndex = parenRange[1].previous();\n      arrowIndex = this.indexOfSourceTokenAfterSourceTokenIndex(\n        rparenIndex,\n        FUNCTION\n      );\n    }\n    let arrow = this.sourceTokenAtIndex(arrowIndex);\n    let expectedArrowType = this.expectedArrowType();\n    let actualArrowType = this.sourceOfToken(arrow);\n    if (actualArrowType !== expectedArrowType) {\n      throw this.error(\n        `expected '${expectedArrowType}' but found ${actualArrowType}`,\n        arrow.start, arrow.end\n      );\n    }\n    return arrow;\n  }\n\n  expectedArrowType(): string {\n    return '->';\n  }\n\n  hasParamStart(): boolean {\n    return this.sourceTokenAtIndex(this.contentStartTokenIndex).type === LPAREN;\n  }\n  \n  implicitReturnPatcher(): NodePatcher {\n    return this;\n  }\n  \n  implicitReturnWillBreak(): boolean {\n    return true;\n  }\n\n  setExplicitlyReturns() {\n    // Stop propagation of return info at functions.\n  }\n\n  /**\n   * Call before initialization to prevent this function from implicitly\n   * returning its last statement.\n   */\n  disableImplicitReturns() {\n    this._implicitReturnsDisabled = true;\n  }\n\n  /**\n   * Determines whether this function has implicit returns disabled.\n   */\n  implicitReturnsDisabled(): boolean {\n    return this._implicitReturnsDisabled;\n  }\n\n  /**\n   * Functions in CoffeeScript are always anonymous and therefore need parens.\n   */\n  statementNeedsParens(): boolean {\n    return true;\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Editor, Node, ParseContext } from './../../../patchers/types.js';\n\nexport default class ReturnPatcher extends NodePatcher {\n  expression: NodePatcher;\n  \n  constructor(node: Node, context: ParseContext, editor: Editor, expression: ?NodePatcher) {\n    super(node, context, editor);\n    this.expression = expression;\n  }\n\n  initialize() {\n    this.setExplicitlyReturns();\n    if (this.expression !== null) {\n      this.expression.setRequiresExpression();\n    }\n  }\n\n  /**\n   * Return statements cannot be expressions.\n   */\n  canPatchAsExpression(): boolean {\n    return false;\n  }\n\n  patchAsStatement() {\n    if (this.expression) {\n      this.expression.patch();\n    }\n  }\n}\n","import FunctionPatcher from './FunctionPatcher.js';\nimport NodePatcher from './../../../patchers/NodePatcher.js';\nimport ReturnPatcher from './ReturnPatcher.js';\nimport type { SourceToken, Node, ParseContext, Editor } from './../../../patchers/types.js';\nimport { NEWLINE, SEMICOLON } from 'coffee-lex';\n\nexport default class BlockPatcher extends NodePatcher {\n  statements: Array<NodePatcher>;\n  shouldPatchInline: ?boolean;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, statements: Array<NodePatcher>) {\n    super(node, context, editor);\n    this.statements = statements;\n    this.shouldPatchInline = null;\n  }\n\n  canPatchAsExpression(): boolean {\n    return this.statements.every(\n      statement => statement.prefersToPatchAsExpression()\n    );\n  }\n\n  setExpression(force=false): boolean {\n    let willPatchAsExpression = super.setExpression(force);\n    if (willPatchAsExpression && this.prefersToPatchAsExpression()) {\n      this.statements.forEach(statement => statement.setExpression());\n    }\n  }\n\n  setImplicitlyReturns() {\n    this.statements[this.statements.length - 1].setImplicitlyReturns();\n  }\n\n  /**\n   * Force the patcher to treat the block as inline (semicolon-separated\n   * statements) or not (newline-separated statements).\n   */\n  setShouldPatchInline(shouldPatchInline: boolean) {\n    this.shouldPatchInline = shouldPatchInline;\n  }\n\n  patchAsStatement({ leftBrace=true, rightBrace=true }={}) {\n    if (leftBrace) {\n      this.insert(this.innerStart, '{');\n    }\n\n    this.statements.forEach(\n      (statement, i, statements) => {\n        if (i === statements.length - 1 && this.parent instanceof FunctionPatcher) {\n          if (statement instanceof ReturnPatcher && !statement.expression) {\n            let removeStart;\n            if (statements.length > 1) {\n              let startOfLineIndex = this.context.sourceTokens.lastIndexOfTokenMatchingPredicate(\n                token => token.type === NEWLINE || token.type === SEMICOLON,\n                statement.outerStartTokenIndex\n              );\n              removeStart = this.sourceTokenAtIndex(startOfLineIndex).start;\n            } else {\n              removeStart = statement.outerStart;\n            }\n            this.remove(\n              removeStart,\n              statement.outerEnd\n            );\n            return;\n          }\n        }\n        if (statement.isSurroundedByParentheses()) {\n          statement.setRequiresExpression();\n        }\n        let hasImplicitReturn = (\n          statement.implicitlyReturns() &&\n          !statement.explicitlyReturns()\n        );\n        let implicitReturnPatcher = hasImplicitReturn ?\n          this.implicitReturnPatcher() : null;\n        if (implicitReturnPatcher) {\n          implicitReturnPatcher.patchImplicitReturnStart(statement);\n        }\n        statement.patch();\n        if (implicitReturnPatcher) {\n          implicitReturnPatcher.patchImplicitReturnEnd(statement);\n        }\n        if (statement.statementNeedsSemicolon()) {\n          this.insert(statement.outerEnd, ';');\n        }\n      }\n    );\n\n    if (rightBrace) {\n      if (this.inline()) {\n        this.insert(this.innerEnd, ' }');\n      } else {\n        this.appendLineAfter('}', -1);\n      }\n    }\n  }\n\n  patchAsExpression({\n    leftBrace=this.statements.length > 1,\n    rightBrace=this.statements.length > 1\n    }={}) {\n    if (leftBrace) {\n      this.insert(this.innerStart, '(');\n    }\n    this.statements.forEach(\n      (statement, i, statements) => {\n        statement.patch();\n        if (i !== statements.length - 1) {\n          let semicolonTokenIndex = this.getSemicolonSourceTokenBetween(\n            statement,\n            statements[i + 1]\n          );\n          if (semicolonTokenIndex) {\n            let semicolonToken = this.sourceTokenAtIndex(semicolonTokenIndex);\n            this.overwrite(semicolonToken.start, semicolonToken.end, ',');\n          } else {\n            this.insert(statement.outerEnd, ',');\n          }\n        }\n      }\n    );\n    if (rightBrace) {\n      this.insert(this.innerEnd, ')');\n    }\n  }\n\n  /**\n   * Insert statements somewhere in this block.\n   */\n  insertStatementsAtIndex(statements: Array<string>, index: number) {\n    let separator = this.inline() ? '; ' : ';\\n';\n    if (index === this.statements.length) {\n      let lastStatement = this.statements[this.statements.length - 1];\n      let terminatorTokenIndex = this.context.sourceTokens.indexOfTokenMatchingPredicate(\n        token => token.type === NEWLINE || token.type === SEMICOLON,\n        lastStatement.outerEndTokenIndex\n      );\n      let insertionPoint = terminatorTokenIndex ?\n        this.sourceTokenAtIndex(terminatorTokenIndex).start :\n        lastStatement.outerEnd;\n      let indent = lastStatement.getIndent();\n      statements.forEach(line => this.insert(insertionPoint, `${separator}${indent}${line}`));\n    } else {\n      let statementToInsertBefore = this.statements[index];\n      let insertionPoint = statementToInsertBefore.outerStart;\n      let indent = statementToInsertBefore.getIndent();\n      statements.forEach(line => this.insert(insertionPoint, `${line}${separator}${indent}`));\n    }\n  }\n\n  /**\n   * Insert a statement before the current block. Since blocks can be patched in\n   * a number of ways, this needs to handle a few cases:\n   * - If it's completely inline, we don't deal with any indentation and just\n   *   put a semicolon-separated statement before the start.\n   * - If it's a normal non-inline block, we insert the statement beforehand\n   *   with the given indentation. However, `this.outerStart` is the first\n   *   non-whitespace character of the first line, so it's already indented, so\n   *   if we want to add a line with *less* indentation, it's a lot more tricky.\n   *   We handle this by walking backward to the previous newline and inserting\n   *   a new line from there. This allows the prepended line to have whatever\n   *   indentation level we want.\n   * - In some cases, such as nontrivial loop expressions with an inline body,\n   *   the source CoffeeScript is inline, but we want the result to be\n   *   non-inline, so we need to be a lot more careful. The normal non-inline\n   *   strategy won't work because there's no newline to walk back to in the\n   *   source CoffeeScript, so the strategy is to instead always insert at\n   *   `this.outerStart`. That means that the indentation for the actual body\n   *   needs to be done later, just before the body itself is patched. See the\n   *   uses of shouldConvertInlineBodyToNonInline in LoopPatcher for an example.\n   */\n  insertLineBefore(statement: string, indent: string) {\n    if (this.inline()) {\n      this.insert(this.outerStart, `${statement}; `);\n    } else if (this.node.inline) {\n      if (indent === null) {\n        indent = this.getIndent();\n      }\n      this.insert(this.outerStart, `${indent}${statement};\\n`);\n    } else {\n      let insertIndex = this.outerStart;\n      while (insertIndex > 0 && this.context.source[insertIndex] !== '\\n') {\n        insertIndex--;\n      }\n      this.insert(insertIndex, `\\n${indent}${statement};`);\n    }\n  }\n\n  insertLineAfter(statement: string, indent: string) {\n    if (this.inline()) {\n      this.insert(this.outerEnd, `; ${statement}`);\n    } else {\n      this.insert(this.outerEnd, `\\n${indent}${statement};`);\n    }\n  }\n\n  /**\n   * @private\n   */\n  getSemicolonSourceTokenBetween(left: NodePatcher, right: NodePatcher): ?SourceToken {\n    return this.indexOfSourceTokenBetweenPatchersMatching(\n      left,\n      right,\n      token => token.type === SEMICOLON\n    );\n  }\n\n  /**\n   * Gets whether this patcher's block is inline (on the same line as the node\n   * that contains it) or not.\n   */\n  inline(): boolean {\n    if (this.shouldPatchInline !== null) {\n      return this.shouldPatchInline;\n    }\n    return this.node.inline;\n  }\n\n  /**\n   * Blocks only exit via the last statement, so we check its code paths.\n   */\n  allCodePathsPresent(): boolean {\n    return this.statements[this.statements.length - 1].allCodePathsPresent();\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\n\nexport default class BoolPatcher extends NodePatcher {\n  patchAsExpression() {\n    switch (this.getOriginalSource()) {\n      case 'off':\n      case 'no':\n        this.overwrite(this.contentStart, this.contentEnd, 'false');\n        break;\n\n      case 'on':\n      case 'yes':\n        this.overwrite(this.contentStart, this.contentEnd, 'true');\n        break;\n    }\n  }\n}\n","import NodePatcher from './NodePatcher.js';\nimport type { Editor, Node, ParseContext } from './types.js';\n\nexport default class PassthroughPatcher extends NodePatcher {\n  children: Array<?NodePatcher|Array<?NodePatcher>>;\n  \n  constructor(node: Node, context: ParseContext, editor: Editor, ...children: Array<?NodePatcher|Array<?NodePatcher>>) {\n    super(node, context, editor);\n    this.children = children;\n  }\n\n  patch() {\n    this.withPrettyErrors(() => {\n      this.children.forEach(child => {\n        if (Array.isArray(child)) {\n          child.forEach(child => child && child.patch());\n        } else if (child) {\n          child.patch();\n        }\n      });\n    });\n  }\n\n  isRepeatable(): boolean {\n    return true;\n  }\n}\n","import PassthroughPatcher from './../../../patchers/PassthroughPatcher.js';\n\nexport default class IdentifierPatcher extends PassthroughPatcher {\n  negate() {\n    this.insert(this.contentStart, '!');\n  }\n\n  isRepeatable(): boolean {\n    return true;\n  }\n\n  /**\n   * Currently, break and continue are parsed as identifiers, but they need to\n   * behave differently in some cases.\n   */\n  canPatchAsExpression(): boolean {\n    return this.node.data !== 'break' && this.node.data !== 'continue';\n  }\n}\n","import FunctionPatcher from './FunctionPatcher.js';\n\n/**\n * Handles bound functions that cannot become arrow functions.\n */\nexport default class ManuallyBoundFunctionPatcher extends FunctionPatcher {\n  patchAsStatement(options={}) {\n    this.insert(this.contentStart, '(');\n    super.patchAsExpression(options);\n    this.insert(this.contentEnd, '.bind(this))');\n  }\n\n  patchAsExpression(options={}) {\n    super.patchAsExpression(options);\n    // If we're instructed to patch as a method, then it won't be legal to add\n    // `.bind(this)`, so skip that step. Calling code is expected to bind us\n    // some other way. In practice, this happens when patching class methods;\n    // code will be added to the constructor to bind the method properly.\n    if (!options.method) {\n      this.insert(this.contentEnd, '.bind(this)');\n    }\n  }\n\n  expectedArrowType(): string {\n    return '=>';\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Node, ParseContext, Editor, SourceToken } from './../../../patchers/types.js';\nimport { AT, DOT, IDENTIFIER, PROTO } from 'coffee-lex';\n\nexport default class MemberAccessOpPatcher extends NodePatcher {\n  expression: NodePatcher;\n  _skipImplicitDotCreation: boolean;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, expression: NodePatcher) {\n    super(node, context, editor);\n    this.expression = expression;\n    this._skipImplicitDotCreation = false;\n  }\n\n  initialize() {\n    this.expression.setRequiresExpression();\n  }\n\n  setSkipImplicitDotCreation() {\n    this._skipImplicitDotCreation = true;\n  }\n\n  patchAsExpression() {\n    if (this.lhsNeedsParens()) {\n      this.insert(this.expression.outerStart, '(');\n    }\n    this.expression.patch();\n    if (this.lhsNeedsParens()) {\n      this.insert(this.expression.outerEnd, ')');\n    }\n    if (this.isShorthandPrototype()) {\n      // `a::` → `a.prototype`\n      //   ^^      ^^^^^^^^^^\n      let operator = this.getMemberOperatorSourceToken();\n      this.overwrite(operator.start, operator.end, '.prototype');\n    }\n    if (this.hasImplicitOperator() && !this._skipImplicitDotCreation) {\n      // `@a` → `@.a`\n      //          ^\n      this.insert(this.expression.outerEnd, '.');\n    }\n  }\n\n  hasImplicitOperator(): boolean {\n    return !this.getMemberOperatorSourceToken();\n  }\n\n  isShorthandPrototype(): boolean {\n    let token = this.getMemberOperatorSourceToken();\n    return token ? token.type === PROTO : false;\n  }\n\n  getMemberOperatorSourceToken(): ?SourceToken {\n    let lastIndex = this.contentEndTokenIndex;\n    let lastToken = this.sourceTokenAtIndex(lastIndex);\n\n    if (lastToken.type === PROTO) {\n      // e.g. `a::`\n      return lastToken;\n    }\n\n    let dotIndex = this.indexOfSourceTokenAfterSourceTokenIndex(\n      this.expression.outerEndTokenIndex,\n      DOT\n    );\n\n    if (!dotIndex) {\n      let firstIndex = this.contentStartTokenIndex;\n      let firstToken = this.sourceTokenAtIndex(firstIndex);\n\n      if (firstToken.type === AT) {\n        // e.g. `@a`, so it's okay that there's no dot\n        return null;\n      }\n\n      throw this.error(`cannot find '.' in member access`);\n    }\n\n    // e.g. `a.b`\n    return this.sourceTokenAtIndex(dotIndex);\n  }\n\n  getMemberName(): string {\n    return this.node.memberName;\n  }\n\n  getFullMemberName(): string {\n    return this.getMemberName();\n  }\n\n  getMemberNameSourceToken(): SourceToken {\n    let tokens = this.context.sourceTokens;\n    let index = tokens.lastIndexOfTokenMatchingPredicate(\n      token => token.type === IDENTIFIER,\n      this.contentEndTokenIndex\n    );\n    if (!index || index.isBefore(this.contentStartTokenIndex)) {\n      throw this.error(`unable to find member name token in access`);\n    }\n    return tokens.tokenAtIndex(index);\n  }\n\n  /**\n   * Member access is repeatable (in CoffeeScript) if the expression we're\n   * accessing a member of is also repeatable. Technically speaking even this is\n   * not safe since member access can have side-effects via getters and setters,\n   * but this is the way the official CoffeeScript compiler works so we follow\n   * suit.\n   */\n  isRepeatable(): boolean {\n    return this.expression.isRepeatable();\n  }\n\n  /**\n   * We can make member accesses repeatable by making the base expression\n   * repeatable if it isn't already.\n   */\n  makeRepeatable(parens: boolean, ref: ?string=null) { // eslint-disable-line no-unused-vars\n    let expression = this.expression.makeRepeatable(true, 'base');\n    return `${expression}.${this.getFullMemberName()}`;\n  }\n\n  /**\n   * If `BASE` needs parens, then `BASE.MEMBER` needs parens.\n   */\n  statementNeedsParens(): boolean {\n    return this.expression.statementShouldAddParens();\n  }\n\n  lhsNeedsParens() {\n    return this.expression.node.type === 'Int';\n  }\n}\n","import ManuallyBoundFunctionPatcher from './ManuallyBoundFunctionPatcher.js';\n\nexport default class BoundGeneratorFunctionPatcher extends ManuallyBoundFunctionPatcher {\n  patchFunctionStart({ method=false }) {\n    let arrow = this.getArrowToken();\n\n    if (!method) {\n      this.insert(this.contentStart, 'function*');\n    }\n\n    if (!this.hasParamStart()) {\n      this.insert(this.contentStart, '() ');\n    }\n\n    this.overwrite(arrow.start, arrow.end, '{');\n  }\n}\n","import FunctionPatcher from './FunctionPatcher.js';\n\n/**\n * Handles generator functions, i.e. produced by embedding `yield` statements.\n */\nexport default class GeneratorFunctionPatcher extends FunctionPatcher {\n  patchFunctionStart({ method=false }) {\n    let arrow = this.getArrowToken();\n\n    if (!method) {\n      this.insert(this.contentStart, 'function*');\n    }\n    \n    if (!this.hasParamStart()) {\n      this.insert(this.contentStart, '() ');\n    }\n\n    this.overwrite(arrow.start, arrow.end, '{');\n  }\n}\n","/* @flow */\n\nimport type MagicString from 'magic-string';\n\n/**\n * Inserts string escape characters before certain characters/strings to be\n * escaped.\n *\n * The skipPattern parameter describes which already-escaped characters to skip\n * over. For normal strings, if we see any backslash, we skip it and the next\n * character, but for heregexes, we only skip a backslash followed by\n * whitespace.\n */\nexport default function escape(patcher: MagicString, skipPattern: RegExp, escapeStrings: Array<string>, start: number, end: number) {\n  let source = patcher.original;\n  for (let i = start; i < end; i++) {\n    if (skipPattern.test(source.slice(i))) {\n      i++;\n    } else if (escapeStrings.some(str => source.slice(i, i + str.length) === str)) {\n      patcher.appendRight(i, '\\\\');\n    }\n  }\n}\n","import { INTERPOLATION_START, STRING_LINE_SEPARATOR, STRING_PADDING } from 'coffee-lex';\nimport repeat from 'repeating';\n\nimport NodePatcher from './../../../patchers/NodePatcher.js';\nimport escape from '../../../utils/escape.js';\n\nexport default class InterpolatedPatcher extends NodePatcher {\n  quasis: Array<NodePatcher>;\n  expressions: Array<NodePatcher>;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, quasis: Array<NodePatcher>, expressions: Array<NodePatcher>) {\n    super(node, context, editor);\n    this.quasis = quasis;\n    this.expressions = expressions;\n  }\n\n  initialize() {\n    for (let expression of this.expressions) {\n      expression.setRequiresExpression();\n    }\n  }\n\n  patchInterpolations() {\n    for (let i = 0; i < this.expressions.length; i++) {\n      let interpolationStart = this.getInterpolationStartTokenAtIndex(i);\n      this.overwrite(interpolationStart.start, interpolationStart.start + 1, '$');\n      this.expressions[i].patch();\n    }\n  }\n\n  getInterpolationStartTokenAtIndex(index: number): SourceToken {\n    let interpolationStartIndex = this.indexOfSourceTokenBetweenPatchersMatching(\n      this.quasis[index], this.expressions[index], token => token.type === INTERPOLATION_START\n    );\n    if (!interpolationStartIndex) {\n      this.error('Cannot find interpolation start for string interpolation.');\n    }\n    let interpolationStart = this.sourceTokenAtIndex(interpolationStartIndex);\n    if (!interpolationStart ||\n      this.slice(interpolationStart.start, interpolationStart.start + 1) !== '#') {\n      this.error(\"Cannot find '#' in interpolation start.\");\n    }\n    return interpolationStart;\n  }\n\n  /**\n   * Handle \"padding\" characters: characters like leading whitespace that should\n   * be removed according to the lexing rules. In addition to STRING_PADDING\n   * tokens, which indicate that the range should be removed, there are also\n   * STRING_LINE_SEPARATOR tokens that indicate that the newlines should be\n   * replaced with a space.\n   *\n   * To preserve the formatting of multiline strings a little better, newline\n   * characters are escaped rather than removed.\n   */\n  removePadding() {\n    for (let quasi of this.quasis) {\n      let tokens = this.getProgramSourceTokens().slice(\n        quasi.contentStartTokenIndex, quasi.contentEndTokenIndex.next()).toArray();\n      for (let token of tokens) {\n        if (token.type === STRING_PADDING) {\n          let paddingCode = this.slice(token.start, token.end);\n          let numNewlines = (paddingCode.match(/\\n/g) || []).length;\n          this.overwrite(token.start, token.end, repeat('\\\\\\n', numNewlines));\n        } else if (token.type === STRING_LINE_SEPARATOR) {\n          this.insert(token.start, ' \\\\');\n        }\n      }\n    }\n  }\n\n  escapeQuasis(skipPattern, escapeStrings) {\n    for (let quasi of this.quasis) {\n      escape(\n        this.editor,\n        skipPattern,\n        escapeStrings,\n        // For now, clamp the quasi bounds to be strictly between the quotes.\n        // Ideally, decaffeinate-parser would provide better location data\n        // that would make this unnecessary.\n        Math.max(quasi.contentStart, this.firstToken().end),\n        Math.min(quasi.contentEnd, this.lastToken().start),\n      );\n    }\n  }\n\n  isRepeatable() {\n    return this.expressions.every(patcher => patcher.isRepeatable());\n  }\n}\n","import { TSSTRING_START, TDSTRING_START } from 'coffee-lex';\n\nimport InterpolatedPatcher from './InterpolatedPatcher.js';\n\n/**\n * Patcher to handle all types of strings, whether or not they have\n * interpolations and whether or not they are multiline.\n */\nexport default class StringPatcher extends InterpolatedPatcher {\n  patchAsExpression() {\n    let shouldBecomeTemplateLiteral = this.shouldBecomeTemplateLiteral();\n\n    let escapeStrings = [];\n    let openQuoteToken = this.firstToken();\n    let closeQuoteToken = this.lastToken();\n\n    if (shouldBecomeTemplateLiteral) {\n      escapeStrings.push('`');\n      escapeStrings.push('${');\n      this.overwrite(openQuoteToken.start, openQuoteToken.end, '`');\n      this.overwrite(closeQuoteToken.start, closeQuoteToken.end, '`');\n    } else if (openQuoteToken.type === TSSTRING_START) {\n      escapeStrings.push('\\'');\n      this.overwrite(openQuoteToken.start, openQuoteToken.end, '\\'');\n      this.overwrite(closeQuoteToken.start, closeQuoteToken.end, '\\'');\n    } else if (openQuoteToken.type === TDSTRING_START) {\n      escapeStrings.push('\"');\n      this.overwrite(openQuoteToken.start, openQuoteToken.end, '\"');\n      this.overwrite(closeQuoteToken.start, closeQuoteToken.end, '\"');\n    }\n\n    this.patchInterpolations();\n    this.removePadding();\n    if (escapeStrings.length > 0) {\n      this.escapeQuasis(/^\\\\/, escapeStrings);\n    }\n  }\n\n  shouldBecomeTemplateLiteral() {\n    return this.expressions.length > 0 || this.node.raw.indexOf('\\n') > -1;\n  }\n}\n","import BoundFunctionPatcher from './BoundFunctionPatcher.js';\nimport BoundGeneratorFunctionPatcher from './BoundGeneratorFunctionPatcher.js';\nimport FunctionPatcher from './FunctionPatcher.js';\nimport GeneratorFunctionPatcher from './GeneratorFunctionPatcher.js';\nimport IdentifierPatcher from './IdentifierPatcher.js';\nimport ManuallyBoundFunctionPatcher from './ManuallyBoundFunctionPatcher.js';\nimport StringPatcher from './StringPatcher.js';\nimport NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Editor, Node, ParseContext } from './../../../patchers/types.js';\n\n/**\n * Handles object properties.\n */\nexport default class ObjectBodyMemberPatcher extends NodePatcher {\n  key: NodePatcher;\n  expression: NodePatcher;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, key: NodePatcher, expression: NodePatcher) {\n    super(node, context, editor);\n    this.key = key;\n    this.expression = expression;\n  }\n\n  initialize() {\n    this.key.setRequiresExpression();\n    this.expression.setRequiresExpression();\n  }\n\n  /**\n   * KEY : EXPRESSION\n   */\n  patchAsExpression(options={}) {\n    if (this.isMethod()) {\n      this.patchAsMethod(options);\n    } else {\n      this.patchAsProperty(options);\n    }\n  }\n\n  patchAsMethod() {\n    if (this.isGeneratorMethod()) {\n      this.insert(this.key.outerStart, '*');\n    }\n    let isComputed = this.isMethodNameComputed();\n    if (isComputed) {\n      // `{ 'hi there': ->` → `{ ['hi there': ->`\n      //                         ^\n      this.insert(this.key.outerStart, '[');\n    }\n    this.patchKey();\n    if (isComputed) {\n      // `{ ['hi there': ->` → `{ ['hi there']: ->`\n      //                                     ^\n      this.insert(this.key.outerEnd, ']');\n    }\n    // `{ ['hi there']: ->` → `{ ['hi there']->`\n    //                ^^\n    this.remove(this.key.outerEnd, this.expression.outerStart);\n    // The function expression might be surrounded by parens, so remove them if\n    // necessary.\n    this.remove(this.expression.outerStart, this.expression.contentStart);\n    this.remove(this.expression.contentEnd, this.expression.outerEnd);\n    this.patchExpression();\n  }\n\n  patchAsProperty() {\n    this.patchKey();\n    this.patchExpression();\n  }\n\n  patchKey() {\n    let computedKeyPatcher = this.getComputedKeyPatcher();\n    if (computedKeyPatcher !== null) {\n      this.overwrite(this.key.outerStart, computedKeyPatcher.outerStart, '[');\n      computedKeyPatcher.patch();\n      this.overwrite(computedKeyPatcher.outerEnd, this.key.outerEnd, ']');\n    } else {\n      let needsBrackets =\n        !(this.key instanceof StringPatcher && !this.key.shouldBecomeTemplateLiteral()) &&\n        !(this.key instanceof IdentifierPatcher);\n      if (needsBrackets) {\n        this.insert(this.key.outerStart, '[');\n      }\n      this.key.patch();\n      if (needsBrackets) {\n        this.insert(this.key.outerEnd, ']');\n      }\n    }\n  }\n\n  /**\n   * As a special case, transform {\"#{a.b}\": c} to {[a.b]: c}, since a template\n   * literal is the best way to do computed keys in CoffeeScript. This method\n   * gets the patcher for that computed key node, if any.\n   */\n  getComputedKeyPatcher() {\n    if (this.key instanceof StringPatcher &&\n        this.key.quasis.length === 2 &&\n        this.key.expressions.length === 1 &&\n        this.key.quasis[0].node.data === '' &&\n        this.key.quasis[1].node.data === '') {\n      return this.key.expressions[0];\n    }\n    return null;\n  }\n\n  patchExpression() {\n    this.expression.patch({ method: this.isMethod() });\n  }\n\n  /**\n   * @protected\n   */\n  isMethodNameComputed(): boolean {\n    return !(this.key instanceof IdentifierPatcher);\n  }\n\n  /**\n   * In normal object bodies, we can use method syntax for normal arrow\n   * functions and for normal generator functions. If we need to explicitly add\n   * `.bind(this)`, then we won't be able to use the method form. But for\n   * classes, since the binding is done in the constructor, we can still use\n   * method syntax, so ClassAssignOpPatcher overrides this method for that case.\n   * We also allow ClassBoundMethodFunctionPatcher since that only comes up in\n   * the class case.\n   *\n   * @protected\n   */\n  isMethod(): boolean {\n    return this.expression instanceof FunctionPatcher &&\n        !(this.expression instanceof ManuallyBoundFunctionPatcher) &&\n        !(this.expression instanceof BoundFunctionPatcher);\n  }\n\n  /**\n   * Note that we include BoundGeneratorFunctionPatcher, even though the object\n   * case doesn't treat it as a method, since the class case should use a\n   * generator method.\n   *\n   * @protected\n   */\n  isGeneratorMethod(): boolean {\n    return this.expression instanceof GeneratorFunctionPatcher ||\n      this.expression instanceof BoundGeneratorFunctionPatcher;\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\n\nexport default class ThisPatcher extends NodePatcher {\n  patchAsExpression() {\n    if (this.isShorthandThis()) {\n      this.overwrite(this.contentStart, this.contentEnd, 'this');\n    }\n  }\n\n  isShorthandThis() {\n    return this.getOriginalSource() === '@';\n  }\n\n  isRepeatable(): boolean {\n    return true;\n  }\n\n  makeRepeatable(parens: boolean, ref: ?string=null): string { // eslint-disable-line no-unused-vars\n    return 'this';\n  }\n}\n","import MemberAccessOpPatcher from './MemberAccessOpPatcher.js';\nimport ObjectBodyMemberPatcher from './ObjectBodyMemberPatcher.js';\nimport StringPatcher from './StringPatcher.js';\nimport ThisPatcher from './ThisPatcher.js';\n\n/**\n * Handles object properties.\n */\nexport default class ObjectInitialiserMemberPatcher extends ObjectBodyMemberPatcher {\n  patchAsProperty() {\n    if (this.key.node === this.expression.node) {\n      this.patchAsShorthand({\n        expand: this.key.node.type !== 'Identifier'\n      });\n    } else {\n      super.patchAsProperty();\n    }\n  }\n\n  /**\n   * @private\n   */\n  patchAsShorthand({ expand=false }={}) {\n    let { key } = this;\n    if (key instanceof MemberAccessOpPatcher) {\n      key.patch();\n      // e.g. `{ @name }`\n      let memberAccessKey = (key: MemberAccessOpPatcher);\n      if (!(memberAccessKey.expression instanceof ThisPatcher)) {\n        throw this.error(\n          `expected property key member access on 'this', e.g. '@name'`\n        );\n      }\n      // `{ @name }` → `{ name: @name }`\n      //                  ^^^^^^\n      this.insert(\n        memberAccessKey.outerStart,\n        `${memberAccessKey.getMemberName()}: `\n      );\n    } else if (expand) {\n      let isComputed = key instanceof StringPatcher && key.shouldBecomeTemplateLiteral();\n\n      if (isComputed) {\n        // `{ `a = ${1 + 1}` }` → `{ [`a = ${1 + 1}` }`\n        //                           ^\n        this.insert(key.outerStart, '[');\n      }\n\n      let valueCode;\n      if (key.isRepeatable()) {\n        valueCode = key.patchAndGetCode();\n      } else {\n        key.patch();\n        valueCode = key.makeRepeatable();\n      }\n\n      if (isComputed) {\n        this.insert(key.outerEnd, ']');\n      }\n\n      // `{ a } → { a: a }`\n      //             ^^^\n      this.insert(key.outerEnd, `: ${valueCode}`);\n    }\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport ObjectInitialiserMemberPatcher from './ObjectInitialiserMemberPatcher.js';\nimport type { Editor, Node, ParseContext } from './../../../patchers/types.js';\nimport { COMMA, LBRACE } from 'coffee-lex';\nimport { isSemanticToken } from '../../../utils/types.js';\n\n/**\n * Handles object literals.\n */\nexport default class ObjectInitialiserPatcher extends NodePatcher {\n  members: Array<NodePatcher>;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, members: Array<NodePatcher>) {\n    super(node, context, editor);\n    this.members = members;\n  }\n\n  initialize() {\n    this.members.forEach(member => member.setRequiresExpression());\n  }\n\n  /**\n   * Objects as expressions are very similar to their CoffeeScript equivalents.\n   */\n  patchAsExpression() {\n    let implicitObject = this.isImplicitObject();\n    if (implicitObject) {\n      let curlyBraceInsertionPosition = this.innerStart;\n      let textToInsert = '{';\n      let shouldIndent = false;\n      if (this.shouldExpandCurlyBraces()) {\n        if (this.implicitlyReturns() && !this.isSurroundedByParentheses()) {\n          textToInsert = `{\\n${this.getIndent()}`;\n          shouldIndent = true;\n        } else {\n          let tokenIndexBeforeOuterStartTokenIndex = this.outerStartTokenIndex;\n          if (!this.isSurroundedByParentheses()) {\n            tokenIndexBeforeOuterStartTokenIndex = tokenIndexBeforeOuterStartTokenIndex.previous();\n          }\n\n          if (tokenIndexBeforeOuterStartTokenIndex) {\n            let precedingTokenIndex = this.context.sourceTokens.lastIndexOfTokenMatchingPredicate(\n              isSemanticToken,\n              tokenIndexBeforeOuterStartTokenIndex\n            );\n            if (precedingTokenIndex) {\n              let precedingToken = this.sourceTokenAtIndex(precedingTokenIndex);\n              curlyBraceInsertionPosition = precedingToken.end;\n              let precedingTokenText = this.sourceOfToken(precedingToken);\n              let lastCharOfToken = precedingTokenText[precedingTokenText.length - 1];\n              let needsSpace = (\n                lastCharOfToken === ':' ||\n                lastCharOfToken === '=' ||\n                lastCharOfToken === ','\n              );\n              if (needsSpace) {\n                textToInsert = ' {';\n              }\n            }\n          }\n        }\n      }\n      this.insert(curlyBraceInsertionPosition, textToInsert);\n      if (shouldIndent) {\n        this.indent();\n      }\n    }\n    this.patchMembers();\n    if (implicitObject) {\n      if (this.shouldExpandCurlyBraces() && !this.isSurroundedByParentheses()) {\n        this.appendLineAfter('}', -1);\n      } else {\n        this.insert(this.innerEnd, '}');\n      }\n    }\n  }\n\n  /**\n   * Objects as statements need to be wrapped in parentheses, or else they'll be\n   * confused with blocks. That is, this is not an object [1]:\n   *\n   *   { a: 0 };\n   *\n   * But this is fine:\n   *\n   *   ({ a: 0 });\n   *\n   * [1]: It is actually valid code, though. It's a block with a labeled\n   * statement `a` with a single expression statement, being the literal 0.\n   */\n  patchAsStatement() {\n    let needsParentheses = !this.isSurroundedByParentheses();\n    let implicitObject = this.isImplicitObject();\n    if (needsParentheses) {\n      this.insert(this.contentStart, '(');\n    }\n    if (implicitObject) {\n      if (this.shouldExpandCurlyBraces() && !this.isSurroundedByParentheses()) {\n        this.insert(this.innerStart, `{\\n${this.getIndent()}`);\n        this.indent();\n      } else {\n        this.insert(this.innerStart, '{');\n      }\n    }\n    this.patchMembers();\n    if (implicitObject) {\n      if (this.shouldExpandCurlyBraces() && !this.isSurroundedByParentheses()) {\n        this.appendLineAfter('}', -1);\n      } else {\n        this.insert(this.innerEnd, '}');\n      }\n    }\n    if (needsParentheses) {\n      this.insert(this.contentEnd, ')');\n    }\n  }\n\n  /**\n   * @private\n   */\n  shouldExpandCurlyBraces(): boolean {\n    return (\n      this.isMultiline() ||\n      this.parent instanceof ObjectInitialiserMemberPatcher\n    );\n  }\n\n  /**\n   * @private\n   */\n  patchMembers() {\n    this.members.forEach((member, i, members) => {\n      member.patch();\n      if (i !== members.length - 1) {\n        if (!member.hasSourceTokenAfter(COMMA)) {\n          this.insert(member.outerEnd, ',');\n        }\n      }\n    });\n  }\n\n  /**\n   * Determines whether this object is implicit, i.e. it lacks braces.\n   *\n   *   a: b      # true\n   *   { a: b }  # false\n   */\n  isImplicitObject(): boolean {\n    let tokens = this.context.sourceTokens;\n    let indexOfFirstToken = tokens.indexOfTokenStartingAtSourceIndex(this.contentStart);\n    return tokens.tokenAtIndex(indexOfFirstToken).type !== LBRACE;\n  }\n\n  /**\n   * Starting a statement with an object always requires parens.\n   */\n  statementNeedsParens(): boolean {\n    return true;\n  }\n}\n","/* @flow */\nimport BlockPatcher from '../stages/main/patchers/BlockPatcher.js';\nimport ObjectInitialiserPatcher from '../stages/main/patchers/ObjectInitialiserPatcher.js';\n\nimport type NodePatcher from '../patchers/NodePatcher.js';\n\n/**\n * Determine if this is a block where the only contents are an object literal.\n */\nexport default function isObjectInitialiserBlock(patcher: NodePatcher): boolean {\n  return patcher instanceof BlockPatcher &&\n    patcher.statements.length === 1 &&\n    patcher.statements[0] instanceof ObjectInitialiserPatcher;\n}\n","/* @flow */\n\nimport type { Node } from '../patchers/types.js';\n\n/**\n * Traverses an AST node, calling a callback for each node in the hierarchy in\n * source order.\n */\nexport default function traverse(node: Node, callback: (node: Node, descend: (node: Node) => void, hasChildren: boolean) => ?boolean) {\n  let descended = false;\n\n  function descend(parent) {\n    descended = true;\n\n    childPropertyNames(parent).forEach(property => {\n      let value = parent[property];\n      if (Array.isArray(value)) {\n        value.forEach(child => {\n          child.parentNode = parent;\n          traverse(child, callback);\n        });\n      } else if (value) {\n        value.parentNode = parent;\n        traverse(value, callback);\n      }\n    });\n  }\n\n  let shouldDescend = callback(\n    node,\n    descend,\n    childPropertyNames(node).length === 0\n  );\n\n  if (!descended && shouldDescend !== false) {\n    descend(node);\n  }\n}\n\nconst ORDER = {\n  ArrayInitialiser: ['members'],\n  AssignOp: ['assignee', 'expression'],\n  BitAndOp: ['left', 'right'],\n  BitNotOp: ['expression'],\n  BitOrOp: ['left', 'right'],\n  BitXorOp: ['left', 'right'],\n  Block: ['statements'],\n  Bool: [],\n  BoundFunction: ['parameters', 'body'],\n  BoundGeneratorFunction: ['parameters', 'body'],\n  Break: [],\n  ChainedComparisonOp: ['expression'],\n  Class: ['nameAssignee', 'parent', 'body'],\n  ClassProtoAssignOp: ['assignee', 'expression'],\n  CompoundAssignOp: ['assignee', 'expression'],\n  Conditional: ['condition', 'consequent', 'alternate'],\n  Constructor: ['assignee', 'expression'],\n  Continue: [],\n  DefaultParam: ['param', 'default'],\n  DeleteOp: ['expression'],\n  DivideOp: ['left', 'right'],\n  DoOp: ['expression'],\n  DynamicMemberAccessOp: ['expression', 'indexingExpr'],\n  EQOp: ['left', 'right'],\n  ExistsOp: ['left', 'right'],\n  Expansion: [],\n  ExpOp: ['left', 'right'],\n  ExtendsOp: ['left', 'right'],\n  Float: [],\n  FloorDivideOp: ['left', 'right'],\n  ForIn: ['keyAssignee', 'valAssignee', 'target', 'step', 'filter', 'body'],\n  ForOf: ['keyAssignee', 'valAssignee', 'target', 'filter', 'body'],\n  Function: ['parameters', 'body'],\n  FunctionApplication: ['function', 'arguments'],\n  GeneratorFunction: ['parameters', 'body'],\n  GTEOp: ['left', 'right'],\n  GTOp: ['left', 'right'],\n  Heregex: ['quasis', 'expressions'],\n  Identifier: [],\n  InOp: ['left', 'right'],\n  InstanceofOp: ['left', 'right'],\n  Int: [],\n  JavaScript: [],\n  LTEOp: ['left', 'right'],\n  LTOp: ['left', 'right'],\n  LeftShiftOp: ['left', 'right'],\n  LogicalAndOp: ['left', 'right'],\n  LogicalNotOp: ['expression'],\n  LogicalOrOp: ['left', 'right'],\n  MemberAccessOp: ['expression'],\n  ModuloOp: ['left', 'right'],\n  MultiplyOp: ['left', 'right'],\n  NEQOp: ['left', 'right'],\n  NewOp: ['ctor', 'arguments'],\n  Null: [],\n  ObjectInitialiser: ['members'],\n  ObjectInitialiserMember: ['key', 'expression'],\n  OfOp: ['left', 'right'],\n  PlusOp: ['left', 'right'],\n  PostDecrementOp: ['expression'],\n  PostIncrementOp: ['expression'],\n  PreDecrementOp: ['expression'],\n  PreIncrementOp: ['expression'],\n  Program: ['body'],\n  ProtoMemberAccessOp: ['expression'],\n  Quasi: [],\n  Range: ['left', 'right'],\n  RegExp: [],\n  RemOp: ['left', 'right'],\n  Rest: ['expression'],\n  Return: ['expression'],\n  SeqOp: ['left', 'right'],\n  SignedRightShiftOp: ['left', 'right'],\n  Slice: ['expression', 'left', 'right'],\n  SoakedDynamicMemberAccessOp: ['expression', 'indexingExpr'],\n  SoakedFunctionApplication: ['function', 'arguments'],\n  SoakedMemberAccessOp: ['expression'],\n  Spread: ['expression'],\n  String: ['quasis', 'expressions'],\n  SubtractOp: ['left', 'right'],\n  Super: [],\n  Switch: ['expression', 'cases', 'alternate'],\n  SwitchCase: ['conditions', 'consequent'],\n  This: [],\n  Throw: ['expression'],\n  Try: ['body', 'catchAssignee', 'catchBody', 'finallyBody'],\n  TypeofOp: ['expression'],\n  UnaryExistsOp: ['expression'],\n  UnaryNegateOp: ['expression'],\n  UnaryPlusOp: ['expression'],\n  Undefined: [],\n  UnsignedRightShiftOp: ['left', 'right'],\n  While: ['condition', 'guard', 'body'],\n  Yield: ['expression'],\n  YieldFrom: ['expression']\n};\n\nexport function childPropertyNames(node: Node): Array<string> {\n  let names = ORDER[node.type];\n\n  if (!names) {\n    throw new Error(`cannot traverse unknown node type: ${node.type}`);\n  }\n\n  return names;\n}\n","import FunctionPatcher from './FunctionPatcher.js';\nimport IdentifierPatcher from './IdentifierPatcher.js';\nimport ManuallyBoundFunctionPatcher from './ManuallyBoundFunctionPatcher.js';\nimport NodePatcher from './../../../patchers/NodePatcher.js';\nimport isObjectInitialiserBlock from '../../../utils/isObjectInitialiserBlock.js';\nimport traverse from '../../../utils/traverse.js';\nimport type { Node } from './../../../patchers/types.js';\nimport { isFunction } from '../../../utils/types.js';\n\n/**\n * Handles bound functions, i.e. \"fat arrows\".\n */\nexport default class BoundFunctionPatcher extends FunctionPatcher {\n  initialize() {\n    super.initialize();\n    if (this.hasInlineBody()) {\n      this.body.setExpression();\n    }\n  }\n\n  /**\n   * Use a slightly-modified version of the regular `FunctionPatcher` when\n   * we can't use arrow functions.\n   */\n  static patcherClassOverrideForNode(node: Node): ?Class<NodePatcher> {\n    let referencesArguments = false;\n\n    traverse(node, child => {\n      if (referencesArguments) {\n        // We already found a reference, so skip this.\n        return false;\n      } else if (child.type === 'Identifier' && child.data === 'arguments') {\n        referencesArguments = true;\n      } else if (child !== node && isFunction(child)) {\n        // Don't descend into other functions.\n        return false;\n      }\n    });\n\n    if (referencesArguments) {\n      return ManuallyBoundFunctionPatcher;\n    } else {\n      return null;\n    }\n  }\n\n  // There's no difference between statement and expression arrow functions.\n  patchAsStatement(options={}) {\n    this.patchAsExpression(options);\n  }\n\n  patchFunctionStart() {\n    let arrow = this.getArrowToken();\n\n    if (!this.hasParamStart()) {\n      this.insert(this.contentStart, '() ');\n    } else if (!this.parameterListNeedsParentheses()) {\n      let [ param ] = this.parameters;\n      if (param.isSurroundedByParentheses()) {\n        this.remove(param.outerStart, param.contentStart);\n        this.remove(param.contentEnd, param.outerEnd);\n      }\n    }\n\n    if (!this.willPatchBodyInline()) {\n      this.insert(arrow.end, ' {');\n    }\n  }\n\n  parameterListNeedsParentheses(): boolean {\n    let parameters = this.parameters;\n\n    if (parameters.length !== 1) {\n      return true;\n    }\n\n    let [ param ] = parameters;\n    return !(param instanceof IdentifierPatcher);\n  }\n\n  patchFunctionBody() {\n    if (this.body) {\n      if (!this.willPatchBodyInline()) {\n        this.body.patch({ leftBrace: false });\n      } else {\n        if (isObjectInitialiserBlock(this.body)) {\n          this.body.surroundInParens();\n        }\n        this.body.patch();\n      }\n    } else {\n      // No body, so BlockPatcher can't insert it for us.\n      this.insert(this.innerEnd, '}');\n    }\n  }\n\n  expectedArrowType(): string {\n    return '=>';\n  }\n\n  willPatchBodyInline(): boolean {\n    return this.body ? this.body.willPatchAsExpression() : false;\n  }\n\n  hasInlineBody(): boolean {\n    return this.body ? this.body.inline() : false;\n  }\n\n  /**\n   * Bound functions already start with a paren or a param identifier, and so\n   * are safe to start a statement.\n   */\n  statementNeedsParens(): boolean {\n    return false;\n  }\n}\n","import BinaryOpPatcher from './BinaryOpPatcher.js';\nimport NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Editor, Node, ParseContext } from './../../../patchers/types.js';\n\n/**\n * Handles constructs of the form `a < b < c < … < z`.\n */\nexport default class ChainedComparisonOpPatcher extends NodePatcher {\n  expression: NodePatcher;\n  \n  /**\n   * `node` should have type `ChainedComparisonOp`.\n   */\n  constructor(node: Node, context: ParseContext, editor: Editor, expression: BinaryOpPatcher) {\n    super(node, context, editor);\n    this.expression = expression;\n    this.negated = false;\n  }\n\n  initialize() {\n    this.expression.setRequiresExpression();\n  }\n\n  patchAsExpression() {\n    this.expression.patch();\n    this.getMiddleOperands().forEach(middle => {\n      let middleAgain = middle.makeRepeatable(true, 'middle');\n      // `a < b < c` → `a < b && b < c`\n      //                     ^^^^^\n      this.insert(\n        middle.outerEnd,\n        ` ${this.negated ? '||' : '&&'} ${middleAgain}`\n      );\n    });\n  }\n\n  /**\n   * @private\n   */\n  getMiddleOperands(): Array<NodePatcher> {\n    let result = [];\n    let comparison = this.expression.left;\n    while (comparison instanceof BinaryOpPatcher) {\n      result.unshift(comparison.right);\n      comparison = comparison.left;\n    }\n    return result;\n  }\n\n  negate() {\n    this.negated = !this.negated;\n    let comparison = this.expression;\n    while (comparison instanceof BinaryOpPatcher) {\n      comparison.negate();\n      comparison = comparison.left;\n    }\n  }\n\n  /**\n   * Forward the request to the underlying comparison operator.\n   */\n  statementNeedsParens(): boolean {\n    return this.expression.statementNeedsParens();\n  }\n}\n","import FunctionPatcher from './FunctionPatcher.js';\n\nexport default class ClassBoundMethodFunctionPatcher extends FunctionPatcher {\n  expectedArrowType(): string {\n    return '=>';\n  }\n}\n","import ClassBoundMethodFunctionPatcher from './ClassBoundMethodFunctionPatcher.js';\nimport IdentifierPatcher from './IdentifierPatcher.js';\nimport ManuallyBoundFunctionPatcher from './ManuallyBoundFunctionPatcher.js';\nimport MemberAccessOpPatcher from './MemberAccessOpPatcher.js';\nimport ObjectBodyMemberPatcher from './ObjectBodyMemberPatcher.js';\nimport ThisPatcher from './ThisPatcher.js';\nimport type NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Node } from './../../../patchers/types.js';\nimport { COLON } from 'coffee-lex';\n\nexport default class ClassAssignOpPatcher extends ObjectBodyMemberPatcher {\n  static patcherClassForChildNode(node: Node, property: string): ?Class<NodePatcher> {\n    if (property === 'expression' && node.type === 'BoundFunction') {\n      return ClassBoundMethodFunctionPatcher;\n    }\n    return null;\n  }\n\n  /**\n   * Don't put semicolons after methods.\n   */\n  statementNeedsSemicolon(): boolean {\n    return !this.isMethod();\n  }\n\n  patchAsExpression() {\n    super.patchAsExpression();\n    if (this.isStaticMethod()) {\n      // `this.a: ->` → `static a: ->`\n      //  ^^^^^          ^^^^^^^\n      let memberNameToken = this.key.getMemberNameSourceToken();\n      this.overwrite(this.key.outerStart, memberNameToken.start, 'static ');\n    }\n  }\n\n  /**\n   * @protected\n   */\n  patchKey() {\n    // Don't bother, we handle it at this level.\n  }\n\n  /**\n   * @protected\n   */\n  patchAsProperty() {\n    // `name: null` → `name = null`\n    //      ^^             ^^^\n    let colonIndex = this.indexOfSourceTokenBetweenPatchersMatching(\n      this.key,\n      this.expression,\n      token => token.type === COLON\n    );\n    if (!colonIndex) {\n      throw this.error('expected a colon between the key and expression of a class property');\n    }\n    let colonToken = this.sourceTokenAtIndex(colonIndex);\n    this.overwrite(colonToken.start, colonToken.end, ' =');\n    this.patchExpression();\n  }\n\n  /**\n   * Determines whether this class assignment has a computed key.\n   *\n   * @protected\n   */\n  isMethodNameComputed(): boolean {\n    if (!super.isMethodNameComputed()) {\n      return false;\n    }\n    return !this.isStaticMethod();\n  }\n\n  /**\n   * Determines if this class assignment matches the known patterns for static\n   * methods in CoffeeScript, i.e.\n   *\n   *   class A\n   *     this.a: ->\n   *     @b: ->\n   *     A.c: ->\n   *\n   * @protected\n   */\n  isStaticMethod(): boolean {\n    if (!(this.key instanceof MemberAccessOpPatcher)) {\n      return false;\n    }\n\n    let memberObject = this.key.expression;\n    if (memberObject instanceof ThisPatcher) {\n      return true;\n    }\n\n    let className = this.parent.parent.nameAssignee;\n    return (\n      className instanceof IdentifierPatcher &&\n      memberObject instanceof IdentifierPatcher &&\n      className.node.data === className.node.data\n    );\n  }\n\n  isBoundInstanceMethod(): boolean {\n    return (\n      !this.isStaticMethod() &&\n      (this.expression.node.type === 'BoundFunction' ||\n        this.expression.node.type === 'BoundGeneratorFunction')\n    );\n  }\n\n  /**\n   * For classes, unlike in objects, manually bound methods can use regular\n   * method syntax because the bind happens in the constructor.\n   *\n   * @protected\n   */\n  isMethod(): boolean {\n    return this.expression instanceof ManuallyBoundFunctionPatcher ||\n      super.isMethod();\n  }\n}\n","import ObjectBodyMemberPatcher from './ObjectBodyMemberPatcher.js';\nimport traverse from '../../../utils/traverse.js';\nimport type FunctionPatcher from './FunctionPatcher.js';\nimport type NodePatcher from '../../../patchers/NodePatcher.js';\nimport type { Editor, Node, ParseContext } from './../../../patchers/types.js';\n\nexport default class ConstructorPatcher extends ObjectBodyMemberPatcher {\n  constructor(node: Node, context: ParseContext, editor: Editor, assignee: NodePatcher, expression: FunctionPatcher) {\n    super(node, context, editor, assignee, expression);\n\n    // Constructor methods do not have implicit returns.\n    expression.disableImplicitReturns();\n  }\n\n  patch(options={}) {\n    super.patch(options);\n    let boundMethods = this.parent.boundInstanceMethods();\n    if (boundMethods.length > 0) {\n      let statements = this.expression.body.statements;\n      let indexOfSuperStatement = -1;\n      for (let i = 0; i < statements.length; i++) {\n        let callsSuper = false;\n        traverse(statements[i].node, child => {\n          if (callsSuper) {\n            // Already found it, skip this one.\n            return false;\n          } else if (child.type === 'Super') {\n            // Found it.\n            callsSuper = true;\n          } else if (child.type === 'Class') {\n            // Don't go into other classes.\n            return false;\n          }\n        });\n        if (callsSuper) {\n          indexOfSuperStatement = i;\n          break;\n        }\n      }\n      let bindings = boundMethods.map(method => {\n        let key = this.context.source.slice(method.key.contentStart, method.key.contentEnd);\n        return `this.${key} = this.${key}.bind(this)`;\n      });\n      this.expression.body.insertStatementsAtIndex(bindings, indexOfSuperStatement + 1);\n    }\n  }\n\n  /**\n   * Don't put semicolons after class constructors.\n   */\n  statementNeedsSemicolon(): boolean {\n    return false;\n  }\n}\n","import BlockPatcher from './BlockPatcher.js';\nimport ClassAssignOpPatcher from './ClassAssignOpPatcher.js';\nimport ConstructorPatcher from './ConstructorPatcher.js';\nimport NodePatcher from './../../../patchers/NodePatcher.js';\nimport adjustIndent from '../../../utils/adjustIndent.js';\nimport type ClassPatcher from './ClassPatcher.js';\nimport type { Node } from './../../../patchers/types.js';\n\nexport default class ClassBlockPatcher extends BlockPatcher {\n  static patcherClassForChildNode(node: Node, property: string): ?Class<NodePatcher> {\n    if (property === 'statements' && node.type === 'AssignOp') {\n      return ClassAssignOpPatcher;\n    }\n  }\n\n  patch(options={}) {\n    if (!this.hasConstructor()) {\n      let boundMethods = this.boundInstanceMethods();\n      if (boundMethods.length > 0) {\n        let { source } = this.context;\n        let insertionPoint = this.statements[0].outerStart;\n        let methodIndent = adjustIndent(source, insertionPoint, 0);\n        let methodBodyIndent = adjustIndent(source, insertionPoint, 1);\n        let constructor = '';\n        if (this.getClassPatcher().isSubclass()) {\n          constructor += `constructor(...args) {\\n${methodBodyIndent}super(...args);\\n`;\n        } else {\n          constructor += `constructor() {\\n`;\n        }\n        boundMethods.forEach(method => {\n          let key = source.slice(method.key.contentStart, method.key.contentEnd);\n          constructor += `${methodBodyIndent}this.${key} = this.${key}.bind(this);\\n`;\n        });\n        constructor += `${methodIndent}}\\n\\n${methodIndent}`;\n        this.insert(insertionPoint, constructor);\n      }\n    }\n    super.patch(options);\n  }\n  \n  getClassPatcher(): ClassPatcher {\n    return this.parent;\n  }\n\n  canPatchAsExpression(): boolean {\n    return false;\n  }\n\n  hasConstructor(): boolean {\n    return this.statements.some(\n      statement => statement instanceof ConstructorPatcher\n    );\n  }\n\n  boundInstanceMethods(): Array<ClassAssignOpPatcher> {\n    return this.statements.filter(statement => {\n      if (statement instanceof ClassAssignOpPatcher) {\n        return statement.isBoundInstanceMethod();\n      } else {\n        return false;\n      }\n    });\n  }\n}\n","import ClassBlockPatcher from './ClassBlockPatcher.js';\nimport IdentifierPatcher from './IdentifierPatcher.js';\nimport MemberAccessOpPatcher from './MemberAccessOpPatcher.js';\nimport NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { SourceToken, Node, ParseContext, Editor } from './../../../patchers/types.js';\nimport { CLASS } from 'coffee-lex';\n\nexport default class ClassPatcher extends NodePatcher {\n  nameAssignee: ?NodePatcher;\n  superclass: ?NodePatcher;\n  body: ?ClassBlockPatcher;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, nameAssignee: ?NodePatcher, parent: ?NodePatcher, body: ?ClassBlockPatcher) {\n    super(node, context, editor);\n    this.nameAssignee = nameAssignee;\n    this.superclass = parent;\n    this.body = body;\n  }\n\n  static patcherClassForChildNode(node: Node, property: string): ?Class<NodePatcher> {\n    if (property === 'body') {\n      return ClassBlockPatcher;\n    }\n    return null;\n  }\n\n  initialize() {\n    if (this.nameAssignee) {\n      this.nameAssignee.setRequiresExpression();\n    }\n    if (this.superclass) {\n      this.superclass.setRequiresExpression();\n    }\n  }\n\n  patchAsStatement() {\n    let hasParens = this.isSurroundedByParentheses();\n    let anonymous = this.isAnonymous();\n    if (anonymous && !hasParens) {\n      // `class` → `(class`\n      //            ^\n      this.insert(this.innerStart, '(');\n    }\n\n    this.patchAsExpression();\n\n    if (anonymous && !hasParens) {\n      // `(class` → `(class)`\n      //                   ^\n      this.insert(this.innerEnd, ')');\n    }\n  }\n\n  patchAsExpression() {\n    if (this.isNamespaced()) {\n      let classToken = this.getClassToken();\n      // `class A.B` → `A.B`\n      //  ^^^^^^\n      this.remove(classToken.start, this.nameAssignee.outerStart);\n      let name = this.getName();\n      if (name) {\n        // `A.B` → `A.B = class B`\n        //             ^^^^^^^^^^\n        this.insert(this.nameAssignee.outerEnd, ` = class ${this.getName()}`);\n      } else {\n        // `A[0]` → `A[0] = class`\n        //               ^^^^^^^^\n        this.insert(this.nameAssignee.outerEnd, ` = class`);\n      }\n    }\n    if (this.nameAssignee) {\n      this.nameAssignee.patch();\n    }\n    if (this.superclass) {\n      this.superclass.patch();\n    }\n    if (!this.body) {\n      // `class A` → `class A {}`\n      //                     ^^^\n      this.insert(this.innerEnd,' {}');\n    } else {\n      // `class A` → `class A {`\n      //                     ^^\n      this.insert(this.getBraceInsertionOffset(), ' {');\n      this.body.patch({ leftBrace: false });\n    }\n  }\n\n  statementNeedsSemicolon(): boolean {\n    return this.isAnonymous() || this.isNamespaced();\n  }\n\n  /**\n   * Classes, like functions, only need parens as statements when anonymous.\n   */\n  statementNeedsParens(): boolean {\n    return this.isAnonymous();\n  }\n\n  /**\n   * @private\n   */\n  getClassToken(): SourceToken {\n    let tokens = this.context.sourceTokens;\n    let classSourceToken = tokens.tokenAtIndex(this.contentStartTokenIndex);\n    if (classSourceToken.type !== CLASS) {\n      throw this.error(\n        `expected CLASS token but found ${classSourceToken.type.name}`,\n        classSourceToken.start, classSourceToken.end\n      );\n    }\n    return classSourceToken;\n  }\n\n  /**\n   * @private\n   */\n  isAnonymous(): boolean {\n    return this.nameAssignee === null;\n  }\n\n  /**\n   * @private\n   */\n  isNamespaced(): boolean {\n    return !this.isAnonymous() && !(this.nameAssignee instanceof IdentifierPatcher);\n  }\n\n  /**\n   * @private\n   */\n  getName(): ?string {\n    let { nameAssignee } = this;\n    if (nameAssignee instanceof IdentifierPatcher) {\n      return nameAssignee.node.data;\n    } else if (nameAssignee instanceof MemberAccessOpPatcher) {\n      return nameAssignee.node.memberName;\n    } else {\n      return null;\n    }\n  }\n\n  isSubclass(): boolean {\n    return this.superclass !== null;\n  }\n\n  /**\n   * @private\n   */\n  getBraceInsertionOffset(): number {\n    if (this.superclass) {\n      return this.superclass.outerEnd;\n    }\n\n    if (this.nameAssignee) {\n      return this.nameAssignee.outerEnd;\n    }\n\n    return this.getClassToken().end;\n  }\n}\n","import AssignOpPatcher from './AssignOpPatcher.js';\nimport type { SourceToken } from './../../../patchers/types.js';\nimport { OPERATOR } from 'coffee-lex';\n\nexport default class CompoundAssignOpPatcher extends AssignOpPatcher {\n  getOperatorToken(): SourceToken {\n    let operatorIndex = this.indexOfSourceTokenBetweenPatchersMatching(\n      this.assignee,\n      this.expression,\n      token => token.type === OPERATOR\n    );\n    if (!operatorIndex) {\n      throw this.error(\n        `expected OPERATOR token between assignee and expression`,\n        this.assignee.outerEnd,\n        this.expression.outerStart\n      );\n    }\n    return this.sourceTokenAtIndex(operatorIndex);\n  }\n\n  /**\n   * If `LHS` needs parens then `LHS += RHS` needs parens.\n   */\n  statementNeedsParens(): boolean {\n    return this.assignee.statementShouldAddParens();\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport type BlockPatcher from './BlockPatcher.js';\nimport type { Node, SourceTokenListIndex, ParseContext, Editor } from './../../../patchers/types.js';\nimport { ELSE, IF, THEN } from 'coffee-lex';\n\nexport default class ConditionalPatcher extends NodePatcher {\n  condition: NodePatcher;\n  consequent: BlockPatcher;\n  alternate: ?BlockPatcher;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, condition: NodePatcher, consequent: BlockPatcher, alternate: ?BlockPatcher) {\n    super(node, context, editor);\n    this.condition = condition;\n    this.consequent = consequent;\n    this.alternate = alternate;\n  }\n\n  initialize() {\n    this.condition.setRequiresExpression();\n  }\n\n  prefersToPatchAsExpression(): boolean {\n    let { consequent, alternate } = this;\n    if (!consequent || !alternate) {\n      return false;\n    }\n    return (\n      consequent.prefersToPatchAsExpression() &&\n      alternate.prefersToPatchAsExpression()\n    );\n  }\n\n  setExpression(force=false): boolean {\n    let willPatchAsExpression = super.setExpression(force);\n    if (willPatchAsExpression && this.willPatchAsTernary()) {\n      if (this.consequent) {\n        this.consequent.setRequiresExpression();\n      }\n      if (this.alternate) {\n        this.alternate.setRequiresExpression();\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  willPatchAsTernary(): boolean {\n    return (\n      this.prefersToPatchAsExpression() || (\n        this.forcedToPatchAsExpression() &&\n        (!this.consequent || this.consequent.prefersToPatchAsExpression()) &&\n        (!this.alternate || this.alternate.prefersToPatchAsExpression())\n      )\n    );\n  }\n\n  /**\n   * @private\n   */\n  willPatchAsIIFE(): boolean {\n    return !this.willPatchAsTernary() && this.forcedToPatchAsExpression();\n  }\n\n  patchAsExpression({ needsParens }={}) {\n    let addParens = needsParens && !this.isSurroundedByParentheses();\n\n    // `if a then b` → `a then b`\n    //  ^^^\n    this.overwrite(\n      this.contentStart,\n      this.condition.outerStart,\n      addParens ? '(' : ''\n    );\n\n    if (this.node.isUnless) {\n      this.condition.negate();\n    }\n\n    this.condition.patch();\n\n    let thenTokenIndex = this.getThenTokenIndex();\n    if (thenTokenIndex) {\n      let thenToken = this.sourceTokenAtIndex(thenTokenIndex);\n      // `a then b` → `a ? b`\n      //    ^^^^         ^\n      this.overwrite(thenToken.start, thenToken.end, '?');\n    } else {\n      // `a b` → `a ? b`\n      //           ^^\n      this.insert(this.condition.outerEnd, ' ?');\n    }\n\n    let elseTokenIndex = this.getElseSourceTokenIndex();\n    let elseToken = elseTokenIndex && this.sourceTokenAtIndex(elseTokenIndex);\n\n    let { consequent, alternate } = this;\n    if (consequent && alternate) {\n      consequent.patch();\n      // `a ? b else c` → `a ? b : c`\n      this.overwrite(elseToken.start, elseToken.end, ':');\n      alternate.patch();\n    } else if (consequent && !alternate) {\n      consequent.patch();\n      // `a ? b` → `a ? b : undefined`\n      if (elseToken !== null) {\n        this.overwrite(this.consequent.outerEnd, elseToken.end, ' : undefined');\n      } else {\n        this.insert(this.consequent.outerEnd, ' : undefined');\n      }\n    } else if (alternate) {\n      this.overwrite(elseToken.start, elseToken.end, 'undefined :');\n      alternate.patch();\n    }\n\n    if (addParens) {\n      this.insert(this.contentEnd, ')');\n    }\n  }\n\n  patchAsForcedExpression() {\n    if (this.willPatchAsTernary()) {\n      // We didn't want to be an expression because we don't have an alternate,\n      // which means that the alternate of a generated ternary would be\n      // `undefined`, which is ugly (i.e. `if a then b` → `a ? b : undefined`).\n      // TODO: Generate a `do` expression instead? (i.e. `do { if (a) { b; } }`)\n      this.patchAsExpression();\n    } else if (this.willPatchAsIIFE()) {\n      this.patchAsIIFE();\n    }\n  }\n\n  patchAsIIFE() {\n    // We're only patched as an expression due to a parent instructing us to,\n    // and the indent level is more logically the indent level of our parent.\n    let baseIndent = this.parent.getIndent(0);\n    let conditionIndent = this.parent.getIndent(1);\n    if (this.consequent) {\n      this.consequent.setShouldPatchInline(false);\n      this.consequent.setImplicitlyReturns();\n    }\n    if (this.alternate) {\n      this.alternate.setShouldPatchInline(false);\n      this.alternate.setImplicitlyReturns();\n    }\n    this.insert(this.innerStart, `(() => {\\n${conditionIndent}`);\n    this.patchAsStatement();\n    this.insert(this.innerEnd, `\\n${baseIndent}})()`);\n  }\n\n  patchAsStatement() {\n    this.patchConditionForStatement();\n    this.patchConsequentForStatement();\n    this.patchAlternateForStatement();\n  }\n\n  /**\n   * @private\n   */\n  patchConditionForStatement() {\n    // `unless a` → `if a`\n    //  ^^^^^^        ^^\n    let ifToken = this.sourceTokenAtIndex(this.getIfSourceTokenIndex());\n    this.overwrite(ifToken.start, ifToken.end, 'if');\n\n    let conditionHasParentheses = this.condition.isSurroundedByParentheses();\n    if (!conditionHasParentheses) {\n      // `if a` → `if (a`\n      //              ^\n      this.insert(this.condition.outerStart, '(');\n    }\n    if (this.node.isUnless) {\n      this.condition.negate();\n    }\n    this.condition.patch({ needsParens: false });\n    if (!conditionHasParentheses) {\n      // `if (a` → `if (a)`\n      //                  ^\n      this.insert(this.condition.outerEnd, ')');\n    }\n\n    let thenTokenIndex = this.getThenTokenIndex();\n    if (thenTokenIndex) {\n      let thenToken = this.sourceTokenAtIndex(thenTokenIndex);\n      // `if (a) then b` → `if (a) b`\n      //         ^^^^^\n      this.remove(thenToken.start, this.consequent.outerStart);\n    }\n  }\n\n  /**\n   * @private\n   */\n  patchConsequentForStatement() {\n    this.insert(this.condition.outerEnd, ' {');\n\n    if (this.alternate) {\n      let elseTokenIndex = this.getElseSourceTokenIndex();\n      let elseToken = this.sourceTokenAtIndex(elseTokenIndex);\n      let rightBracePosition = elseToken.start;\n      if (this.consequent !== null) {\n        this.consequent.patch({ leftBrace: false, rightBrace: false });\n      }\n      this.insert(rightBracePosition, '} ');\n    } else {\n      if (this.consequent !== null) {\n        this.consequent.patch({ leftBrace: false });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  patchAlternateForStatement() {\n    let elseTokenIndex = this.getElseSourceTokenIndex();\n    if (this.alternate) {\n      let ifToken = this.sourceTokenAtIndex(elseTokenIndex.next());\n      let isElseIf = ifToken ? ifToken.type === IF : false;\n      if (isElseIf) {\n        // Let the nested ConditionalPatcher handle braces.\n        this.alternate.patch({ leftBrace: false, rightBrace: false });\n      } else {\n        let elseToken = this.sourceTokenAtIndex(elseTokenIndex);\n        let leftBracePosition = elseToken.end;\n        this.insert(leftBracePosition, ' {');\n        this.alternate.patch({ leftBrace: false });\n      }\n    } else if (elseTokenIndex !== null) {\n      let elseToken = this.sourceTokenAtIndex(elseTokenIndex);\n      this.insert(elseToken.end, ' {}');\n    }\n  }\n\n  setImplicitlyReturns() {\n    if (this.consequent) {\n      this.consequent.setImplicitlyReturns();\n    }\n    if (this.alternate) {\n      this.alternate.setImplicitlyReturns();\n    }\n  }\n\n  /**\n   * Conditionals do not need semicolons when used as statements.\n   */\n  statementNeedsSemicolon(): boolean {\n    return false;\n  }\n\n  /**\n   * Gets the index of the token representing the `if` at the start.\n   *\n   * @private\n   */\n  getIfSourceTokenIndex(): SourceTokenListIndex {\n    let ifTokenIndex = this.indexOfSourceTokenStartingAtSourceIndex(this.contentStart);\n    if (!ifTokenIndex) {\n      throw this.error('expected IF token at start of conditional');\n    }\n    let ifToken = this.sourceTokenAtIndex(ifTokenIndex);\n    if (ifToken.type !== IF) {\n      throw this.error(\n        `expected IF token at start of conditional, but got ${ifToken.type.name}`\n      );\n    }\n    return ifTokenIndex;\n  }\n  /**\n   * Gets the index of the token representing the `else` between consequent and\n   * alternate.\n   *\n   * @private\n   */\n  getElseSourceTokenIndex(): ?SourceTokenListIndex {\n    let elseTokenIndex = this.indexOfSourceTokenBetweenSourceIndicesMatching(\n      this.consequent !== null ? this.consequent.outerEnd : this.condition.outerEnd,\n      this.alternate !== null ? this.alternate.outerStart : this.outerEnd,\n      token => token.type === ELSE\n    );\n    if (this.alternate !== null && !elseTokenIndex) {\n      throw this.error(\n        'expected ELSE token between consequent and alternate',\n        this.consequent.outerEnd,\n        this.alternate.outerStart\n      );\n    }\n    return elseTokenIndex;\n  }\n\n  /**\n   * Gets the index of the token representing the `then` between condition and\n   * consequent.\n   *\n   * @private\n   */\n  getThenTokenIndex(): ?SourceTokenListIndex {\n    if (this.consequent === null) {\n      return null;\n    }\n    return this.indexOfSourceTokenBetweenPatchersMatching(\n      this.condition,\n      this.consequent,\n      token => token.type === THEN\n    );\n  }\n\n  /**\n   * Conditionals have all code paths if there is an `else` and both the\n   * consequent and alternate have all their code paths.\n   */\n  allCodePathsPresent(): boolean {\n    if (!this.consequent || !this.alternate) {\n      return false;\n    }\n\n    return (\n      this.consequent.allCodePathsPresent() &&\n      this.alternate.allCodePathsPresent()\n    );\n  }\n}\n","import NodePatcher from '../../../patchers/NodePatcher.js';\nimport type { Editor, Node, ParseContext } from '../../../patchers/types.js';\n\nexport default class DefaultParamPatcher extends NodePatcher {\n  param: NodePatcher;\n  value: NodePatcher;\n  \n  constructor(node: Node, context: ParseContext, editor: Editor, param: NodePatcher, value: NodePatcher) {\n    super(node, context, editor);\n    this.param = param;\n    this.value = value;\n  }\n\n  initialize() {\n    this.param.setRequiresExpression();\n    this.value.setRequiresExpression();\n  }\n  \n  patchAsExpression() {\n    this.param.patch();\n    this.value.patch();\n  }\n}\n","import DefaultParamPatcher from './DefaultParamPatcher.js';\nimport FunctionPatcher from './FunctionPatcher.js';\nimport NodePatcher from '../../../patchers/NodePatcher.js';\nimport type { Editor, Node, ParseContext, SourceTokenListIndex } from '../../../patchers/types.js';\nimport { DO } from 'coffee-lex';\n\nexport default class DoOpPatcher extends NodePatcher {\n  expression: NodePatcher;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, expression: NodePatcher) {\n    super(node, context, editor);\n    this.expression = expression;\n  }\n\n  initialize() {\n    this.expression.setRequiresExpression();\n  }\n  \n  patchAsExpression() {\n    let doTokenIndex = this.getDoTokenIndex();\n    let doToken = this.sourceTokenAtIndex(doTokenIndex);\n    let nextToken = this.sourceTokenAtIndex(doTokenIndex.next());\n    this.remove(doToken.start, nextToken.start);\n\n    let addParens = (\n      this.expression instanceof FunctionPatcher &&\n      !this.isSurroundedByParentheses()\n    );\n\n    if (addParens) {\n      this.insert(this.outerStart, '(');\n    }\n\n    this.expression.patch();\n\n    if (addParens) {\n      this.insert(this.outerEnd, ')');\n    }\n\n    let args = [];\n    if (this.expression instanceof FunctionPatcher) {\n      let expression = (this.expression: FunctionPatcher);\n      expression.parameters.forEach(param => {\n        if (param instanceof DefaultParamPatcher) {\n          let valueSource = param.value.getPatchedSource();\n          this.remove(param.param.outerEnd, param.value.outerEnd);\n          args.push(valueSource);\n        } else {\n          args.push(param.getPatchedSource());\n        }\n      });\n    }\n    this.insert(this.innerEnd, `(${args.join(', ')})`);\n  }\n\n  /**\n   * @private\n   */\n  getDoTokenIndex(): SourceTokenListIndex {\n    let index = this.contentStartTokenIndex;\n    let token = this.sourceTokenAtIndex(index);\n    if (!token || token.type !== DO) {\n      throw this.error(`expected 'do' at start of expression`);\n    }\n    return index;\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Node, ParseContext, Editor } from './../../../patchers/types.js';\n\nexport default class DynamicMemberAccessOpPatcher extends NodePatcher {\n  expression: NodePatcher;\n  indexingExpr: NodePatcher;\n  \n  constructor(node: Node, context: ParseContext, editor: Editor, expression: NodePatcher, indexingExpr: NodePatcher) {\n    super(node, context, editor);\n    this.expression = expression;\n    this.indexingExpr = indexingExpr;\n  }\n\n  initialize() {\n    this.expression.setRequiresExpression();\n    this.indexingExpr.setRequiresExpression();\n  }\n\n  patchAsExpression() {\n    this.expression.patch();\n    this.indexingExpr.patch();\n  }\n\n  /**\n   * CoffeeScript considers dynamic member access repeatable if both parts\n   * are themselves repeatable. So, for example, `a[0]` is repeatable because\n   * both `a` and `0` are repeatable, but `a()[0]` and `a[b()]` are not.\n   */\n  isRepeatable(): boolean {\n    return this.expression.isRepeatable() && this.indexingExpr.isRepeatable();\n  }\n\n  /**\n   * We can make dynamic member access repeatable by making both parts\n   * repeatable if they aren't already. We do that by giving them names and\n   * referring to those names in a new dynamic member access. We cannot simply\n   * save the value of the member access because this could be used as the LHS\n   * of an assignment.\n   */\n  makeRepeatable(parens: boolean, ref: ?string=null): string { // eslint-disable-line no-unused-vars\n    let expression = this.expression.makeRepeatable(true, 'base');\n    let indexingExpr = this.indexingExpr.makeRepeatable(false, 'name');\n    return `${expression}[${indexingExpr}]`;\n  }\n\n  /**\n   * If `BASE` needs parens, then `BASE[INDEX]` needs parens.\n   */\n  statementNeedsParens(): boolean {\n    return this.expression.statementShouldAddParens();\n  }\n}\n","import BinaryOpPatcher from './BinaryOpPatcher.js';\nimport type { SourceToken } from './../../../patchers/types.js';\nimport { OPERATOR } from 'coffee-lex';\n\n/**\n * Handles equality and inequality comparisons.\n */\nexport default class EqualityPatcher extends BinaryOpPatcher {\n  negated: boolean = false;\n  \n  patchAsExpression() {\n    this.left.patch();\n    let compareToken = this.getCompareToken();\n    this.overwrite(\n      compareToken.start,\n      compareToken.end,\n      this.getCompareOperator()\n    );\n    this.right.patch();\n  }\n\n  getCompareOperator(): string {\n    switch (this.node.type) {\n      case 'EQOp':\n        return this.negated ? '!==' : '===';\n\n      case 'NEQOp':\n        return this.negated ? '===' : '!==';\n\n      case 'LTOp':\n        return this.negated ? '>=' : '<';\n\n      case 'GTOp':\n        return this.negated ? '<=' : '>';\n\n      case 'LTEOp':\n        return this.negated ? '>' : '<=';\n\n      case 'GTEOp':\n        return this.negated ? '<' : '>=';\n\n      default:\n        throw this.error(\n          `unsupported equality/inequality type: ${this.node.type}`\n        );\n    }\n  }\n\n  /**\n   * @private\n   */\n  getCompareToken(): SourceToken {\n    let { left, right } = this;\n    let compareTokenIndex = this.indexOfSourceTokenBetweenPatchersMatching(\n      left,\n      right,\n      token => token.type === OPERATOR\n    );\n\n    if (!compareTokenIndex) {\n      throw this.error(\n        'expected OPERATOR token but none was found',\n        left.outerEnd,\n        right.outerStart\n      );\n    }\n\n    return this.sourceTokenAtIndex(compareTokenIndex);\n  }\n\n  /**\n   * Flips negated flag but doesn't edit anything immediately so that we can\n   * use the correct operator in `patch`.\n   */\n  negate() {\n    this.negated = !this.negated;\n  }\n}\n","import BinaryOpPatcher from './BinaryOpPatcher.js';\n\n/**\n * Handles exponentiation, i.e. `a ** b`.\n */\nexport default class ExpOpPatcher extends BinaryOpPatcher {\n  /**\n   * LEFT '**' RIGHT\n   */\n  patchAsExpression() {\n    // `a ** b` → `Math.pow(a ** b`\n    //             ^^^^^^^^^\n    this.insert(this.contentStart, `Math.pow(`);\n\n    this.left.patch();\n\n    // `Math.pow(a ** b` → `Math.pow(a, b`\n    //            ^^^^                ^^\n    this.overwrite(this.left.outerEnd, this.right.outerStart, ', ');\n\n    this.right.patch();\n\n    // `Math.pow(a, b` → `Math.pow(a, b)`\n    //                                 ^\n    this.insert(this.contentEnd, `)`);\n  }\n\n  /**\n   * We'll always start with `Math.pow` so we don't need parens.\n   */\n  statementNeedsParens(): boolean {\n    return false;\n  }\n}\n","import CompoundAssignOpPatcher from './CompoundAssignOpPatcher.js';\nimport IdentifierPatcher from './IdentifierPatcher.js';\nimport traverse from '../../../utils/traverse.js';\n\nexport default class ExistsOpCompoundAssignOpPatcher extends CompoundAssignOpPatcher {\n  patchAsExpression() {\n    let assigneeAgain;\n    let needsTypeofCheck = (\n      this.assignee instanceof IdentifierPatcher &&\n      !this.node.scope.hasBinding(this.assignee.node.data)\n    );\n    if (needsTypeofCheck) {\n      // `a ?= b` → `typeof a ?= b`\n      //             ^^^^^^^\n      this.insert(this.assignee.outerStart, `typeof `);\n      this.assignee.patch();\n      assigneeAgain = this.assignee.makeRepeatable();\n      // `typeof a ? b` → `typeof a !== 'undefined' && a !== null ? a ?= b`\n      //                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      this.insert(\n        this.assignee.outerEnd,\n        ` !== 'undefined' && ${assigneeAgain} !== null ? ${assigneeAgain}`\n      );\n    } else {\n      this.assignee.patch();\n      assigneeAgain = this.assignee.makeRepeatable();\n      // `a.b ?= b` → `a.b != null ? a.b ?= b`\n      //                  ^^^^^^^^^^^^^^\n      this.insert(this.assignee.outerEnd, ` != null ? ${assigneeAgain}`);\n    }\n\n    let operator = this.getOperatorToken();\n    // `a.b != null ? a.b ?= b` → `a.b != null ? a.b : (a.b = b`\n    //                    ^^                         ^^^^^^^^\n    this.overwrite(operator.start, operator.end, `: (${assigneeAgain} =`);\n    this.expression.patch();\n    // `a.b != null ? a.b : (a.b = b` → `a.b != null ? a.b : (a.b = b)`\n    //                                                               ^\n    this.insert(this.expression.outerEnd, ')');\n  }\n\n  patchAsStatement() {\n    if (this.lhsHasSoakOperation()) {\n      this.patchAsExpression();\n      return;\n    }\n\n    let assigneeAgain;\n    if (this.assignee instanceof IdentifierPatcher) {\n      // `a ?= b` → `if (typeof a ?= b`\n      //             ^^^^^^^^^^^\n      this.insert(this.assignee.outerStart, `if (typeof `);\n      this.assignee.patch();\n      assigneeAgain = this.assignee.makeRepeatable();\n      // `if (typeof a ?= b` → `if (typeof a === 'undefined' || a === null) { ?= b`\n      //                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      this.insert(\n        this.assignee.outerEnd,\n        ` === 'undefined' || ${assigneeAgain} === null) {`\n      );\n    } else {\n      // `a.b ?= b` → `if (a.b ?= b`\n      //               ^^^^\n      this.insert(this.assignee.outerStart, `if (`);\n      this.assignee.patch();\n      assigneeAgain = this.assignee.makeRepeatable();\n      // `if (a.b ?= b` → `if (a.b == null) { ?= b`\n      //                          ^^^^^^^^^^^\n      this.insert(this.assignee.outerEnd, ` == null) {`);\n    }\n\n    let operator = this.getOperatorToken();\n    // `if (a.b == null) { ?= b` → `if (a.b == null) { a.b = b`\n    //                     ^^                          ^^^^^\n    this.overwrite(operator.start, operator.end, `${assigneeAgain} =`);\n    this.expression.patch();\n    // `if (a.b == null) { a.b = b` → `if (a.b == null) { a.b = b; }`\n    //                                                           ^^^\n    this.insert(this.expression.outerEnd, `; }`);\n  }\n\n  /**\n   * If the left-hand side of the assignment has a soak operation, then there\n   * may be a __guard__ call surrounding the whole thing, so we can't patch\n   * statement code, so instead run the expression code path.\n   */\n  lhsHasSoakOperation() {\n    let foundSoak = false;\n    traverse(this.assignee.node, node => {\n      if (foundSoak) {\n        return false;\n      }\n      if (node.type === 'SoakedDynamicMemberAccessOp' ||\n          node.type === 'SoakedFunctionApplication' ||\n          node.type === 'SoakedMemberAccessOp') {\n        foundSoak = true;\n      }\n    });\n    return foundSoak;\n  }\n\n  /**\n   * We'll always start with an `if` so we don't need parens.\n   */\n  statementNeedsParens(): boolean {\n    return false;\n  }\n}\n","import BinaryOpPatcher from './BinaryOpPatcher.js';\nimport IdentifierPatcher from './IdentifierPatcher.js';\n\nexport default class ExistsOpPatcher extends BinaryOpPatcher {\n  /**\n   * LEFT '?' RIGHT → `LEFT != null ? LEFT : RIGHT`\n   */\n  patchAsExpression() {\n    let needsTypeofCheck = (\n      this.left instanceof IdentifierPatcher &&\n      !this.node.scope.hasBinding(this.left.node.data)\n    );\n    if (needsTypeofCheck) {\n      // `a ? b` → `typeof a ? b`\n      //            ^^^^^^^\n      this.insert(this.contentStart, `typeof `);\n      let leftAgain = this.left.makeRepeatable(true, 'left');\n      this.left.patch();\n      // `typeof a ? b` → `typeof a !== 'undefined' && a !== null ? a : b`\n      //          ^^^              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      this.overwrite(\n        this.left.outerEnd,\n        this.right.outerStart,\n        ` !== 'undefined' && ${leftAgain} !== null ? ${leftAgain} : `\n      );\n    } else {\n      let leftAgain = this.left.makeRepeatable(true, 'left');\n      this.left.patch();\n      // `a.b ? c` → `a.b != null ? a.b : c`\n      //     ^^^         ^^^^^^^^^^^^^^^^^\n      this.overwrite(\n        this.left.outerEnd,\n        this.right.outerStart,\n        ` != null ? ${leftAgain} : `\n      );\n    }\n    this.right.patch();\n  }\n\n  /**\n   * LEFT '?' RIGHT → `if (LEFT == null) { RIGHT }`\n   */\n  patchAsStatement() {\n    let needsTypeofCheck = (\n      this.left instanceof IdentifierPatcher &&\n      !this.node.scope.hasBinding(this.left.node.data)\n    );\n    // `a ? b` → `if (a ? b`\n    //            ^^^\n    this.insert(this.contentStart, `if (`);\n    if (needsTypeofCheck) {\n      let leftAgain = this.left.makeRepeatable();\n      // `if (a ? b` → `if (typeof a ? b`\n      //                    ^^^^^^^\n      this.insert(this.contentStart, `typeof `);\n      // `if (typeof a ? b` → `if (typeof a === 'undefined' || a === null) { b`\n      //              ^^^                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      this.overwrite(\n        this.left.outerEnd,\n        this.right.outerStart,\n        ` === 'undefined' || ${leftAgain} === null) { `\n      );\n    } else {\n      // `if (a.b ? b.c` → `if (a.b == null) { b.c`\n      //         ^^^               ^^^^^^^^^^^^\n      this.overwrite(\n        this.left.outerEnd,\n        this.right.outerStart,\n        ` == null) { `\n      );\n    }\n    // `if (a.b == null) { b.c` → `if (a.b == null) { b.c }`\n    //                                                   ^^\n    this.insert(this.innerEnd, ` }`);\n  }\n\n  /**\n   * We'll always start with an `if` so we don't need parens.\n   */\n  statementNeedsParens(): boolean {\n    return false;\n  }\n}\n","import BinaryOpPatcher from './BinaryOpPatcher.js';\n\nconst EXTENDS_HELPER = `\nfunction __extends__(child, parent) {\n  Object.getOwnPropertyNames(parent).forEach(\n    name => child[name] = parent[name]\n  );\n  child.prototype = Object.create(parent.prototype);\n  child.__super__ = parent.prototype;\n  return child;\n}\n`;\n\n/**\n * Handles `extends` infix operator.\n */\nexport default class ExtendsOpPatcher extends BinaryOpPatcher {\n  /**\n   * CHILD extends PARENT\n   */\n  patchAsExpression() {\n    let helper = this.registerHelper('__extends__', EXTENDS_HELPER);\n    this.insert(this.left.outerStart, `${helper}(`);\n    this.left.patch();\n    this.overwrite(this.left.outerEnd, this.right.outerStart, ', ');\n    this.right.patch();\n    this.insert(this.right.outerEnd, ')');\n  }\n\n  /**\n   * We always prefix with `__extends__`, so no need for parens.\n   */\n  statementNeedsParens(): boolean {\n    return false;\n  }\n}\n","import BinaryOpPatcher from './BinaryOpPatcher.js';\n\nexport default class FloorDivideOpPatcher extends BinaryOpPatcher {\n  /**\n   * LEFT '//' RIGHT\n   */\n  patchAsExpression() {\n    let operator = this.getOperatorToken();\n\n    // `a // b` → `Math.floor(a // b`\n    //             ^^^^^^^^^^^\n    this.insert(this.contentStart, 'Math.floor(');\n\n    this.left.patch({ needsParens: true });\n\n    // `Math.floor(a // b)` → `Math.floor(a / b)`\n    //               ^^                     ^\n    this.overwrite(operator.start, operator.end, '/');\n\n    this.right.patch({ needsParens: true });\n\n    // `Math.floor(a // b` → `Math.floor(a // b)`\n    //                                         ^\n    this.insert(this.contentEnd, ')');\n  }\n\n  /**\n   * We always prefix with `Math.floor`, so no need for parens.\n   */\n  statementNeedsParens(): boolean {\n    return false;\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport traverse from '../../../utils/traverse.js';\nimport { isFunction } from '../../../utils/types.js';\n\nexport default class LoopPatcher extends NodePatcher {\n  body: BlockPatcher;\n  yielding: boolean;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, body: BlockPatcher) {\n    super(node, context, editor);\n    this.body = body;\n  }\n\n  patchAsExpression() {\n    // We're only patched as an expression due to a parent instructing us to,\n    // and the indent level is more logically the indent level of our parent.\n    let baseIndent = this.parent.getIndent(0);\n    let iifeBodyIndent = this.getLoopIndent();\n    this.body.setShouldPatchInline(false);\n    this.body.setImplicitlyReturns();\n    this.body.setIndent(this.getLoopBodyIndent());\n    let resultBinding = this.getResultArrayBinding();\n    let prefix = !this.yielding ? '(() =>' : 'yield* (function*()';\n    this.insert(this.innerStart, `${prefix} {\\n${iifeBodyIndent}${resultBinding} = [];\\n${iifeBodyIndent}`);\n    this.patchAsStatement();\n    let suffix = !this.yielding ? '()' : this.referencesArguments() ? '.apply(this, arguments)' : '.call(this)';\n    this.insert(this.innerEnd, `\\n${iifeBodyIndent}return ${resultBinding};\\n${baseIndent}})${suffix}`);\n  }\n\n  /**\n   * The first of three meaningful indentation levels for where we might want to\n   * insert code.\n   *\n   * As an example, in this code:\n   * a((() => {\n   *   for (let i = 0; i < b.length; i++) {\n   *     let val = b[i];\n   *     if (val) {\n   *       c;\n   *     }\n   *   )\n   * })())\n   *\n   * - `getLoopIndent` returns the indentation of the `for`.\n   * - `getOuterLoopBodyIndent` returns the indentation of the `if`.\n   * - `getLoopBodyIndent` returns the indentation of `c`.\n   *\n   * However, these levels may change based on whether the loop has a condition,\n   * and whether the loop is being formatted as an IIFE or as a regular loop\n   * statement.\n   *\n   * We need to be especially careful about when to actually set the indentation\n   * of existing code, since doing that too much can confuse magic-string. The\n   * only code that actually is adjusted is the loop body (but only when it's\n   * not an inline body), and this is done relatively early on in all cases.\n   */\n  getLoopIndent() {\n    if (this.willPatchAsExpression()) {\n      return this.parent.getIndent(1);\n    } else {\n      return this.getIndent();\n    }\n  }\n\n  /**\n   * @see getLoopIndent.\n   */\n  getOuterLoopBodyIndent() {\n    return this.getLoopIndent() + this.getProgramIndentString();\n  }\n\n  /**\n   * @see getLoopIndent.\n   */\n  getLoopBodyIndent() {\n    throw this.error(`'getLoopBodyIndent' must be overridden in subclasses`);\n  }\n\n  yieldController() {\n    this.yielding = true;\n    this.yields();\n  }\n\n  /**\n   * IIFE-style loop expressions should always be multi-line, even if the loop\n   * body in CoffeeScript is inline. This means we need to use a different\n   * patching strategy where we insert a newline in the proper place before\n   * generating code around the body, then we need to directly create the\n   * indentation just before patching the body.\n   */\n  patchPossibleNewlineAfterLoopHeader(loopHeaderEndIndex: number) {\n    if (this.shouldConvertInlineBodyToNonInline()) {\n      this.overwrite(loopHeaderEndIndex, this.body.contentStart, `\\n`);\n    }\n  }\n\n  patchBodyWithPossibleItemVariable() {\n    if (this.shouldConvertInlineBodyToNonInline()) {\n      this.body.insert(this.body.outerStart, this.getLoopBodyIndent());\n    }\n\n    if (this.willPatchAsExpression() && !this.allBodyCodePathsPresent()) {\n      let itemBinding = this.getResultArrayElementBinding();\n      this.body.insertStatementsAtIndex([`var ${itemBinding}`], 0);\n      this.body.patch({ leftBrace: false, rightBrace: false });\n      this.body.insertStatementsAtIndex(\n        [`${this.getResultArrayBinding()}.push(${itemBinding})`],\n        this.body.statements.length\n      );\n    } else {\n      this.body.patch({ leftBrace: false, rightBrace: false });\n    }\n  }\n\n  shouldConvertInlineBodyToNonInline() {\n    return this.willPatchAsExpression() && this.body.node.inline;\n  }\n\n  /**\n   * Most implicit returns cause program flow to break by using a `return`\n   * statement, but we don't do that since we're just collecting values in\n   * an array. This allows descendants who care about this to adjust their\n   * behavior accordingly.\n   */\n  implicitReturnWillBreak(): boolean {\n    if (this.willPatchAsExpression()) {\n      return false;\n    } else {\n      return super.implicitReturnWillBreak();\n    }\n  }\n\n  /**\n   * We decide how statements in implicit return positions are patched, if\n   * we're being used as an expression. This is because we don't want to return\n   * them, but add them to an array.\n   */\n  implicitReturnPatcher(): NodePatcher {\n    if (this.willPatchAsExpression()) {\n      return this;\n    } else {\n      return super.implicitReturnPatcher();\n    }\n  }\n\n  /**\n   * If this loop is used as an expression, then we need to collect all the\n   * values of the statements in implicit-return position. If all the code paths\n   * in our body are present, we can just add `result.push(…)` to all\n   * implicit-return position statements. If not, we want those code paths to\n   * result in adding `undefined` to the resulting array. The way we do that is\n   * by creating an `item` local variable that we set in each code path, and\n   * when the code exits through a missing code path (i.e. `if false then b`)\n   * then `item` will naturally have the value `undefined` which we then push\n   * at the end of the loop body.\n   */\n  patchImplicitReturnStart(patcher: NodePatcher) {\n    // Control flow statements like break and continue should be skipped.\n    if (!patcher.canPatchAsExpression()) {\n      return;\n    }\n    patcher.setRequiresExpression();\n    if (this.allBodyCodePathsPresent()) {\n      // `a + b` → `result.push(a + b`\n      //            ^^^^^^^^^^^^\n      this.insert(patcher.outerStart, `${this.getResultArrayBinding()}.push(`);\n    } else {\n      // `a + b` → `item = a + b`\n      //            ^^^^^^^\n      this.insert(patcher.outerStart, `${this.getResultArrayElementBinding()} = `);\n    }\n  }\n\n  /**\n   * @see patchImplicitReturnStart\n   */\n  patchImplicitReturnEnd(patcher: NodePatcher) {\n    if (!patcher.canPatchAsExpression()) {\n      return;\n    }\n    if (this.allBodyCodePathsPresent()) {\n      this.insert(patcher.outerEnd, `)`);\n    }\n  }\n\n  allBodyCodePathsPresent(): boolean {\n    if (this._allBodyCodePathsPresent === undefined) {\n      this._allBodyCodePathsPresent = this.body.allCodePathsPresent();\n    }\n    return this._allBodyCodePathsPresent;\n  }\n\n  /**\n   * @private\n   */\n  getResultArrayBinding(): string {\n    if (!this._resultArrayBinding) {\n      this._resultArrayBinding = this.claimFreeBinding('result');\n    }\n    return this._resultArrayBinding;\n  }\n\n  /**\n   * @private\n   */\n  getResultArrayElementBinding(): string {\n    if (!this._resultArrayElementBinding) {\n      this._resultArrayElementBinding = this.claimFreeBinding('item');\n    }\n    return this._resultArrayElementBinding;\n  }\n\n  statementNeedsSemicolon() {\n    return false;\n  }\n\n  /**\n   * @private\n   */\n  referencesArguments() {\n    let result = false;\n\n    traverse(this.node, node => {\n      if (result || isFunction(node)) {\n        return false;\n      }\n\n      if (node.type === 'Identifier' && node.data === 'arguments') {\n        result = true;\n      }\n    });\n\n    return result;\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport IdentifierPatcher from './IdentifierPatcher.js';\nimport LoopPatcher from './LoopPatcher.js';\nimport type BlockPatcher from './BlockPatcher.js';\nimport type { Node, ParseContext, Editor, SourceToken } from './../../../patchers/types.js';\nimport { RELATION, THEN } from 'coffee-lex';\n\nexport default class ForPatcher extends LoopPatcher {\n  keyAssignee: ?NodePatcher;\n  valAssignee: ?NodePatcher;\n  target: NodePatcher;\n  filter: ?NodePatcher;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, keyAssignee: ?NodePatcher, valAssignee: ?NodePatcher, target: NodePatcher, filter: ?NodePatcher, body: BlockPatcher) {\n    super(node, context, editor, body);\n    this.keyAssignee = keyAssignee;\n    this.valAssignee = valAssignee;\n    this.target = target;\n    this.filter = filter;\n  }\n\n  initialize() {\n    if (this.keyAssignee) {\n      this.keyAssignee.setRequiresExpression();\n    }\n    if (this.valAssignee) {\n      this.valAssignee.setRequiresExpression();\n    }\n    this.target.setRequiresExpression();\n    if (this.filter) {\n      this.filter.setRequiresExpression();\n    }\n  }\n\n  getFilterCode(): ?string {\n    let filter = this.filter;\n    if (!filter) {\n      return null;\n    }\n    if (!this._filterCode) {\n      this._filterCode = filter.patchAndGetCode({ needsParens: false });\n    }\n    return this._filterCode;\n  }\n\n  getLoopBodyIndent() {\n    if (this.filter) {\n      return this.getOuterLoopBodyIndent() + this.getProgramIndentString();\n    } else {\n      return this.getOuterLoopBodyIndent();\n    }\n  }\n\n  patchBodyAndFilter() {\n    let {body, filter} = this;\n\n    if (filter) {\n      this.body.insertLineBefore(`if (${this.getFilterCode()}) {`, this.getOuterLoopBodyIndent());\n      this.patchBodyWithPossibleItemVariable();\n      body.insertLineAfter('}', this.getOuterLoopBodyIndent());\n      body.insertLineAfter('}', this.getLoopIndent());\n    } else {\n      this.patchBodyWithPossibleItemVariable();\n      body.insertLineAfter('}', this.getLoopIndent());\n    }\n  }\n\n  getRelationToken(): SourceToken {\n    let tokenIndex = this.indexOfSourceTokenBetweenPatchersMatching(\n      this.keyAssignee || this.valAssignee, this.target,\n      token => token.type === RELATION\n    );\n    if (!tokenIndex) {\n      throw this.error(`cannot find relation keyword in 'for' loop`);\n    }\n    return this.sourceTokenAtIndex(tokenIndex);\n  }\n\n  /**\n   * @protected\n   */\n  getIndexBinding(): string {\n    if (!this._indexBinding) {\n      this._indexBinding = this.computeIndexBinding();\n    }\n    return this._indexBinding;\n  }\n\n  /**\n   * @protected\n   */\n  computeIndexBinding(): string {\n    let keyAssignee = this.keyAssignee;\n    if (keyAssignee) {\n      if (!(keyAssignee instanceof IdentifierPatcher)) {\n        // CoffeeScript requires that the index be an identifier, not a pattern\n        // matching expression, so this should never happen.\n        throw keyAssignee.error(`expected loop index to be an identifier`);\n      }\n      return this.slice(keyAssignee.contentStart, keyAssignee.contentEnd);\n    } else {\n      return this.claimFreeBinding(this.indexBindingCandidates());\n    }\n  }\n\n  /**\n   * @protected\n   */\n  indexBindingCandidates(): Array<string> {\n    return ['i', 'j', 'k'];\n  }\n\n  /**\n   * @protected\n   */\n  removeThenToken() {\n    let index = this.indexOfSourceTokenBetweenPatchersMatching(\n      this.target, this.body,\n      token => token.type === THEN\n    );\n    if (index) {\n      let thenToken = this.sourceTokenAtIndex(index);\n      let nextToken = this.sourceTokenAtIndex(index.next());\n      this.remove(thenToken.start, nextToken.start);\n    }\n  }\n\n  getTargetCode(): string {\n    // Trigger patching the reference.\n    this.getTargetReference();\n    return this.slice(this.target.contentStart, this.target.contentEnd);\n  }\n\n  getTargetReference(): string {\n    if (!this._targetReference) {\n      if (this.requiresExtractingTarget()) {\n        this.target.patch();\n        this._targetReference = this.claimFreeBinding(this.targetBindingCandidate());\n      } else {\n        this._targetReference = this.target.patchAndGetCode();\n      }\n    }\n    return this._targetReference;\n  }\n}\n","import BinaryOpPatcher from './BinaryOpPatcher.js';\n\nconst RANGE_HELPER =\n`function __range__(left, right, inclusive) {\n  let range = [];\n  let ascending = left < right;\n  let end = !inclusive ? right : ascending ? right + 1 : right - 1;\n  for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n    range.push(i);\n  }\n  return range;\n}`;\n\nconst MAXIMUM_LITERAL_RANGE_ELEMENTS = 21;\n\nexport default class RangePatcher extends BinaryOpPatcher {\n  patchAsExpression() {\n    if (this.canBecomeLiteralArray()) {\n      this.patchAsLiteralArray();\n    } else {\n      this.patchAsIIFE();\n    }\n  }\n\n  /**\n   * @private\n   */\n  patchAsLiteralArray() {\n    let start = this.left.node.data;\n    let end = this.right.node.data;\n    let inclusive = this.isInclusive();\n    let ascending = start < end;\n\n    if (inclusive) {\n      end += ascending ? 1 : -1;\n    }\n\n    let list = '';\n\n    for (let i = start; ascending ? i < end : i > end; ascending ? i++ : i--) {\n      let isLast = ascending ? i === end - 1 : i === end + 1;\n      if (isLast) {\n        list += `${i}`;\n      } else {\n        list += `${i}, `;\n      }\n    }\n\n    // `[0..2]` → `[0, 1, 2]`\n    //  ^^^^^^     ^^^^^^^^^\n    this.overwrite(this.contentStart, this.contentEnd, `[${list}]`);\n  }\n\n  /**\n   * @private\n   */\n  patchAsIIFE() {\n    let helper = this.registerHelper('__range__', RANGE_HELPER);\n\n    // `[a..b]` → `__range__(a..b]`\n    //  ^          ^^^^^^^^^^\n    this.overwrite(this.contentStart, this.left.outerStart, `${helper}(`);\n\n    this.left.patch();\n\n    // `__range__(a..b]` → `__range__(a, b]`\n    //             ^^                  ^^\n    this.overwrite(this.left.outerEnd, this.right.outerStart, ', ');\n\n    this.right.patch();\n\n    // `__range__(a, b]` → `__range__(a, b, true)`\n    //                ^                   ^^^^^^\n    this.overwrite(this.right.outerEnd, this.contentEnd, `, ${this.isInclusive()})`);\n  }\n\n  /**\n   * @private\n   */\n  canBecomeLiteralArray(): boolean {\n    let range = this.getLiteralRange();\n\n    if (!range) {\n      return false;\n    }\n\n    let [ first, last ] = range;\n    return Math.abs(last - first) <= MAXIMUM_LITERAL_RANGE_ELEMENTS;\n  }\n\n  /**\n   * @private\n   */\n  getLiteralRange(): ?[number, number] {\n    let left = this.left.node;\n    let right = this.right.node;\n\n    if (left.type !== 'Int' || right.type !== 'Int') {\n      return false;\n    }\n\n    let first = left.data;\n    let last = right.data;\n    if (first < last) {\n      return [first, last + (this.isInclusive() ? 1 : 0)];\n    } else {\n      return [first, last - (this.isInclusive() ? 1 : 0)];\n    }\n  }\n\n  /**\n   * @private\n   */\n  isInclusive(): boolean {\n    return this.node.isInclusive;\n  }\n}\n","import ForPatcher from './ForPatcher.js';\nimport RangePatcher from './RangePatcher.js';\nimport isObjectInitialiserBlock from '../../../utils/isObjectInitialiserBlock.js';\nimport type BlockPatcher from './BlockPatcher.js';\nimport type NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Node, ParseContext, Editor } from './../../../patchers/types.js';\n\nconst UP = 'UP';\nconst DOWN = 'DOWN';\nconst UNKNOWN = 'UNKNOWN';\ntype IndexDirection = 'UP' | 'DOWN' | 'UNKNOWN';\n\nexport default class ForInPatcher extends ForPatcher {\n  constructor(node: Node, context: ParseContext, editor: Editor, keyAssignee: ?NodePatcher, valAssignee: ?NodePatcher, target: NodePatcher, step: ?NodePatcher, filter: ?NodePatcher, body: BlockPatcher) {\n    super(node, context, editor, keyAssignee, valAssignee, target, filter, body);\n    this.step = step;\n  }\n\n  initialize() {\n    super.initialize();\n    if (this.step) {\n      this.step.setRequiresExpression();\n    }\n  }\n\n  patchAsExpression() {\n    // When possible, we want to transform the loop into a use of `map`, but\n    // there are some cases when we can't. Use the more general approach of a\n    // statement loop within an IIFE if that's the case.\n    if (!this.canPatchAsMapExpression()) {\n      return super.patchAsExpression();\n    }\n    this.removeThenToken();\n\n    let assigneeCode = this.getValueBinding();\n    if (this.keyAssignee) {\n      assigneeCode += `, ${this.getIndexBinding()}`;\n    }\n\n    // for a in b when c d  ->  b when c d\n    // (\"then\" was removed above).\n    this.remove(this.contentStart, this.target.outerStart);\n    this.target.patch();\n    if (this.filter !== null) {\n      // b when c d  ->  b.filter((a) => c d\n      this.overwrite(\n        this.target.outerEnd, this.filter.outerStart,\n        `.filter((${assigneeCode}) => `\n      );\n      this.filter.patch();\n      // b.filter((a) => c d  ->  b.filter((a) => c).map((a) => d\n      this.insert(this.filter.outerEnd, `).map((${assigneeCode}) =>`);\n    } else {\n      // b d  ->  b.map((a) => d\n      this.insert(this.target.outerEnd, `.map((${assigneeCode}) =>`);\n    }\n    this.patchBodyForExpressionLoop();\n    // b.filter((a) => c).map((a) => d  ->  b.filter((a) => c).map((a) => d)\n    this.insert(this.body.outerEnd, ')');\n  }\n\n  patchBodyForExpressionLoop() {\n    this.body.setRequiresExpression();\n    let bodyNeedsParens = isObjectInitialiserBlock(this.body)\n      && !this.body.isSurroundedByParentheses();\n    if (bodyNeedsParens) {\n      let insertPoint = this.filter ? this.filter.outerEnd : this.target.outerEnd;\n      // Handle both inline and multiline cases by either skipping the existing\n      // space or adding one.\n      if (this.slice(insertPoint, insertPoint + 1) === ' ') {\n        this.body.insert(insertPoint + 1, '(');\n      } else {\n        this.body.insert(insertPoint, ' (');\n      }\n    }\n    this.body.patch();\n    if (bodyNeedsParens) {\n      this.body.insert(this.body.outerEnd, ')');\n    }\n  }\n\n  canPatchAsMapExpression(): boolean {\n    if (this.step !== null) {\n      return false;\n    }\n    if (!this.body.canPatchAsExpression()) {\n      return false;\n    }\n    // The high-level approach of a.filter(...).map((x, i) => ...) doesn't work,\n    // since the filter will change the indexes, so we specifically exclude that\n    // case.\n    if (this.filter !== null && this.keyAssignee !== null) {\n      return false;\n    }\n    return true;\n  }\n\n  patchAsStatement() {\n    if (!this.body.inline()) {\n      this.body.setIndent(this.getLoopBodyIndent());\n    }\n\n    if (this.shouldPatchAsForOf()) {\n      this.getFilterCode();\n      this.patchForOfLoop();\n    } else {\n      // Run for the side-effect of patching and slicing the value.\n      this.getValueBinding();\n      this.getFilterCode();\n\n      this.patchForLoopHeader();\n      this.patchForLoopBody();\n    }\n  }\n\n  /**\n   * As long as we aren't using the loop index or a step, we prefer to use JS\n   * for-of loops.\n   */\n  shouldPatchAsForOf() {\n    return (\n      !this.shouldPatchAsInitTestUpdateLoop() &&\n      this.step === null &&\n      this.keyAssignee === null\n    );\n  }\n\n  getValueBinding(): string {\n    if (!this._valueBinding) {\n      if (this.valAssignee) {\n        this._valueBinding = this.valAssignee.patchAndGetCode();\n      } else if (this.shouldPatchAsInitTestUpdateLoop()) {\n        this._valueBinding = this.claimFreeBinding(this.indexBindingCandidates());\n      } else {\n        this._valueBinding = this.claimFreeBinding('value');\n      }\n    }\n    return this._valueBinding;\n  }\n\n  /**\n   * @protected\n   */\n  computeIndexBinding(): string {\n    if (this.shouldPatchAsInitTestUpdateLoop()) {\n      return this.getValueBinding();\n    } else {\n      return super.computeIndexBinding();\n    }\n  }\n\n  patchForLoopHeader() {\n    if (this.requiresExtractingTarget()) {\n      this.insert(this.innerStart, `${this.getTargetReference()} = ${this.getTargetCode()}\\n${this.getLoopIndent()}`);\n    }\n    let firstHeaderPatcher = this.valAssignee || this.target;\n    let lastHeaderPatcher = this.getLastHeaderPatcher();\n    this.overwrite(\n      firstHeaderPatcher.outerStart,\n      lastHeaderPatcher.outerEnd,\n      `(${this.getInitCode()}; ${this.getTestCode()}; ${this.getUpdateCode()}) {`\n    );\n  }\n\n  getLastHeaderPatcher(): NodePatcher {\n    return [this.step, this.filter, this.target]\n      .filter(patcher => patcher)\n      .reduce((last, patcher) =>\n        patcher.contentEnd > last.contentEnd ? patcher : last\n      );\n  }\n\n  patchForLoopBody() {\n    this.removeThenToken();\n    this.patchPossibleNewlineAfterLoopHeader(this.getLastHeaderPatcher().outerEnd);\n\n    if (!this.shouldPatchAsInitTestUpdateLoop() && this.valAssignee) {\n      let valueAssignment = `${this.getValueBinding()} = ${this.getTargetReference()}[${this.getIndexBinding()}]`;\n      if (this.valAssignee.statementNeedsParens()) {\n        valueAssignment = `(${valueAssignment})`;\n      }\n      this.body.insertLineBefore(valueAssignment, this.getOuterLoopBodyIndent());\n    }\n    this.patchBodyAndFilter();\n  }\n\n  /**\n   * Special case for patching for-of case for when the loop is simple enough\n   * that for-of works. Note that for-of has slightly different semantics\n   * because it uses the iterator protocol rather than CoffeeScript's notion of\n   * an array-like object, so this transform sacrifices 100% correctness in\n   * favor of cleaner code.\n   */\n  patchForOfLoop() {\n    // Save the filter code and remove if it it's there.\n    this.getFilterCode();\n    if (this.filter) {\n      this.remove(this.target.outerEnd, this.filter.outerEnd);\n    }\n\n    if (this.valAssignee) {\n      let relationToken = this.getRelationToken();\n      this.valAssignee.patch();\n      this.insert(this.valAssignee.outerStart, '(');\n      this.overwrite(relationToken.start, relationToken.end, 'of');\n    } else {\n      // Handle loops like `for [0..2]`\n      let valueBinding = this.getValueBinding();\n      this.insert(this.target.outerStart, `(let ${valueBinding} of `);\n    }\n\n    this.target.patch();\n    this.insert(this.target.outerEnd, ') {');\n    this.removeThenToken();\n    this.patchBodyAndFilter();\n  }\n\n  requiresExtractingTarget() {\n    return (\n      !this.shouldPatchAsInitTestUpdateLoop() &&\n      !this.target.isRepeatable() &&\n      !this.shouldPatchAsForOf()\n    );\n  }\n\n  targetBindingCandidate() {\n    return 'iterable';\n  }\n\n  getInitCode(): string {\n    let step = this.getStep();\n    if (this.shouldPatchAsInitTestUpdateLoop()) {\n      return `${this.getIndexBinding()} = ${this.target.left.patchAndGetCode()}`;\n    } else if (step.negated) {\n      return `${this.getIndexBinding()} = ${this.getTargetReference()}.length - 1`;\n    } else {\n      let result = `${this.getIndexBinding()} = 0`;\n      if (!step.isLiteral) {\n        result += `, ${step.update} = ${step.init}`;\n      }\n      return result;\n    }\n  }\n\n  getTestCode(): string {\n    let step = this.getStep();\n    if (this.shouldPatchAsInitTestUpdateLoop()) {\n      let direction = this.getIndexDirection();\n      let inclusive = this.target.isInclusive();\n      let operator;\n\n      if (direction === DOWN) {\n        operator = inclusive ? '>=' : '>';\n      } else {\n        operator = inclusive ? '<=' : '<';\n      }\n\n      return `${this.getIndexBinding()} ${operator} ${this.target.right.patchAndGetCode()}`;\n    } else if (step.negated) {\n      return `${this.getIndexBinding()} >= 0`;\n    } else {\n      return `${this.getIndexBinding()} < ${this.getTargetReference()}.length`;\n    }\n  }\n\n  getUpdateCode(): string {\n    let indexBinding = this.getIndexBinding();\n    let step = this.getStep();\n    let direction = this.getIndexDirection();\n    if (step.number === 1) {\n      return `${indexBinding}${direction === DOWN ? '--' : '++'}`;\n    } else if (direction === DOWN) {\n      return `${indexBinding} -= ${step.update}`;\n    } else {\n      return `${indexBinding} += ${step.update}`;\n    }\n  }\n\n  getStep(): Step {\n    if (this._step === undefined) {\n      this._step = new Step(this.step);\n    }\n    return this._step;\n  }\n\n  /**\n   * Can we patch using `for (;;)` style?\n   *\n   * Currently, that requires either a fixed range:\n   *\n   *   a() for [0..1]\n   *\n   * Or a dynamic range with a fixed step:\n   *\n   *   a() for [n..m] by 1\n   *\n   * Eventually, we could also support any dynamic range:\n   *\n   *   a() for [from..to]\n   *   a() for [lower()..upper()]\n   *\n   * By capturing the bounds as needed and comparing:\n   *\n   *   for (let asc = from <= to, i = from; asc ? i <= to : i >= to; asc ? i++ : i--) {\n   *     a();\n   *   }\n   *   for (let start = lower(), end = upper(), asc = start <= end, i = start; asc ? i <= end : i >= end; asc ? i++ : i--) {\n   *     a();\n   *   }\n   */\n  shouldPatchAsInitTestUpdateLoop(): boolean {\n    return this.hasFixedRange() || (this.hasDynamicRange() && this.hasExplicitStep());\n  }\n\n  /**\n   * Determines whether this `for…in` loop has an explicit `by` step.\n   */\n  hasExplicitStep(): boolean {\n    return !this.getStep().isVirtual;\n  }\n\n  /**\n   * Determines the direction of index iteration, either UP, DOWN, or UNKNOWN.\n   * UNKNOWN means that we cannot statically determine the direction.\n   */\n  getIndexDirection(): IndexDirection {\n    let step = this.getStep();\n    if (step.isVirtual && this.hasFixedRange()) {\n      let left = this.target.left.node.data;\n      let right = this.target.right.node.data;\n      return left > right ? DOWN : UP;\n    } else if (this.hasDynamicRange()) {\n      return UNKNOWN;\n    } else {\n      return step.negated ? DOWN : UP;\n    }\n  }\n\n  /**\n   * Are we looping over a range with dynamic start/end?\n   *\n   * @example\n   *\n   *   for [a..b]\n   *   for [0..b]\n   */\n  hasDynamicRange(): boolean {\n    return (this.target instanceof RangePatcher) && !this.hasFixedRange();\n  }\n\n  /**\n   * Are we looping over a range with fixed (static) start/end?\n   *\n   * @example\n   *\n   *   for [0..3]\n   *   for [7.0..10.0]\n   */\n  hasFixedRange(): boolean {\n    return (\n      this.target instanceof RangePatcher &&\n      (this.target.left.node.type === 'Int' || this.target.left.node.type === 'Float') &&\n      (this.target.right.node.type === 'Int' || this.target.right.node.type === 'Float')\n    );\n  }\n}\n\nclass Step {\n  isLiteral: boolean;\n  isVirtual: boolean;\n  negated: boolean;\n  init: string;\n  update: string;\n  number: ?number;\n  raw: string;\n\n  constructor(patcher: ?NodePatcher) {\n    let negated = false;\n    let root = patcher;\n    let apply = (patcher: NodePatcher) => {\n      if (patcher.node.type === 'UnaryNegateOp') {\n        negated = !negated;\n        apply(patcher.expression);\n      } else {\n        root = patcher;\n      }\n    };\n    if (patcher) {\n      apply(patcher);\n      patcher.patch();\n      this.isLiteral = root.node.type === 'Int' || root.node.type === 'Float';\n      this.init = patcher.slice(patcher.contentStart, patcher.contentEnd);\n      if (this.isLiteral) {\n        this.update = root.slice(root.contentStart, root.contentEnd);\n        this.number = root.node.data;\n      } else {\n        this.update = root.claimFreeBinding('step');\n        this.number = null;\n      }\n    } else {\n      this.isLiteral = true;\n      this.init = '1';\n      this.update = '1';\n      this.number = 1;\n    }\n    this.negated = negated;\n    this.isVirtual = !patcher;\n  }\n}\n","import ForPatcher from './ForPatcher.js';\nimport {OWN} from 'coffee-lex';\n\nexport default class ForOfPatcher extends ForPatcher {\n  patchAsStatement() {\n    if (!this.body.inline()) {\n      this.body.setIndent(this.getLoopBodyIndent());\n    }\n\n    let { keyAssignee } = this;\n\n    // Save the filter code and remove if it it's there.\n    this.getFilterCode();\n    if (this.filter) {\n      this.remove(this.target.outerEnd, this.filter.outerEnd);\n    }\n\n    this.removeOwnTokenIfExists();\n\n    let shouldExtractTarget = this.requiresExtractingTarget();\n    if (shouldExtractTarget) {\n      this.insert(\n        this.innerStart,\n        `${this.getTargetReference()} = ${this.getTargetCode()}\\n${this.getLoopIndent()}`\n      );\n    }\n\n    let keyBinding = this.getIndexBinding();\n    this.insert(keyAssignee.outerStart, '(');\n\n    // Patch the target. Also get a reference in case we need it.\n    let targetReference = this.getTargetReference();\n    if (shouldExtractTarget) {\n      this.overwrite(this.target.outerStart, this.target.outerEnd, targetReference);\n    }\n\n    let { valAssignee } = this;\n\n    let valueAssignment = null;\n    if (valAssignee) {\n      valAssignee.patch();\n      let valAssigneeString = this.slice(valAssignee.contentStart, valAssignee.contentEnd);\n      // `for (k, v of o` → `for (k of o`\n      //        ^^^\n      this.remove(keyAssignee.outerEnd, valAssignee.outerEnd);\n\n      valueAssignment = `${valAssigneeString} = ${this.getTargetReference()}[${keyBinding}]`;\n\n      if (valAssignee.statementNeedsParens()) {\n        valueAssignment = `(${valueAssignment})`;\n      }\n    }\n\n    let relationToken = this.getRelationToken();\n    if (this.node.isOwn) {\n      // `for (k of o` → `for (k of Object.keys(o`\n      //                            ^^^^^^^^^^^^\n      this.insert(this.target.outerStart, 'Object.keys(');\n\n      // `for (k of o` → `for (k of Object.keys(o)) {`\n      //                                         ^^^^\n      this.insert(this.target.outerEnd, ')) {');\n    } else {\n      // `for (k of o` → `for (k in o`\n      //         ^^              ^^\n      this.overwrite(relationToken.start, relationToken.end, 'in');\n\n      // `for (k in o` → `for (k in o) {`\n      //                             ^^^\n      this.insert(this.target.outerEnd, ') {');\n    }\n\n    this.removeThenToken();\n    this.patchPossibleNewlineAfterLoopHeader(this.target.outerEnd);\n    if (valueAssignment !== null) {\n      this.body.insertLineBefore(valueAssignment, this.getOuterLoopBodyIndent());\n    }\n    this.patchBodyAndFilter();\n  }\n\n  removeOwnTokenIfExists() {\n    if (this.node.isOwn) {\n      let ownIndex = this.indexOfSourceTokenAfterSourceTokenIndex(\n        this.contentStartTokenIndex,\n        OWN\n      );\n      let ownToken = this.sourceTokenAtIndex(ownIndex);\n      this.remove(ownToken.start, this.keyAssignee.outerStart);\n    }\n  }\n\n  requiresExtractingTarget() {\n    return !this.target.isRepeatable() && this.valAssignee;\n  }\n\n  targetBindingCandidate() {\n    return 'object';\n  }\n\n  indexBindingCandidates(): Array<string> {\n    return ['key'];\n  }\n}\n","import InterpolatedPatcher from './InterpolatedPatcher.js';\n\nconst CLOSE_TOKEN_BASE_LENGTH = 3;\n\nexport default class HeregexPatcher extends InterpolatedPatcher {\n  patchAsExpression() {\n    let openToken = this.firstToken();\n    let closeToken = this.lastToken();\n\n    this.overwrite(openToken.start, openToken.end, 'new RegExp(`');\n    if (closeToken.end - closeToken.start > CLOSE_TOKEN_BASE_LENGTH) {\n      // If the close token has flags, e.g. ///gi, keep the flags as a string literal.\n      this.overwrite(closeToken.start, closeToken.start + CLOSE_TOKEN_BASE_LENGTH, '`, \\'');\n      this.insert(closeToken.end, '\\')');\n    } else {\n      // Otherwise, don't specify flags.\n      this.overwrite(closeToken.start, closeToken.end, '`)');\n    }\n\n    this.patchInterpolations();\n    this.removePadding();\n    this.escapeQuasis(/^\\\\\\s/, ['`', '${', '\\\\']);\n  }\n}\n","import ArrayInitialiserPatcher from './ArrayInitialiserPatcher.js';\nimport BinaryOpPatcher from './BinaryOpPatcher.js';\nimport DynamicMemberAccessOpPatcher from './DynamicMemberAccessOpPatcher.js';\nimport FunctionApplicationPatcher from './FunctionApplicationPatcher.js';\nimport IdentifierPatcher from './IdentifierPatcher.js';\nimport MemberAccessOpPatcher from './MemberAccessOpPatcher.js';\nimport StringPatcher from './StringPatcher.js';\nimport type NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { SourceToken, Editor, Node, ParseContext } from './../../../patchers/types.js';\nimport { RELATION } from 'coffee-lex';\n\n/**\n * Handles `in` operators, e.g. `a in b` and `a not in b`.\n */\nexport default class InOpPatcher extends BinaryOpPatcher {\n  negated: boolean;\n\n  /**\n   * `node` is of type `InOp`.\n   */\n  constructor(node: Node, context: ParseContext, editor: Editor, left: NodePatcher, right: NodePatcher) {\n    super(node, context, editor, left, right);\n    this.negated = node.isNot;\n  }\n\n  negate() {\n    this.negated = !this.negated;\n  }\n\n  operatorTokenPredicate(): (token: SourceToken) => boolean {\n    return (token: SourceToken) => token.type === RELATION;\n  }\n\n  /**\n   * LEFT 'in' RIGHT\n   */\n  patchAsExpression() {\n    // In typical cases, when converting `a in b` to `b.includes(a)`, parens\n    // won't be necessary around the `b`, but to be safe, only skip the parens\n    // in a specific set of known-good cases.\n    let arrayNeedsParens = !this.right.isSurroundedByParentheses() &&\n        !(this.right instanceof IdentifierPatcher) &&\n        !(this.right instanceof MemberAccessOpPatcher) &&\n        !(this.right instanceof DynamicMemberAccessOpPatcher) &&\n        !(this.right instanceof FunctionApplicationPatcher) &&\n        !(this.right instanceof ArrayInitialiserPatcher) &&\n        !(this.right instanceof StringPatcher);\n\n    this.left.patch();\n    let leftCode = this.slice(this.left.contentStart, this.left.contentEnd);\n\n    // `a in b` → `b`\n    //  ^^^^^\n    this.remove(this.left.outerStart, this.right.outerStart);\n\n    if (this.negated) {\n      // `b` → `!b`\n      //        ^\n      this.insert(this.right.outerStart, '!');\n    }\n    if (arrayNeedsParens) {\n      // `!b` → `!(b`\n      //          ^\n      this.insert(this.right.outerStart, '(');\n    }\n\n    this.right.patch();\n\n    if (arrayNeedsParens) {\n      // `!(b` → `!(b)`\n      //             ^\n      this.insert(this.right.outerEnd, ')');\n    }\n\n    // `!(b` → `!(b).includes(a)`\n    //              ^^^^^^^^^^^^\n    this.insert(this.right.outerEnd, `.includes(${leftCode})`);\n  }\n\n  /**\n   * Method invocations don't need parens.\n   */\n  statementNeedsParens(): boolean {\n    return false;\n  }\n}\n","import BinaryOpPatcher from './BinaryOpPatcher.js';\nimport type NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Editor, Node, ParseContext } from './../../../patchers/types.js';\n\n/**\n * Handles `instanceof` operator, e.g. `a instanceof b`.\n */\nexport default class NegatableBinaryOpPatcher extends BinaryOpPatcher {\n  negated: boolean;\n  \n  constructor(node: Node, context: ParseContext, editor: Editor, left: NodePatcher, right: NodePatcher) {\n    super(node, context, editor, left, right);\n    this.negated = node.isNot;\n  }\n\n  negate() {\n    this.negated = !this.negated;\n  }\n\n  javaScriptOperator() {\n    throw new Error(`'javaScriptOperator' should be implemented in subclass`);\n  }\n\n  /**\n   * LEFT 'not'? OP RIGHT\n   */\n  patchAsExpression() {\n    let { negated } = this;\n    if (negated) {\n      // `a not instanceof b` → `!(a not instanceof b`\n      //                         ^^\n      this.insert(this.innerStart, '!(');\n    }\n\n    // Patch LEFT and RIGHT.\n    super.patchAsExpression();\n\n    if (negated) {\n      // `!(a not instanceof b` → `!(a not instanceof b)`\n      //                                               ^\n      this.insert(this.innerEnd, ')');\n    }\n\n    // `!(a not instanceof b)` → `!(a instanceof b)`\n    //      ^^^^^^^^^^^^^^            ^^^^^^^^^^\n    let token = this.getOperatorToken();\n    this.overwrite(token.start, token.end, this.javaScriptOperator());\n  }\n\n  /**\n   * It may be wrapped due to negation, so don't double-wrap.\n   */\n  statementNeedsParens(): boolean {\n    if (this.negated) {\n      return false;\n    } else {\n      return super.statementNeedsParens();\n    }\n  }\n}\n","import NegatableBinaryOpPatcher from './NegatableBinaryOpPatcher.js';\n\n/**\n * Handles `instanceof` operator, e.g. `a instanceof b`.\n */\nexport default class InstanceofOpPatcher extends NegatableBinaryOpPatcher {\n  javaScriptOperator() {\n    return 'instanceof';\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\n\n/**\n * Handles embedded JavaScript.\n */\nexport default class JavaScriptPatcher extends NodePatcher {\n  /**\n   * All we have to do is strip off the backticks.\n   */\n  patchAsExpression() {\n    // '`void 0`' → 'void 0`'\n    //  ^\n    this.remove(this.contentStart, this.contentStart + '`'.length);\n    // 'void 0`' → 'void 0'\n    //        ^\n    this.remove(this.contentEnd - '`'.length, this.contentEnd);\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Node, ParseContext, Editor } from './../../../patchers/types.js';\n\nexport default class UnaryOpPatcher extends NodePatcher {\n  expression: NodePatcher;\n  \n  constructor(node: Node, context: ParseContext, editor: Editor, expression: NodePatcher) {\n    super(node, context, editor);\n    this.expression = expression;\n  }\n\n  initialize() {\n    this.expression.setRequiresExpression();\n  }\n\n  /**\n   * OP EXPRESSION\n   */\n  patchAsExpression({ needsParens=true }={}) {\n    this.expression.patch({ needsParens });\n  }\n\n  /**\n   * If `EXPRESSION` needs parens then `EXPRESSION OP` needs parens.\n   */\n  statementNeedsParens(): boolean {\n    return this.expression.statementShouldAddParens();\n  }\n}\n","import UnaryOpPatcher from './UnaryOpPatcher.js';\n\nexport default class LogicalNotOpPatcher extends UnaryOpPatcher {\n  /**\n   * Though it's possible that `!` could trigger a `valueOf` call to arbitrary\n   * code, CoffeeScript ignores that possibility and so do we.\n   */\n  isRepeatable(): boolean {\n    return this.expression.isRepeatable();\n  }\n\n  /**\n   * ( `!` | `not` ) EXPRESSION\n   */\n  patchAsExpression(options={}) {\n    if (this.expression.canHandleNegationInternally()) {\n      this.expression.negate();\n      this.remove(this.contentStart, this.expression.outerStart);\n    } else {\n      this.overwrite(this.contentStart, this.expression.outerStart, '!');\n    }\n    super.patchAsExpression(options);\n  }\n}\n","import CompoundAssignOpPatcher from './CompoundAssignOpPatcher.js';\n\nexport default class LogicalOpCompoundAssignOpPatcher extends CompoundAssignOpPatcher {\n  patchAsExpression() {\n    let operator = this.getOperatorToken();\n\n    // `a &&= b` → `a && b`\n    //    ^^^         ^^\n    this.overwrite(\n      operator.start,\n      operator.end,\n      this.isOrOp() ? `||` : `&&`\n    );\n\n    let assigneeAgain = this.assignee.makeRepeatable(false);\n    this.assignee.patch();\n\n    // `a && b` → `a && (a = b`\n    //                  ^^^^^\n    this.insert(this.expression.outerStart, `(${assigneeAgain} = `);\n\n    this.expression.patch();\n\n    // `a && (a = b` → `a && (a = b)`\n    //                             ^\n    this.insert(this.expression.outerEnd, ')');\n  }\n\n  patchAsStatement() {\n    // `a &&= b` → `if (a &&= b`\n    //              ^^^^\n    this.insert(this.contentStart, 'if (');\n\n    if (this.isOrOp()) {\n      this.assignee.negate();\n    }\n\n    let assigneeAgain = this.assignee.makeRepeatable(false);\n    this.assignee.patch();\n\n    // `if (a &&= b` → `if (a) { a = b`\n    //       ^^^^^           ^^^^^^^^\n    this.overwrite(this.assignee.outerEnd, this.expression.outerStart, `) { ${assigneeAgain} = `);\n    \n    this.expression.patch();\n\n    // `if (a) { a = b` → `if (a) { a = b }`\n    //                                   ^^\n    this.insert(this.expression.outerEnd, ' }');\n  }\n\n  /**\n   * @private\n   */\n  isOrOp(): boolean {\n    let operator = this.getOperatorToken();\n    let op = this.sourceOfToken(operator);\n    // There could be a space in the middle of the operator, like `or =` or\n    // `|| =`, and \"op\" will just be the first token in that case. So just check\n    // the start of the operator.\n    return op.substr(0, 2) === '||' || op.substr(0, 2) === 'or';\n  }\n\n  /**\n   * We always start with an `if` statement, so no parens.\n   */\n  statementNeedsParens(): boolean {\n    return false;\n  }\n}\n","import BinaryOpPatcher from './BinaryOpPatcher.js';\nimport NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Node, ParseContext, Editor } from './../../../patchers/types.js';\n\n/**\n * Handles logical AND and logical OR.\n *\n * This class is primarily responsible for rewriting `and` to `&&` and `or` to\n * `||`. It also applies De Morgan's laws [1] in the event of negation, such as\n * when used as the condition of an `unless` expression:\n *\n *   a unless b && c  # equivalent to `a if !b || !c`\n *\n * [1]: https://en.wikipedia.org/wiki/De_Morgan%27s_laws\n */\nexport default class LogicalOpPatcher extends BinaryOpPatcher {\n  negated: boolean = false;\n\n  /**\n   * `node` is expected to be either `LogicalAndOp` or `LogicalOrOp`.\n   */\n  constructor(node: Node, context: ParseContext, editor: Editor, left: NodePatcher, right: NodePatcher) {\n    super(node, context, editor);\n    this.left = left;\n    this.right = right;\n  }\n\n  patchOperator() {\n    let operatorToken = this.getOperatorToken();\n    this.overwrite(\n      operatorToken.start,\n      operatorToken.end,\n      this.getOperator()\n    );\n  }\n\n  /**\n   * Apply De Morgan's law.\n   *\n   * @private\n   */\n  getOperator(): string {\n    let operatorToken = this.getOperatorToken();\n    let operator = this.context.source.slice(\n      operatorToken.start,\n      operatorToken.end\n    );\n    if (operator === 'and') {\n      operator = '&&';\n    } else if (operator === 'or') {\n      operator = '||';\n    }\n    if (this.negated) {\n      return operator === '&&' ? '||' : '&&';\n    } else {\n      return operator;\n    }\n  }\n\n  negate() {\n    this.negated = !this.negated;\n    this.left.negate();\n    this.right.negate();\n  }\n}\n","import BinaryOpPatcher from './BinaryOpPatcher.js';\nimport type NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Editor, Node, ParseContext } from './../../../patchers/types.js';\n\nconst MOD_HELPER =\n  `function __mod__(a, b) {\n  a = +a;\n  b = +b;\n  return (a % b + b) % b;\n}`;\n\n/**\n * Handles modulo operator, e.g. `a %% b`.\n */\nexport default class ModuloOpPatcher extends BinaryOpPatcher {\n  /**\n   * `node` is of type `ModuloOp`.\n   */\n  constructor(node: Node, context: ParseContext, editor: Editor, left: NodePatcher, right: NodePatcher) {\n    super(node, context, editor, left, right);\n  }\n\n  patchAsExpression() {\n    let helper = this.registerHelper('__mod__', MOD_HELPER);\n\n    // `a %% b` → `__mod__(a %% b`\n    //             ^^^^^^^^\n    this.insert(this.left.outerStart, `${helper}(`);\n\n    this.left.patch();\n\n    // `__mod__(a %% b` → `__mod__(a, b`\n    //           ^^^^               ^^\n    this.overwrite(this.left.outerEnd, this.right.outerStart, ', ');\n\n    this.right.patch();\n\n    // `__mod__(a, b` → `__mod__(a, b)`\n    //                               ^\n    this.insert(this.right.outerEnd, ')');\n  }\n\n  /**\n   * We always prefix with `__mod__` so no parens needed.\n   */\n  statementNeedsParens(): boolean {\n    return false;\n  }\n}\n","import FunctionApplicationPatcher from './FunctionApplicationPatcher.js';\n\n/**\n * Handles construction of objects with `new`.\n */\nexport default class NewOpPatcher extends FunctionApplicationPatcher {}\n","import NegatableBinaryOpPatcher from './NegatableBinaryOpPatcher.js';\nimport type { SourceToken } from './../../../patchers/types.js';\nimport { RELATION } from 'coffee-lex';\n\n/**\n * Handles `of` operators, e.g. `a of b` and `a not of b`.\n */\nexport default class OfOpPatcher extends NegatableBinaryOpPatcher {\n  operatorTokenPredicate(): (token: SourceToken) => boolean {\n    return (token: SourceToken) => token.type === RELATION;\n  }\n\n  javaScriptOperator() {\n    return 'in';\n  }\n}\n","/* @flow */\n\n/**\n * Generates a blank object with no prototype.\n */\nexport default function blank(): Object {\n  return Object.create(null);\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport blank from '../../../utils/blank.js';\nimport determineIndent from '../../../utils/determineIndent.js';\nimport getIndent from '../../../utils/getIndent.js';\nimport { COMMENT, CONTINUATION, HERECOMMENT} from 'coffee-lex';\nimport type BlockPatcher from './BlockPatcher.js';\nimport type { Editor, Node, ParseContext, SourceToken } from './../../../patchers/types.js';\n\nconst BLOCK_COMMENT_DELIMITER = '###';\n\nexport default class ProgramPatcher extends NodePatcher {\n  body: ?BlockPatcher;\n  helpers: { [key: string]: string };\n  _indentString: ?string;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, body: ?BlockPatcher) {\n    super(node, context, editor);\n    this.body = body;\n\n    this.helpers = blank();\n    this._indentString = null;\n  }\n\n  shouldTrimContentRange() {\n    return true;\n  }\n\n  canPatchAsExpression(): boolean {\n    return false;\n  }\n\n  patchAsStatement() {\n    if (this.body) {\n      this.body.patch({ leftBrace: false, rightBrace: false });\n    }\n    this.patchContinuations();\n    this.patchComments();\n\n    for (let helper in this.helpers) {\n      this.editor.append(`\\n${this.helpers[helper]}`);\n    }\n  }\n\n  /**\n   * Removes continuation tokens (i.e. '\\' at the end of a line).\n   *\n   * @private\n   */\n  patchContinuations() {\n    this.getProgramSourceTokens().forEach(token => {\n      if (token.type === CONTINUATION) {\n        this.remove(token.start, token.end);\n      }\n    });\n  }\n\n  /**\n   * Replaces CoffeeScript style comments with JavaScript style comments.\n   *\n   * @private\n   */\n  patchComments() {\n    let { source } = this.context;\n    this.getProgramSourceTokens().forEach(token => {\n      if (token.type === COMMENT) {\n        if (token.start === 0 && source[1] === '!') {\n          this.patchShebangComment(token);\n        } else {\n          this.patchLineComment(token);\n        }\n      } else if (token.type === HERECOMMENT) {\n        this.patchBlockComment(token);\n      }\n    });\n  }\n\n  /**\n   * Patches a block comment.\n   *\n   * @private\n   */\n  patchBlockComment(comment: SourceToken) {\n    let { start, end } = comment;\n    this.overwrite(start, start + BLOCK_COMMENT_DELIMITER.length, '/*');\n\n    let atStartOfLine = false;\n    let lastStartOfLine = null;\n    let lineUpAsterisks = true;\n    let isMultiline = false;\n    let { source } = this.context;\n    let expectedIndent = getIndent(source, start);\n    let leadingHashIndexes = [];\n\n    for (let index = start + BLOCK_COMMENT_DELIMITER.length; index < end - BLOCK_COMMENT_DELIMITER.length; index++) {\n      switch (source[index]) {\n        case '\\n':\n          isMultiline = true;\n          atStartOfLine = true;\n          lastStartOfLine = index + '\\n'.length;\n          break;\n\n        case ' ':\n        case '\\t':\n          break;\n\n        case '#':\n          if (atStartOfLine) {\n            leadingHashIndexes.push(index);\n            atStartOfLine = false;\n            if (source.slice(lastStartOfLine, index) !== expectedIndent) {\n              lineUpAsterisks = false;\n            }\n          }\n          break;\n\n        default:\n          if (atStartOfLine) {\n            atStartOfLine = false;\n            lineUpAsterisks = false;\n          }\n          break;\n      }\n    }\n\n    leadingHashIndexes.forEach(index => {\n      this.overwrite(index, index + '#'.length, lineUpAsterisks ? ' *' : '*');\n    });\n\n    this.overwrite(end - BLOCK_COMMENT_DELIMITER.length, end, isMultiline && lineUpAsterisks ? ' */' : '*/');\n  }\n\n  /**\n   * Patches a single-line comment.\n   *\n   * @private\n   */\n  patchLineComment(comment: SourceToken) {\n    let { start } = comment;\n    this.overwrite(start, start + '#'.length, '//');\n  }\n\n  /**\n   * Patches a shebang comment.\n   *\n   * @private\n   */\n  patchShebangComment(comment: SourceToken) {\n    let { start, end } = comment;\n    let commentBody = this.slice(start, end);\n    let coffeeIndex = commentBody.indexOf('coffee');\n\n    if (coffeeIndex >= 0) {\n      this.overwrite(\n        start + coffeeIndex,\n        start + coffeeIndex + 'coffee'.length,\n        'node'\n      );\n    }\n  }\n\n  /**\n   * Register a helper to be reused in several places.\n   *\n   * FIXME: Pick a different name than what is in scope.\n   */\n  registerHelper(name: string, code: string): string {\n    code = code.trim();\n    if (name in this.helpers) {\n      if (this.helpers[name] !== code) {\n        throw new Error(`BUG: cannot override helper '${name}'`);\n      }\n    } else {\n      this.helpers[name] = code;\n    }\n    return name;\n  }\n\n  /**\n   * Gets the indent string used for each indent in this program.\n   */\n  getProgramIndentString(): string {\n    if (!this._indentString) {\n      this._indentString = determineIndent(this.context.source);\n    }\n    return this._indentString;\n  }\n\n  /**\n   * Serve as the implicit return patcher for anyone not included in a function.\n   */\n  implicitReturnPatcher(): NodePatcher {\n    return this;\n  }\n\n  /**\n   * Serve as the default for anyone not included in a function.\n   */\n  implicitReturnWillBreak(): boolean {\n    return true;\n  }\n}\n\n","import MemberAccessOpPatcher from './MemberAccessOpPatcher.js';\n\nexport default class ProtoMemberAccessOpPatcher extends MemberAccessOpPatcher {\n  patchAsExpression() {\n    this.expression.patch();\n    // `a::b` → `a.prototype.b`\n    //   ^^        ^^^^^^^^^^\n    let memberNameToken = this.getMemberNameSourceToken();\n    this.overwrite(this.expression.outerEnd, memberNameToken.start, '.prototype.');\n  }\n\n  hasImplicitOperator(): boolean {\n    return false;\n  }\n\n  getFullMemberName(): string {\n    return `prototype.${this.getMemberName()}`;\n  }\n}\n","import NodePatcher from '../../../patchers/NodePatcher.js';\n\n/**\n * Handles regexes and heregexes (e.g. `/\\.js$/` and `///a/b/c///`).\n */\nexport default class RegExpPatcher extends NodePatcher {\n  patchAsExpression() {\n    this.overwrite(this.contentStart, this.contentEnd, this.node.data);\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Editor, Node, ParseContext } from './../../../patchers/types.js';\n\n/**\n * Handles spread operations, e.g. `a(b...)` or `[a...]`.\n */\nexport default class SpreadPatcher extends NodePatcher {\n  expression: ?NodePatcher;\n  \n  constructor(node: Node, context: ParseContext, editor: Editor, expression: ?NodePatcher) {\n    super(node, context, editor);\n    this.expression = expression;\n  }\n\n  initialize() {\n    this.expression.setRequiresExpression();\n  }\n\n  /**\n   * All we have to do is move the `...` from the right to the left.\n   */\n  patchAsExpression() {\n    if (this.node.virtual) {\n      // i.e. the virtual spread in a bare `super` call.\n      return;\n    }\n\n    // `a...` → `...a...`\n    //           ^^^\n    this.insert(this.expression.outerStart, '...');\n    this.expression.patch();\n    // `...a...` → `...a`\n    //      ^^^\n    this.remove(this.expression.outerEnd, this.contentEnd);\n  }\n}\n","import SpreadPatcher from './SpreadPatcher.js';\n\nexport default class RestPatcher extends SpreadPatcher {}\n","import BinaryOpPatcher from './BinaryOpPatcher.js';\nimport { NEWLINE, SEMICOLON } from 'coffee-lex';\nimport type { SourceToken } from './../../../patchers/types.js';\n\n/**\n * Handles sequence expressions, e.g `a; b`.\n */\nexport default class SeqOpPatcher extends BinaryOpPatcher {\n  /**\n   * LEFT ';' RIGHT\n   */\n  patchAsExpression() {\n    this.left.patch();\n\n    let token = this.getOperatorToken();\n    \n    if (token.type === SEMICOLON) {\n      // `a; b` → `a, b`\n      //   ^        ^\n      this.overwrite(token.start, token.end, ',');\n    } else if (token.type === NEWLINE) {\n      this.insert(this.left.outerEnd, ',');\n    }\n\n    this.right.patch();\n  }\n\n  operatorTokenPredicate(): (token: SourceToken) => boolean {\n    return (token: SourceToken): boolean => token.type === SEMICOLON || token.type === NEWLINE;\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { SourceToken, Editor, Node, ParseContext } from './../../../patchers/types.js';\nimport { LBRACKET, RANGE, RBRACKET } from 'coffee-lex';\n\n/**\n * Handles array or string slicing, e.g. `names[i..]`.\n */\nexport default class SlicePatcher extends NodePatcher {\n  expression: NodePatcher;\n  left: ?NodePatcher;\n  right: ?NodePatcher;\n  \n  /**\n   * `node` is of type `Slice`.\n   */\n  constructor(node: Node, context: ParseContext, editor: Editor, expression: NodePatcher, left: ?NodePatcher, right: ?NodePatcher) {\n    super(node, context, editor);\n    this.expression = expression;\n    this.left = left;\n    this.right = right;\n  }\n\n  initialize() {\n    this.expression.setRequiresExpression();\n    if (this.left) {\n      this.left.setRequiresExpression();\n    }\n    if (this.right) {\n      this.right.setRequiresExpression();\n    }\n  }\n\n  /**\n   * EXPRESSION '[' LEFT? ( .. | ... ) RIGHT? ']'\n   */\n  patchAsExpression() {\n    this.expression.patch();\n    let indexStart = this.getIndexStartSourceToken();\n    // `a[0..1]` → `a.slice(0..1]`\n    //   ^           ^^^^^^^\n    this.overwrite(indexStart.start, indexStart.end, '.slice(');\n    if (this.left) {\n      this.left.patch();\n    } else if (this.right) {\n      // `a.slice(..1]` → `a.slice(0..1]`\n      //                           ^\n      this.insert(indexStart.end, '0');\n    }\n    let slice = this.getSliceSourceToken();\n    let inclusive = slice.end - slice.start === '..'.length;\n    let right = this.right;\n    if (right) {\n      if (inclusive) {\n        if (right.node.raw === '-1') {\n          this.remove(\n            slice.start,\n            right.outerEnd\n          );\n        } else if (right.node.type === 'Int') {\n          this.overwrite(\n            slice.start,\n            right.outerEnd,\n            `, ${right.node.data + 1}`\n          );\n        } else {\n          // `a.slice(0..1]` → `a.slice(0, 1]`\n          //           ^^                ^^\n          this.overwrite(slice.start, slice.end, ', ');\n          right.patch();\n          this.insert(right.outerEnd, ' + 1 || undefined');\n        }\n      } else {\n        // `a.slice(0..1]` → `a.slice(0, 1]`\n        //           ^^                ^^\n        this.overwrite(slice.start, slice.end, ', ');\n        right.patch();\n      }\n    } else {\n      // `a.slice(0..]` → `a.slice(0]`\n      //           ^^\n      this.overwrite(slice.start, slice.end, '');\n    }\n    let indexEnd = this.getIndexEndSourceToken();\n    // `a.slice(0, 1]` → `a.slice(0, 1)`\n    //              ^                 ^\n    this.overwrite(indexEnd.start, indexEnd.end, ')');\n  }\n\n  /**\n   * @private\n   */\n  getIndexStartSourceToken(): SourceToken {\n    let tokens = this.context.sourceTokens;\n    let index = tokens.indexOfTokenMatchingPredicate(\n      token => token.type === LBRACKET,\n      this.expression.outerEndTokenIndex\n    );\n    if (!index || index.isAfter(this.contentEndTokenIndex)) {\n      throw this.error(`could not find INDEX_START after slice expression`);\n    }\n    return tokens.tokenAtIndex(index);\n  }\n\n  /**\n   * @private\n   */\n  getSliceSourceToken(): SourceToken {\n    let tokens = this.context.sourceTokens;\n    let { source } = this.context;\n    let index = tokens.indexOfTokenMatchingPredicate(token => {\n      if (token.type !== RANGE) {\n        return false;\n      }\n      let operator = source.slice(token.start, token.end);\n      return operator === '...' || operator === '..';\n    }, this.left ? this.left.outerEndTokenIndex : this.expression.outerEndTokenIndex);\n    if (!index || index.isAfter(this.contentEndTokenIndex)) {\n      throw this.error(`could not find '..' or '...' in slice`);\n    }\n    return tokens.tokenAtIndex(index);\n  }\n\n  /**\n   * @private\n   */\n  getIndexEndSourceToken(): SourceToken {\n    let tokens = this.context.sourceTokens;\n    let index = tokens.lastIndexOfTokenMatchingPredicate(\n      token => token.type === RBRACKET,\n      this.outerEndTokenIndex\n    );\n    if (!index || index.isBefore(this.contentStartTokenIndex)) {\n      throw this.error(`could not find ']' ending slice`);\n    }\n    return tokens.tokenAtIndex(index);\n  }\n\n  /**\n   * If `BASE` needs parens then `BASE[0..1]` needs parens.\n   */\n  statementNeedsParens(): boolean {\n    return this.expression.statementShouldAddParens();\n  }\n}\n","import MemberAccessOpPatcher from './MemberAccessOpPatcher.js';\nimport findSoakContainer from '../../../utils/findSoakContainer.js';\n\nconst GUARD_HELPER =\n  `function __guard__(value, transform) {\n  return (typeof value !== 'undefined' && value !== null) ? transform(value) : undefined;\n}`;\n\nexport default class SoakedMemberAccessOpPatcher extends MemberAccessOpPatcher {\n  _shouldSkipSoakPatch: boolean;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, expression: NodePatcher) {\n    super(node, context, editor, expression);\n    this._shouldSkipSoakPatch = false;\n  }\n\n  patchAsExpression() {\n    if (!this._shouldSkipSoakPatch) {\n      this.registerHelper('__guard__', GUARD_HELPER);\n      let memberNameToken = this.getMemberNameSourceToken();\n      let soakContainer = findSoakContainer(this);\n      let varName = soakContainer.claimFreeBinding('x');\n      this.overwrite(this.expression.outerEnd, memberNameToken.start, `, ${varName} => ${varName}.`);\n      soakContainer.insert(soakContainer.contentStart, '__guard__(');\n      soakContainer.insert(soakContainer.contentEnd, ')');\n    }\n    this.expression.patch();\n  }\n\n  setShouldSkipSoakPatch() {\n    this._shouldSkipSoakPatch = true;\n  }\n\n  /**\n   * There isn't an implicit-dot syntax like @a for soaked access.\n   */\n  hasImplicitOperator(): boolean {\n    return false;\n  }\n}\n","import DynamicMemberAccessOpPatcher from './DynamicMemberAccessOpPatcher.js';\nimport FunctionApplicationPatcher from './FunctionApplicationPatcher.js';\nimport MemberAccessOpPatcher from './MemberAccessOpPatcher.js';\nimport SoakedDynamicMemberAccessOpPatcher from './SoakedDynamicMemberAccessOpPatcher.js';\nimport SoakedMemberAccessOpPatcher from './SoakedMemberAccessOpPatcher.js';\nimport findSoakContainer from '../../../utils/findSoakContainer.js';\nimport { CALL_START } from 'coffee-lex';\n\nconst GUARD_FUNC_HELPER =\n  `function __guardFunc__(func, transform) {\n  return typeof func === 'function' ? transform(func) : undefined;\n}`;\n\n/**\n * Special guard function so that the calling code can properly specify the\n * proper `this` value in the call.\n *\n * Note that this method is slightly incorrect in that it's more defensive than\n * `a.b?()`; it does a null check on `a`, when CoffeeScript code would crash on\n * null/undefined `a`. This may be possible to correct in the future, but there\n * are a few reasons it's useful in the current implementation:\n * - The implementation of soak chaining requires that soak operations do\n *   nothing if their leftmost value is undefined, e.g. that `a?.b?.c` can be\n *   correctly rewritten as `(a?.b)?.c`. Soaked method-style function\n *   application is a counterexample, though: `a?.b.c?()` cannot be rewritten as\n *   `(a?.b).c?()`, since the second one crashes if `a` is null. So, instead, we\n *   effectively treat it as `(a?.b)?.c?()`, which again isn't 100% correct, but\n *   will properly guard on `a` being null/undefined.\n * - We'd need a function like this anyway to transform code like `a?.b?()`, so\n *   this avoids the need to have two slightly different functions to handle\n *   this case which is already fairly obscure.\n */\nconst GUARD_METHOD_HELPER =\n  `function __guardMethod__(obj, methodName, transform) {\n  if (typeof obj !== 'undefined' && obj !== null && typeof obj[methodName] === 'function') {\n    return transform(obj, methodName);\n  } else {\n    return undefined;\n  }\n}`;\n\nexport default class SoakedFunctionApplicationPatcher extends FunctionApplicationPatcher {\n  patchAsExpression() {\n    if (this.fn instanceof MemberAccessOpPatcher) {\n      this.patchMethodCall(this.fn);\n    } else if (this.fn instanceof DynamicMemberAccessOpPatcher) {\n      this.patchDynamicMethodCall(this.fn);\n    } else {\n      this.patchNonMethodCall();\n    }\n    super.patchAsExpression();\n  }\n\n  /**\n   * Change a.b?() to __guardMethod__(a, 'b', o => o.b())\n   */\n  patchMethodCall(fn: MemberAccessOpPatcher) {\n    let memberName = fn.getMemberName();\n    if (fn.hasImplicitOperator()) {\n      fn.setSkipImplicitDotCreation();\n    }\n\n    this.registerHelper('__guardMethod__', GUARD_METHOD_HELPER);\n    if (fn instanceof SoakedMemberAccessOpPatcher) {\n      fn.setShouldSkipSoakPatch();\n    }\n\n    let callStartToken = this.getCallStartToken();\n    let soakContainer = findSoakContainer(this);\n    let varName = soakContainer.claimFreeBinding('o');\n    // Since memberName is always a valid identifier, we can put it in a string\n    // literal without worrying about escaping.\n    this.overwrite(fn.expression.outerEnd, callStartToken.end,\n      `, '${memberName}', ${varName} => ${varName}.${memberName}(`);\n    soakContainer.insert(soakContainer.contentStart, '__guardMethod__(');\n    soakContainer.insert(soakContainer.contentEnd, ')');\n  }\n\n  /**\n   * Change a[b]?() to __guardMethod__(a, b, (o, m) => o[m]())\n   */\n  patchDynamicMethodCall(fn: DynamicMemberAccessOpPatcher) {\n    let {expression, indexingExpr} = fn;\n\n    this.registerHelper('__guardMethod__', GUARD_METHOD_HELPER);\n    if (fn instanceof SoakedDynamicMemberAccessOpPatcher) {\n      fn.setShouldSkipSoakPatch();\n    }\n\n    let callStartToken = this.getCallStartToken();\n    let soakContainer = findSoakContainer(this);\n    let objVarName = soakContainer.claimFreeBinding('o');\n    let methodVarName = soakContainer.claimFreeBinding('m');\n    this.overwrite(expression.outerEnd, indexingExpr.outerStart, `, `);\n    this.overwrite(indexingExpr.outerEnd, callStartToken.end,\n      `, (${objVarName}, ${methodVarName}) => ${objVarName}[${methodVarName}](`);\n    soakContainer.insert(soakContainer.contentStart, '__guardMethod__(');\n    soakContainer.insert(soakContainer.contentEnd, ')');\n  }\n\n  patchNonMethodCall() {\n    this.registerHelper('__guardFunc__', GUARD_FUNC_HELPER);\n    let callStartToken = this.getCallStartToken();\n    let soakContainer = findSoakContainer(this);\n    let varName = soakContainer.claimFreeBinding('f');\n    this.overwrite(this.fn.outerEnd, callStartToken.end, `, ${varName} => ${varName}(`);\n    soakContainer.insert(soakContainer.contentStart, '__guardFunc__(');\n    soakContainer.insert(soakContainer.contentEnd, ')');\n  }\n\n  getCallStartToken(): SourceToken {\n    let tokens = this.context.sourceTokens;\n    let index = tokens.indexOfTokenMatchingPredicate(\n      token => token.type === CALL_START,\n      this.fn.outerEndTokenIndex\n    );\n    if (!index || index.isAfter(this.contentEndTokenIndex)) {\n      throw this.error(`unable to find open-paren for function call`);\n    }\n    return tokens.tokenAtIndex(index);\n  }\n}\n","/* @flow */\nimport AssignOpPatcher from '../stages/main/patchers/AssignOpPatcher.js';\nimport FunctionApplicationPatcher from '../stages/main/patchers/FunctionApplicationPatcher.js';\nimport MemberAccessOpPatcher from '../stages/main/patchers/MemberAccessOpPatcher.js';\nimport DynamicMemberAccessOpPatcher from '../stages/main/patchers/DynamicMemberAccessOpPatcher.js';\nimport SoakedDynamicMemberAccessOpPatcher from '../stages/main/patchers/SoakedDynamicMemberAccessOpPatcher.js';\nimport SoakedFunctionApplicationPatcher from '../stages/main/patchers/SoakedFunctionApplicationPatcher.js';\nimport SoakedMemberAccessOpPatcher from '../stages/main/patchers/SoakedMemberAccessOpPatcher.js';\n\nimport type NodePatcher from '../patchers/NodePatcher.js';\n\n/**\n * Find the enclosing node defining the \"soak range\" for a given soak operation.\n * For example, in the expression `a(b?.c.d())`, returns the `b?.c.d()` node,\n * since that's the chain of operations that will be skipped if `b` is null or\n * undefined.\n */\nexport default function findSoakContainer(patcher: NodePatcher): NodePatcher {\n  let result = patcher;\n  while (canParentHandleSoak(result)) {\n    result = result.parent;\n  }\n  return result;\n}\n\n/**\n * Determine if this \"soak range\" can be expanded outward.\n *\n * In determining the soak range, we also stop when we see other soak\n * operations. For example, in `a?.b?.c`, `a?.b` is used as the soak container\n * for the first soak, which works because the second soak operation will\n * \"take over\"; if `a` is null or undefined, then `a?.b` will be undefined, so\n * the entire thing will evaluate to undefined. This requires all soak\n * operations to do a null check on their leftmost value, which is why we need\n * to make __guardMethod__ do a null check on the object arg.\n */\nfunction canParentHandleSoak(patcher: NodePatcher): boolean {\n  if (patcher.parent === null) {\n    return false;\n  }\n  if (patcher.isSurroundedByParentheses()) {\n    return false;\n  }\n  // If we are currently the `a?.b` in an expression like `a?.b.c?()`, we don't\n  // want to expand any further, since method-style soaked function application\n  // is a special case and the `.c?(` will be patched. In this case, the `a?.b`\n  // is what we should set as our soak container, since the method-style soak\n  // implementation will \"take over\" from that point.\n  if ((patcher.parent instanceof MemberAccessOpPatcher\n        || patcher.parent instanceof DynamicMemberAccessOpPatcher)\n      && patcher.parent.parent !== null\n      && patcher.parent.parent instanceof SoakedFunctionApplicationPatcher\n      && patcher.parent.parent.fn === patcher.parent) {\n    return false;\n  }\n  if (patcher.parent instanceof MemberAccessOpPatcher\n      && !(patcher.parent instanceof SoakedMemberAccessOpPatcher)) {\n    return true;\n  }\n  if (patcher.parent instanceof DynamicMemberAccessOpPatcher\n      && !(patcher.parent instanceof SoakedDynamicMemberAccessOpPatcher)\n      && patcher.parent.expression === patcher) {\n    return true;\n  }\n  if (patcher.parent instanceof FunctionApplicationPatcher\n      && !(patcher.parent instanceof SoakedFunctionApplicationPatcher)\n      && patcher.parent.fn === patcher) {\n    return true;\n  }\n  if (patcher.parent instanceof AssignOpPatcher\n      && patcher.parent.assignee === patcher) {\n    return true;\n  }\n  if (['PostIncrementOp', 'PostDecrementOp'].indexOf(patcher.parent.node.type) >= 0) {\n    return true;\n  }\n  if (['PreIncrementOp', 'PreDecrementOp', 'DeleteOp'].indexOf(patcher.parent.node.type) >= 0) {\n    throw patcher.parent.error(\n      'Expressions like `++a?.b`, `--a?.b`, and `delete a?.b` are not supported yet.'\n    );\n  }\n  return false;\n}\n","import DynamicMemberAccessOpPatcher from './DynamicMemberAccessOpPatcher.js';\nimport findSoakContainer from '../../../utils/findSoakContainer.js';\n\nconst GUARD_HELPER =\n  `function __guard__(value, transform) {\n  return (typeof value !== 'undefined' && value !== null) ? transform(value) : undefined;\n}`;\n\nexport default class SoakedDynamicMemberAccessOpPatcher extends DynamicMemberAccessOpPatcher {\n  _shouldSkipSoakPatch: boolean;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, expression: NodePatcher, indexingExpr: NodePatcher) {\n    super(node, context, editor, expression, indexingExpr);\n    this._shouldSkipSoakPatch = false;\n  }\n\n  patchAsExpression() {\n    if (!this._shouldSkipSoakPatch) {\n      this.registerHelper('__guard__', GUARD_HELPER);\n      let soakContainer = findSoakContainer(this);\n      let varName = soakContainer.claimFreeBinding('x');\n      this.overwrite(this.expression.outerEnd, this.indexingExpr.outerStart, `, ${varName} => ${varName}[`);\n      soakContainer.insert(soakContainer.contentStart, '__guard__(');\n      soakContainer.insert(soakContainer.contentEnd, ')');\n    }\n\n    this.expression.patch();\n    this.indexingExpr.patch();\n  }\n\n  setShouldSkipSoakPatch() {\n    this._shouldSkipSoakPatch = true;\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport ClassAssignOpPatcher from './ClassAssignOpPatcher.js';\nimport ConstructorPatcher from './ConstructorPatcher.js';\n\nexport default class SuperPatcher extends NodePatcher {\n  patchAsExpression() {\n    let name = this.getContainingMethodName();\n    if (name) {\n      this.insert(this.contentEnd, `.${name}`);\n    }\n  }\n\n  /**\n   * @private\n   */\n  getContainingMethodName(): ?string {\n    let { parent } = this;\n    while (parent) {\n      if (parent instanceof ConstructorPatcher) {\n        return null;\n      } else if (parent instanceof ClassAssignOpPatcher) {\n        if (parent.isStaticMethod()) {\n          return parent.key.node.memberName;\n        } else {\n          return parent.key.node.data;\n        }\n      }\n      parent = parent.parent;\n    }\n    throw this.error(`no containing method found for 'super'`);\n  }\n}\n","import NodePatcher from '../../../patchers/NodePatcher.js';\nimport type { Editor, Node, ParseContext, SourceToken } from '../../../patchers/types.js';\nimport { BREAK, COMMA, THEN, WHEN } from 'coffee-lex';\n\nexport default class SwitchCasePatcher extends NodePatcher {\n  conditions: Array<NodePatcher>;\n  consequent: ?NodePatcher;\n\n  negated: boolean;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, conditions: Array<NodePatcher>, consequent: NodePatcher) {\n    super(node, context, editor);\n    this.conditions = conditions;\n    this.consequent = consequent;\n    this.negated = false;\n  }\n\n  initialize() {\n    this.conditions.forEach(condition => condition.setRequiresExpression());\n  }\n\n  patchAsStatement() {\n    // `when a, b, c then d` → `a, b, c then d`\n    //  ^^^^^\n    let whenToken = this.getWhenToken();\n    this.remove(whenToken.start, this.conditions[0].contentStart);\n\n    // `a, b, c then d` → `a b c then d`\n    //   ^  ^\n    this.getCommaTokens().forEach(comma => {\n      this.remove(comma.start, comma.end);\n    });\n\n    this.conditions.forEach(condition => {\n      // `a b c then d` → `case a: case b: case c: then d`\n      //                   ^^^^^ ^^^^^^^ ^^^^^^^ ^\n      this.insert(condition.outerStart, 'case ');\n      if (this.negated) {\n        condition.negate();\n      }\n      condition.patch({ leftBrace: false, rightBrace: false });\n      this.insert(condition.outerEnd, ':');\n    });\n\n\n    // `case a: case b: case c: then d → `case a: case b: case c: d`\n    //                          ^^^^^\n    let thenToken = this.getThenToken();\n    if (thenToken) {\n      if (this.consequent !== null) {\n        this.remove(thenToken.start, this.consequent.contentStart);\n      } else {\n        this.remove(thenToken.start, thenToken.end);\n      }\n    }\n\n    if (this.consequent !== null) {\n      this.consequent.patch({ leftBrace: false, rightBrace: false });\n    }\n\n    let hasBreak = this.getBreakToken() !== null;\n    let implicitReturnWillBreak = (\n      this.implicitlyReturns() &&\n      this.implicitReturnWillBreak() &&\n      (!this.consequent || this.consequent.allCodePathsPresent())\n    );\n    let shouldAddBreak = !hasBreak && !implicitReturnWillBreak;\n    if (shouldAddBreak) {\n      if (thenToken) {\n        // `case a: case b: case c: then d → `case a: case b: case c: d break`\n        //                                                             ^^^^^^\n        if (this.consequent !== null) {\n          this.insert(this.consequent.contentEnd, ' break');\n        } else {\n          this.insert(thenToken.end, ' break');\n        }\n      } else {\n        this.appendLineAfter('break', 1);\n      }\n    }\n  }\n\n  setImplicitlyReturns() {\n    super.setImplicitlyReturns();\n    if (this.consequent !== null) {\n      this.consequent.setImplicitlyReturns();\n    }\n  }\n\n  patchAsExpression() {\n    this.patchAsStatement();\n  }\n\n  /**\n   * Don't actually negate the conditions until just before patching, since\n   * otherwise we might accidentally overwrite a ! character that gets inserted.\n   */\n  negate() {\n    this.negated = !this.negated;\n  }\n\n  /**\n   * @private\n   */\n  getWhenToken(): SourceToken {\n    let whenToken = this.sourceTokenAtIndex(this.contentStartTokenIndex);\n    if (!whenToken) {\n      throw this.error(`bad token index for start of 'when'`);\n    }\n    if (whenToken.type !== WHEN) {\n      throw this.error(`unexpected ${whenToken.type.name} at start of 'switch' case`);\n    }\n    return whenToken;\n  }\n\n  /**\n   * @private\n   */\n  getCommaTokens(): Array<SourceToken> {\n    let result = [];\n    for (let i = 1; i < this.conditions.length; i++) {\n      let left = this.conditions[i - 1];\n      let right = this.conditions[i];\n      let commaIndex = this.indexOfSourceTokenBetweenPatchersMatching(\n        left, right, token => token.type === COMMA\n      );\n      if (!commaIndex) {\n        throw this.error(\n          `unable to find comma between 'when' conditions`,\n          left.contentEnd,\n          right.contentStart\n        );\n      }\n      result.push(this.sourceTokenAtIndex(commaIndex));\n    }\n    return result;\n  }\n\n  /**\n   * @private\n   */\n  getBreakToken(): ?SourceToken {\n    let lastToken = this.sourceTokenAtIndex(this.contentEndTokenIndex);\n    if (lastToken && lastToken.type === BREAK) {\n      return lastToken;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Gets the token representing the `then` between condition and consequent.\n   *\n   * @private\n   */\n  getThenToken(): ?SourceToken {\n    let thenTokenIndex = this.indexOfSourceTokenBetweenSourceIndicesMatching(\n      this.conditions[0].outerEnd,\n      this.consequent !== null ? this.consequent.outerStart : this.contentEnd,\n      token => token.type === THEN\n    );\n    return thenTokenIndex ? this.sourceTokenAtIndex(thenTokenIndex) : null;\n  }\n}\n","import NodePatcher from '../../../patchers/NodePatcher.js';\nimport type { Editor, Node, ParseContext, SourceToken } from '../../../patchers/types.js';\nimport { ELSE, SWITCH } from 'coffee-lex';\n\nexport default class SwitchPatcher extends NodePatcher {\n  expression: NodePatcher;\n  cases: Array<NodePatcher>;\n  alternate: ?NodePatcher;\n  \n  constructor(node: Node, context: ParseContext, editor: Editor, expression: NodePatcher, cases: Array<NodePatcher>, alternate: ?NodePatcher) {\n    super(node, context, editor);\n    this.expression = expression;\n    this.cases = cases;\n    this.alternate = alternate;\n  }\n\n  patchAsStatement() {\n    if (this.expression) {\n      // `switch a` → `switch (a`\n      //                      ^\n      if (!this.expression.isSurroundedByParentheses()) {\n        this.insert(this.expression.contentStart, '(');\n      }\n\n      this.expression.patch();\n\n      // `switch (a` → `switch (a)`\n      //                         ^\n      if (!this.expression.isSurroundedByParentheses()) {\n        this.insert(this.expression.contentEnd, ')');\n      }\n\n      // `switch (a)` → `switch (a) {`\n      //                            ^\n      this.insert(this.expression.outerEnd, ' {');\n    } else {\n      this.cases.forEach(casePatcher => casePatcher.negate());\n\n      // `switch` → `switch (false) {`\n      //                   ^^^^^^^^^^\n      let switchToken = this.getSwitchToken();\n      this.insert(switchToken.end, ' (false) {');\n    }\n\n    this.cases.forEach(casePatcher => casePatcher.patch());\n\n    this.overwriteElse();\n    if (this.alternate) {\n      this.alternate.patch({ leftBrace: false, rightBrace: false });\n    }\n\n    this.appendLineAfter('}');\n  }\n\n  setImplicitlyReturns() {\n    this.cases.forEach(casePatcher => casePatcher.setImplicitlyReturns());\n    if (this.alternate) {\n      this.alternate.setImplicitlyReturns();\n    }\n  }\n\n  patchAsExpression() {\n    this.setImplicitlyReturns();\n\n    // `` → `(() => { `\n    //       ^^^^^^^^^\n    this.insert(this.contentStart, '(() => { ');\n    this.patchAsStatement();\n\n    // `` → ` })()`\n    //       ^^^^^\n    this.appendToEndOfLine(' })()');\n  }\n\n  /**\n   * @private\n   */\n  overwriteElse() {\n    // `else` → `default:`\n    //           ^^^^^^^^\n    let elseToken = this.getElseToken();\n    if (elseToken) {\n      this.overwrite(elseToken.start, elseToken.end, 'default:');\n    }\n  }\n\n  /**\n   * @private\n   */\n  getElseToken(): ?SourceToken {\n    if (!this.alternate) {\n      return null;\n    }\n\n    let tokens = this.context.sourceTokens;\n    let elseTokenIndex = tokens.lastIndexOfTokenMatchingPredicate(\n      token => token.type === ELSE,\n      this.alternate.contentStartTokenIndex\n    );\n    if (!elseTokenIndex || elseTokenIndex.isBefore(this.contentStartTokenIndex)) {\n      throw this.alternate.error(`no ELSE token found before 'switch' alternate`);\n    }\n    return this.sourceTokenAtIndex(elseTokenIndex);\n  }\n\n  /**\n   * @private\n   */\n  getSwitchToken(): SourceToken {\n    let switchToken = this.sourceTokenAtIndex(this.contentStartTokenIndex);\n    if (!switchToken) {\n      throw this.error(`bad token index for start of 'switch'`);\n    }\n    if (switchToken.type !== SWITCH) {\n      throw this.error(`unexpected ${switchToken.type.name} token at start of 'switch'`);\n    }\n    return switchToken;\n  }\n\n  /**\n   * Switch statements with all code paths present have a `default` case and\n   * each case has all of its code paths covered.\n   */\n  allCodePathsPresent(): boolean {\n    if (!this.alternate) {\n      return false;\n    }\n    \n    return (\n      this.cases.every(switchCase => switchCase.allCodePathsPresent()) &&\n      this.alternate.allCodePathsPresent()\n    );\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Node, ParseContext, Editor } from './../../../patchers/types.js';\nimport { THROW } from 'coffee-lex';\n\nexport default class ThrowPatcher extends NodePatcher {\n  expression: NodePatcher;\n  \n  constructor(node: Node, context: ParseContext, editor: Editor, expression: NodePatcher) {\n    super(node, context, editor);\n    this.expression = expression;\n  }\n\n  /**\n   * Throw in JavaScript is a statement only, so we'd prefer it stay that way.\n   */\n  prefersToPatchAsExpression(): boolean {\n    return false;\n  }\n\n  /**\n   * Throw statements that are in the implicit return position should simply\n   * be left alone as they're pure statements in JS and don't have a value.\n   */\n  setImplicitlyReturns() {\n    // throw can't be an implicit return\n  }\n\n  /**\n   * `throw` statements cannot normally be used as expressions, so we wrap them\n   * in an arrow function IIFE.\n   */\n  patchAsExpression() {\n    let hasParens = this.isSurroundedByParentheses();\n    if (!hasParens) {\n      // `throw err` → `(throw err`\n      //                ^\n      this.insert(this.outerStart, '(');\n    }\n    // `(throw err` → `(() => { throw err`\n    //                  ^^^^^^^^\n    this.insert(this.innerStart, '() => { ');\n    this.patchAsStatement();\n    // `(() => { throw err` → `(() => { throw err }`\n    //                                           ^^\n    this.insert(this.innerEnd, ' }');\n    if (!hasParens) {\n      // `(() => { throw err }` → `(() => { throw err })`\n      //                                               ^\n      this.insert(this.outerEnd, ')');\n    }\n    // `(() => { throw err })` → `(() => { throw err })()`\n    //                                                 ^^\n    this.insert(this.outerEnd, '()');\n  }\n\n  patchAsStatement() {\n    let throwToken = this.sourceTokenAtIndex(this.contentStartTokenIndex);\n    if (throwToken.type !== THROW) {\n      this.error('Expected to find throw token at the start of throw statement.');\n    }\n    let spacing = this.slice(throwToken.end, this.expression.outerStart);\n    if (spacing.indexOf('\\n') !== -1) {\n      this.overwrite(throwToken.end, this.expression.outerStart, ' ');\n    }\n    this.expression.patch();\n  }\n\n  /**\n   * This is here so that we can add the `()` outside any existing parens.\n   */\n  allowPatchingOuterBounds(): boolean {\n    return true;\n  }\n}\n","/* @flow */\n\nfunction nativeFind<T>(array: Array<T>, iterator: (element: T, i: number, array: Array<T>) => boolean, context: any): ?T {\n  return array.find(iterator, context);\n}\n\nfunction find<T>(array: Array<T>, iterator: (element: T, i: number, array: Array<T>) => boolean, context: any): ?T {\n  for (let i = 0; i < array.length; i++) {\n    let element = array[i];\n    if (iterator.call(context, element, i, array)) {\n      return element;\n    }\n  }\n  return undefined;\n}\n\nexport default Array.prototype.find ? nativeFind : find;\n","/* @flow */\n\n/**\n * Maps a list to another list by combining lists.\n */\nexport default function flatMap<T, U>(list: Array<T>, map: (element: T) => Array<U>): Array<U> {\n  return list.reduce((memo, item) => memo.concat(map(item)), []);\n}\n","/* @flow */\n\nimport flatMap from './flatMap.js';\nimport type Node from '../patchers/types.js';\n\n/**\n * Gets the identifiers for the given LHS value.\n *\n * @example\n *\n *   Given `a`, returns [`a`].\n *   Given `[a, b]`, returns [`a`, `b`].\n *   Given `{a, b: c}`, returns [`a`, `c`].\n *   Given `[a, {b, c: d}]`, returns [`a`, `b`, `d`].\n */\nexport default function leftHandIdentifiers(node: Node): Array<Node> {\n  if (node.type === 'Identifier') {\n    return [node];\n  } else if (node.type === 'ArrayInitialiser') {\n    return flatMap(node.members, leftHandIdentifiers);\n  } else if (node.type === 'ObjectInitialiser') {\n    return flatMap(node.members, member => leftHandIdentifiers(member.expression));\n  } else {\n    return [];\n  }\n}\n","/* @flow */\n\nimport find from './array/find.js';\nimport flatMap from './flatMap.js';\nimport leftHandIdentifiers from './leftHandIdentifiers.js';\nimport type { Node } from '../patchers/types.js';\n\ntype Bindings = { [key: string]: Node };\n\n/**\n * Represents a CoffeeScript scope and its bindings.\n */\nexport default class Scope {\n  parent: ?Scope;\n  bindings: Bindings;\n\n  constructor(parent: ?Scope=null) {\n    this.parent = parent;\n    this.bindings = Object.create(parent ? parent.bindings : null);\n  }\n\n  getBinding(name: string): ?Node {\n    return this.bindings[this.key(name)] || null;\n  }\n\n  hasBinding(name: string): boolean {\n    return this.getBinding(name) !== null;\n  }\n\n  getOwnNames(): Array<string> {\n    return Object.getOwnPropertyNames(this.bindings).map(key => this.unkey(key));\n  }\n\n  declares(name: string, node: Node) {\n    let key = this.key(name);\n    this.bindings[key] = node;\n  }\n\n  assigns(name: string, node: Node) {\n    if (!this.bindings[this.key(name)]) {\n      // Not defined in this or any parent scope.\n      this.declares(name, node);\n    }\n  }\n\n  claimFreeBinding(node: Node, name: ?(string | Array<string>)=null): string {\n    if (!name) { name = 'ref'; }\n    let names = Array.isArray(name) ? name : [name];\n    let binding = find(names, name => !this.getBinding(name));\n\n    if (!binding) {\n      let counter = 0;\n      while (!binding) {\n        counter += 1;\n        binding = find(names, name => !this.getBinding(`${name}${counter}`));\n      }\n      binding = `${binding}${counter}`;\n    }\n\n    this.declares(binding, node);\n    return binding;\n  }\n\n  /**\n   * @private\n   */\n  key(name: string): string {\n    return `$${name}`;\n  }\n\n  /**\n   * @private\n   */\n  unkey(key: string): string {\n    return key.slice(1);\n  }\n\n  /**\n   * Handles declarations or assigns for any bindings for a given node.\n   */\n  processNode(node: Node) {\n    switch (node.type) {\n      case 'AssignOp':\n        leftHandIdentifiers(node.assignee).forEach(identifier =>\n          this.assigns(identifier.data, identifier)\n        );\n        break;\n\n      case 'Function':\n      case 'BoundFunction':\n      case 'GeneratorFunction':\n        getBindingsForNode(node).forEach(identifier => this.declares(identifier.data, identifier));\n        break;\n\n      case 'ForIn':\n      case 'ForOf':\n        [node.keyAssignee, node.valAssignee].forEach(assignee => {\n          if (assignee) {\n            leftHandIdentifiers(assignee).forEach(identifier =>\n              this.assigns(identifier.data, identifier)\n            );\n          }\n        });\n        break;\n    }\n  }\n\n  toString(): string {\n    let parts = this.getOwnNames();\n    if (this.parent) {\n      parts.push(`parent = ${this.parent.toString()}`);\n    }\n    return `${this.constructor.name} {${parts.length > 0 ? ` ${parts.join(', ')} ` : ''}}`;\n  }\n\n  inspect(): string {\n    return this.toString();\n  }\n}\n\n/**\n * Gets all the identifiers representing bindings in `node`.\n */\nfunction getBindingsForNode(node: Node): Array<Node> {\n  switch (node.type) {\n    case 'Function':\n    case 'GeneratorFunction':\n    case 'BoundFunction':\n      return flatMap(node.parameters, getBindingsForNode);\n\n    case 'Identifier':\n    case 'ArrayInitialiser':\n    case 'ObjectInitialiser':\n      return leftHandIdentifiers(node);\n\n    case 'DefaultParam':\n      return getBindingsForNode(node.param);\n\n    case 'Rest':\n      return getBindingsForNode(node.expression);\n\n    case 'Expansion':\n    case 'MemberAccessOp':\n      return [];\n\n    default:\n      throw new Error(`unexpected parameter type: ${node.type}`);\n  }\n}\n","/* @flow */\n\nimport Scope from './Scope.js';\nimport traverse from './traverse.js';\nimport type { Node } from '../patchers/types.js';\nimport { parse as decaffeinateParse } from 'decaffeinate-parser';\n\n/**\n * Parses a CoffeeScript program and attaches scope information to the nodes.\n */\nexport default function parse(source: string): Node {\n  let ast = decaffeinateParse(source);\n  traverse(ast, attachScope);\n  return ast;\n}\n\nfunction attachScope(node: Node) {\n  switch (node.type) {\n    case 'Program':\n      node.scope = new Scope();\n      break;\n\n    case 'Function':\n    case 'BoundFunction':\n    case 'GeneratorFunction':\n      node.scope = new Scope(node.parentNode.scope);\n      break;\n\n    default:\n      node.scope = node.parentNode.scope;\n      break;\n  }\n\n  node.scope.processNode(node);\n}\n","import MagicString from 'magic-string';\nimport NodePatcher from '../patchers/NodePatcher.js';\nimport PatchError from '../utils/PatchError.js';\nimport parse from '../utils/parse.js';\nimport type { Node, ParseContext, Editor } from '../patchers/types.js';\nimport { basename } from 'path';\nimport { childPropertyNames } from '../utils/traverse.js';\nimport { logger } from '../utils/debug.js';\n\nexport default class TransformCoffeeScriptStage {\n  static run(content: string, filename: string): { code: string, map: Object } {\n    let log = logger(this.name);\n    log(content);\n\n    let ast = parse(content);\n    let editor = new MagicString(content);\n    let stage = new this(ast, ast.context, editor);\n    let patcher = stage.build();\n    patcher.patch();\n    return {\n      code: editor.toString(),\n      map: editor.generateMap({\n        source: filename,\n        file: `${basename(filename, this.inputExtension)}-${this.name}${this.outputExtension}`,\n        includeContent: true\n      })\n    };\n  }\n\n  static get inputExtension() {\n    return '.coffee';\n  }\n\n  static get outputExtension() {\n    return '.js';\n  }\n\n  constructor(ast: Node, context: ParseContext, editor: Editor) {\n    this.ast = ast;\n    this.context = context;\n    this.editor = editor;\n    this.root = null;\n    this.patchers = [];\n  }\n\n  /**\n   * This should be overridden in subclasses.\n   */\n  patcherConstructorForNode(node: Node): ?Class<NodePatcher> { // eslint-disable-line no-unused-vars\n    return null;\n  }\n\n  build(): NodePatcher {\n    this.root = this.patcherForNode(this.ast);\n    this.patchers.forEach(patcher => patcher.initialize());\n    return this.root;\n  }\n\n  patcherForNode(node: Node, parent: ?Class<NodePatcher>=null, property: ?string=null): NodePatcher {\n    let constructor = this._patcherConstructorForNode(node);\n\n    if (parent) {\n      let override = parent.patcherClassForChildNode(node, property);\n      if (override) {\n        constructor = override;\n      }\n    }\n\n    let children = childPropertyNames(node).map(name => {\n      let child = node[name];\n      if (!child) {\n        return null;\n      } else if (Array.isArray(child)) {\n        return child.map(item =>\n          this.patcherForNode(item, constructor, name)\n        );\n      } else {\n        return this.patcherForNode(child, constructor, name);\n      }\n    });\n\n    let patcher = new constructor(node, this.context, this.editor, ...children);\n    this.patchers.push(patcher);\n    this.associateParent(patcher, children);\n\n    return patcher;\n  }\n\n  associateParent(parent, child) {\n    if (Array.isArray(child)) {\n      child.forEach(item => this.associateParent(parent, item));\n    } else if (child) {\n      child.parent = parent;\n    }\n  }\n\n  _patcherConstructorForNode(node: Node): Class<NodePatcher> {\n    let constructor = this.patcherConstructorForNode(node);\n\n    if (constructor === null) {\n      let props = childPropertyNames(node);\n      throw new PatchError(\n        `no patcher available for node type: ${node.type}` +\n        `${props.length ? ` (props: ${props.join(', ')})` : ''}`,\n        this.context.source,\n        ...node.range\n      );\n    }\n\n    return constructor.patcherClassOverrideForNode(node) || constructor;\n  }\n}\n","import NodePatcher from '../../../patchers/NodePatcher.js';\nimport type BlockPatcher from './BlockPatcher.js';\nimport type { Node, ParseContext, Editor, SourceToken, SourceTokenListIndex } from '../../../patchers/types.js';\nimport { CATCH, FINALLY, THEN, TRY } from 'coffee-lex';\n\n/**\n * Handles `try` statements, e.g. `try a catch e then console.log(e)`.\n */\nexport default class TryPatcher extends NodePatcher {\n  body: BlockPatcher;\n  catchAssignee: ?NodePatcher;\n  catchBody: ?BlockPatcher;\n  finallyBody: ?BlockPatcher;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, body: BlockPatcher, catchAssignee: ?NodePatcher, catchBody: ?BlockPatcher, finallyBody: ?BlockPatcher) {\n    super(node, context, editor);\n    this.body = body;\n    this.catchAssignee = catchAssignee;\n    this.catchBody = catchBody;\n    this.finallyBody = finallyBody;\n  }\n  \n  initialize() {\n    if (this.catchAssignee) {\n      this.catchAssignee.setRequiresExpression();\n    }\n  }\n\n  /**\n   * 'try' BODY ( 'catch' ASSIGNEE? CATCH-BODY? )? ( 'finally' FINALLY-BODY )?\n   */\n  patchAsStatement() {\n    let tryToken = this.getTryToken();\n    let catchToken = this.getCatchToken();\n    let thenTokenIndex = this.getThenTokenIndex();\n    let finallyToken = this.getFinallyToken();\n\n    // `try a` → `try { a`\n    //               ^^\n    this.insert(tryToken.end, ` {`);\n    if (this.body.inline()) {\n      this.body.patch({ leftBrace: false });\n    } else {\n      if (catchToken || finallyToken) {\n        this.body.patch({ leftBrace: false, rightBrace: false });\n        // `try { a; catch err` → `try { a; } catch err`\n        //                                  ^^\n        this.insert((catchToken || finallyToken).start, '} ');\n      } else {\n        this.body.patch({ leftBrace: false });\n      }\n    }\n\n    if (thenTokenIndex) {\n      let thenToken = this.sourceTokenAtIndex(thenTokenIndex);\n      let nextToken = this.sourceTokenAtIndex(thenTokenIndex.next());\n      // `try { a; } catch err then b` → `try { a; } catch err b`\n      //                       ^^^^^\n      this.remove(thenToken.start, nextToken.start);\n    }\n\n    if (catchToken) {\n      let afterCatchHeader =\n        this.catchAssignee ?\n          this.catchAssignee.outerEnd :\n          catchToken.end;\n\n      if (this.catchAssignee) {\n        let addErrorParens = !this.catchAssignee.isSurroundedByParentheses();\n        if (addErrorParens) {\n          // `try { a; } catch err` → `try { a; } catch (err`\n          //                                            ^\n          this.insert(this.catchAssignee.outerStart, '(');\n        }\n        this.catchAssignee.patch();\n        if (addErrorParens) {\n          // `try { a; } catch (err` → `try { a; } catch (err)`\n          //                                                 ^\n          this.insert(this.catchAssignee.outerEnd, ')');\n        }\n      } else {\n        // `try { a; } catch` → `try { a; } catch (error)`\n        //                                       ^^^^^^^^\n        this.insert(afterCatchHeader, ` (${this.getErrorBinding()})`);\n      }\n\n      if (this.catchBody) {\n        // `try { a; } catch (error)` → `try { a; } catch (error) {`\n        //                                                       ^^\n        this.insert(afterCatchHeader, ' {');\n        this.catchBody.patch({ leftBrace: false });\n      } else {\n        this.insert(afterCatchHeader, ' {}');\n      }\n    } else if (!finallyToken) {\n      // `try { a; }` → `try { a; } catch (error) {}`\n      //                           ^^^^^^^^^^^^^^^^^\n      this.insert(this.body.innerEnd, ` catch (${this.getErrorBinding()}) {}`);\n    }\n\n    if (finallyToken) {\n      if (!this.finallyBody) {\n        this.insert(finallyToken.end, ' {}');\n      } else if (this.finallyBody.inline()) {\n        this.finallyBody.patch();\n      } else {\n        // `try { a; } finally b` → `try { a; } finally { b`\n        //                                             ^^\n        this.insert(finallyToken.end, ' {');\n        this.finallyBody.patch({ leftBrace: false });\n      }\n    }\n  }\n\n  patchAsExpression() {\n    // Make our children return since we're wrapping in a function.\n    this.setImplicitlyReturns();\n\n    let needsParens = !this.isSurroundedByParentheses();\n    if (needsParens) {\n      // `a = try b()` → `a = (try b()`\n      //                      ^\n      this.insert(this.outerStart, '(');\n    }\n    // `a = (try b()` → `a = (() => { try b()`\n    //                        ^^^^^^^^\n    this.insert(this.outerStart, '() => { ');\n    this.patchAsStatement();\n    // `a = (() => { try { b(); } catch (error) {}` → `a = (() => { try { b(); } catch (error) {} }`\n    //                                                                                           ^^\n    this.insert(this.outerEnd, ' }');\n    if (needsParens) {\n      // `a = (() => { try { b(); } catch (error) {} }` → `a = (() => { try { b(); } catch (error) {} })`\n      //                                                                                               ^\n      this.insert(this.outerEnd, ')');\n    }\n    // `a = (() => { try { b(); } catch (error) {} })` → `a = (() => { try { b(); } catch (error) {} })()`\n    //                                                                                                 ^^\n    this.insert(this.outerEnd, '()');\n  }\n\n  setImplicitlyReturns() {\n    this.body.setImplicitlyReturns();\n    if (this.catchBody) {\n      this.catchBody.setImplicitlyReturns();\n    }\n  }\n  \n  statementNeedsSemicolon(): boolean {\n    return false;\n  }\n\n  /**\n   * @private\n   */\n  getTryToken(): SourceToken {\n    let tryTokenIndex = this.contentStartTokenIndex;\n    let tryToken = this.sourceTokenAtIndex(tryTokenIndex);\n    if (!tryToken || tryToken.type !== TRY) {\n      throw this.error(`expected 'try' keyword at start of 'try' statement`);\n    }\n    return tryToken;\n  }\n\n  /**\n   * @private\n   */\n  getCatchToken(): ?SourceToken {\n    let searchEnd;\n    if (this.catchAssignee) {\n      searchEnd = this.catchAssignee.outerStart;\n    } else if (this.catchBody) {\n      searchEnd = this.catchBody.outerStart;\n    } else if (this.finallyBody) {\n      searchEnd = this.finallyBody.outerStart;\n    } else {\n      searchEnd = this.contentEnd;\n    }\n\n    let catchTokenIndex = this.indexOfSourceTokenBetweenSourceIndicesMatching(\n      this.body.outerEnd, searchEnd, token => token.type === CATCH\n    );\n    if (!catchTokenIndex) {\n      return null;\n    }\n    return this.sourceTokenAtIndex(catchTokenIndex);\n  }\n\n  /**\n   * @private\n   */\n  getThenTokenIndex(): ?SourceTokenListIndex {\n    if (!this.catchAssignee && !this.catchBody) {\n      return null;\n    }\n    return this.indexOfSourceTokenBetweenPatchersMatching(\n      this.catchAssignee || this.body, this.catchBody,\n      token => token.type === THEN\n    );\n  }\n\n  /**\n   * @private\n   */\n  getFinallyToken(): ?SourceToken {\n    let searchStart;\n    if (this.catchBody) {\n      searchStart = this.catchBody.outerEnd;\n    } else if (this.catchAssignee) {\n      searchStart = this.catchAssignee.outerEnd;\n    } else {\n      searchStart = this.body.outerEnd;\n    }\n\n    let searchEnd;\n    if (this.finallyBody) {\n      searchEnd = this.finallyBody.outerStart;\n    } else {\n      searchEnd = this.contentEnd;\n    }\n\n    let finallyTokenIndex = this.indexOfSourceTokenBetweenSourceIndicesMatching(\n      searchStart, searchEnd, token => token.type === FINALLY\n    );\n    if (!finallyTokenIndex) {\n      return null;\n    }\n    return this.sourceTokenAtIndex(finallyTokenIndex);\n  }\n\n  /**\n   * @private\n   */\n  getErrorBinding(): string {\n    if (!this._errorBinding) {\n      this._errorBinding = this.claimFreeBinding('error');\n    }\n    return this._errorBinding;\n  }\n}\n","import UnaryOpPatcher from './UnaryOpPatcher.js';\n\n/**\n * Handles unary exists, e.g. `a?`.\n */\nexport default class UnaryExistsOpPatcher extends UnaryOpPatcher {\n  negated: boolean = false;\n\n  /**\n   * The expression version of this sometimes needs parentheses, but we don't\n   * yet have a good mechanism for determining when that is, so we just make\n   * sure they're always there. For example, this doesn't need parentheses:\n   *\n   *   set = a?\n   *\n   * Because it becomes this:\n   *\n   *   var set = typeof a !== 'undefined' && a !== null;\n   *\n   * But this does:\n   *\n   *   'set? ' + a?\n   *\n   * Because this:\n   *\n   *   'set? ' + a != null;\n   *\n   * Is equivalent to this:\n   *\n   *   ('set? + a) != null;\n   *\n   * Which has a different meaning than this:\n   *\n   *   'set? ' + (a != null);\n   */\n  patchAsExpression({ needsParens=true }={}) {\n    let addParens = needsParens && !this.isSurroundedByParentheses();\n    if (addParens) {\n      // `a?` → `(a?`\n      //         ^\n      this.insert(this.contentStart, '(');\n    }\n    this.patchAsStatement();\n    if (addParens) {\n      // `(a?` → `(a?)`\n      //             ^\n      this.insert(this.contentEnd, ')');\n    }\n  }\n\n  /**\n   * EXPRESSION '?'\n   */\n  patchAsStatement() {\n    let { node: { expression }, negated } = this;\n    let needsTypeofCheck = this.needsTypeofCheck();\n\n    this.expression.patch();\n    if (needsTypeofCheck) {\n      if (negated) {\n        // `a?` → `typeof a === 'undefined' && a === null`\n        //  ^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        this.overwrite(\n          this.contentStart,\n          this.contentEnd,\n          `typeof ${expression.raw} === 'undefined' || ${expression.raw} === null`\n        );\n      } else {\n        // `a?` → `typeof a !== 'undefined' && a !== null`\n        //  ^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        this.overwrite(\n          this.contentStart,\n          this.contentEnd,\n          `typeof ${expression.raw} !== 'undefined' && ${expression.raw} !== null`\n        );\n      }\n\n    } else {\n      if (negated) {\n        // `a.b?` → `a.b == null`\n        //     ^        ^^^^^^^^\n        this.overwrite(this.expression.outerEnd, this.contentEnd, ' == null');\n      } else {\n        // `a.b?` → `a.b != null`\n        //     ^        ^^^^^^^^\n        this.overwrite(this.expression.outerEnd, this.contentEnd, ' != null');\n      }\n    }\n  }\n\n  /**\n   * Since we turn into an equality check, we can simply invert the operator\n   * to handle negation internally rather than by prefixing with `!`.\n   */\n  canHandleNegationInternally(): boolean {\n    return true;\n  }\n\n  /**\n   * Flips negated flag but doesn't edit anything immediately so that we can\n   * use the correct operator in `patch`.\n   */\n  negate() {\n    this.negated = !this.negated;\n  }\n\n  /**\n   * @private\n   */\n  needsTypeofCheck(): boolean {\n    let { node } = this;\n    let { expression } = node;\n    return (\n      expression &&\n      expression.type === 'Identifier' &&\n      !node.scope.hasBinding(expression.data)\n    );\n  }\n\n  /**\n   * When we prefix with a `typeof` check we don't need parens, otherwise\n   * delegate.\n   */\n  statementNeedsParens(): boolean {\n    if (this.needsTypeofCheck()) {\n      return false;\n    } else {\n      return this.expression.statementShouldAddParens();\n    }\n  }\n}\n","import UnaryOpPatcher from './UnaryOpPatcher.js';\n\n/**\n * Handles unary math operators, e.g. `+a`, `-a`, `~a`.\n */\nexport default class UnaryMathOpPatcher extends UnaryOpPatcher {\n  /**\n   * Math does not (usually) have side effects, as far as CoffeeScript is\n   * concerned. It could trigger a `valueOf` call that could trigger arbitrary\n   * code, but we ignore that possibility.\n   */\n  isRepeatable(): boolean {\n    return this.expression.isRepeatable();\n  }\n}\n","import UnaryOpPatcher from './UnaryOpPatcher.js';\n\n/**\n * Handles `typeof`, e.g. `typeof name`.\n */\nexport default class UnaryTypeofOpPatcher extends UnaryOpPatcher {\n  /**\n   * `typeof` does not have side-effects.\n   */\n  isRepeatable(): boolean {\n    return this.expression.isRepeatable();\n  }\n\n  /**\n   * This always starts with `typeof` and doesn't need parens.\n   */\n  statementNeedsParens(): boolean {\n    return false;\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport LoopPatcher from './LoopPatcher.js';\nimport type BlockPatcher from './BlockPatcher.js';\nimport type { Editor, Node, ParseContext, SourceTokenListIndex } from './../../../patchers/types.js';\nimport { LOOP, THEN, WHILE } from 'coffee-lex';\n\n/**\n * Handles `while` loops, e.g.\n *\n *   while a\n *     b\n */\nexport default class WhilePatcher extends LoopPatcher {\n  condition: NodePatcher;\n  guard: ?NodePatcher;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, condition: NodePatcher, guard: ?NodePatcher, body: BlockPatcher) {\n    super(node, context, editor, body);\n    this.condition = condition;\n    this.guard = guard;\n  }\n\n  /**\n   * ( 'while' | 'until' ) CONDITION ('when' GUARD)? 'then' BODY\n   * ( 'while' | 'until' ) CONDITION ('when' GUARD)? NEWLINE INDENT BODY\n   * 'loop' 'then' BODY\n   * 'loop' NEWLINE INDENT BODY\n   */\n  patchAsStatement() {\n    if (!this.body.inline()) {\n      this.body.setIndent(this.getLoopBodyIndent());\n    }\n\n    // `until a` → `while a`\n    //  ^^^^^       ^^^^^\n    let whileToken = this.sourceTokenAtIndex(this.getWhileTokenIndex());\n    let isLoop = whileToken.type === LOOP;\n\n    if (isLoop) {\n      this.overwrite(whileToken.start, whileToken.end, 'while (true) {');\n    } else {\n      this.overwrite(whileToken.start, whileToken.end, 'while');\n\n      let conditionNeedsParens = !this.condition.isSurroundedByParentheses();\n      if (conditionNeedsParens) {\n        // `while a` → `while (a`\n        //                    ^\n        this.insert(this.condition.outerStart, '(');\n      }\n\n      if (this.node.isUntil) {\n        this.condition.negate();\n      }\n      this.condition.patch();\n\n      if (this.guard) {\n        let guardNeedsParens = !this.guard.isSurroundedByParentheses();\n        if (this.body.inline()) {\n          // `while (a when b` → `while (a) { if (b`\n          //          ^^^^^^              ^^^^^^^^\n          this.overwrite(\n            this.condition.outerEnd,\n            this.guard.outerStart,\n            `${conditionNeedsParens ? ')' : ''} { if ${guardNeedsParens ? '(' : ''}`\n          );\n        } else {\n          // `while (a when b` → `while (a) {\\n  if (b`\n          //          ^^^^^^              ^^^^^^^^^^^\n          this.overwrite(\n            this.condition.outerEnd,\n            this.guard.outerStart,\n            `${conditionNeedsParens ? ')' : ''} {\\n${this.getOuterLoopBodyIndent()}if ${guardNeedsParens ? '(' : ''}`\n          );\n\n        }\n        this.guard.patch();\n\n        // `while (a) {\\n  if (b` → `while (a) {\\n  if (b) {`\n        //                                               ^^^\n        this.insert(this.guard.outerEnd, `${guardNeedsParens ? ')' : ''} {`);\n      } else {\n        // `while (a` → `while (a) {`\n        //                       ^^^\n        this.insert(this.condition.outerEnd, `${conditionNeedsParens ? ')' : ''} {`);\n      }\n    }\n\n    let thenIndex = this.getThenTokenIndex();\n    if (thenIndex) {\n      let thenToken = this.sourceTokenAtIndex(thenIndex);\n      let nextToken = this.sourceTokenAtIndex(thenIndex.next());\n      this.remove(thenToken.start, nextToken.start);\n    }\n\n    this.patchPossibleNewlineAfterLoopHeader(\n      this.guard ? this.guard.outerEnd : this.condition.outerEnd);\n    this.patchBodyWithPossibleItemVariable();\n\n    if (this.guard) {\n      // Close the guard's `if` consequent block.\n      this.body.insertLineAfter('}', this.getOuterLoopBodyIndent());\n    }\n\n    // Close the `while` body block.\n    this.body.insertLineAfter('}', this.getLoopIndent());\n  }\n\n  /**\n   * @private\n   */\n  getWhileTokenIndex(): SourceTokenListIndex {\n    let whileTokenIndex = this.contentStartTokenIndex;\n    let whileToken = this.sourceTokenAtIndex(whileTokenIndex);\n    if (!whileToken) {\n      throw this.error(`could not get first token of 'while' loop`);\n    }\n    switch (whileToken.type) {\n      case LOOP:\n      case WHILE:\n        return whileTokenIndex;\n\n      default:\n        throw this.error(\n          `expected 'while' token to be type WHILE or LOOP, got ${whileToken.type.name}`\n        );\n    }\n  }\n\n  /**\n   * @private\n   */\n  getThenTokenIndex(): ?SourceTokenListIndex {\n    let whileTokenIndex = this.getWhileTokenIndex();\n    if (!whileTokenIndex) {\n      throw this.error(`could not get first token of 'while' loop`);\n    }\n\n    let whileToken = this.sourceTokenAtIndex(whileTokenIndex);\n    if (whileToken.type === LOOP) {\n      // `loop then …`\n      let nextTokenIndex = whileTokenIndex.next();\n      let nextToken = this.sourceTokenAtIndex(nextTokenIndex);\n      if (!nextToken) {\n        throw this.error(`expected another token after 'loop' but none was found`);\n      }\n      return nextToken.type === THEN ? nextTokenIndex : null;\n    } else {\n      // `while a then …`\n      return this.indexOfSourceTokenBetweenPatchersMatching(\n        this.guard || this.condition,\n        this.body,\n        token => token.type === THEN\n      );\n    }\n  }\n\n  getLoopBodyIndent() {\n    if (this.guard) {\n      return this.getOuterLoopBodyIndent() + this.getProgramIndentString();\n    } else {\n      return this.getOuterLoopBodyIndent();\n    }\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Node, ParseContext, Editor } from './../../../patchers/types.js';\n\nexport default class YieldPatcher extends NodePatcher {\n  expression: NodePatcher;\n  \n  constructor(node: Node, context: ParseContext, editor: Editor, expression: NodePatcher) {\n    super(node, context, editor);\n    this.expression = expression;\n  }\n  \n  initialize() {\n    this.yields();\n    this.expression.setRequiresExpression();\n  }\n\n  /**\n   * 'yield' EXPRESSION\n   */\n  patchAsExpression({ needsParens=true }={}) {\n    this.expression.patch({ needsParens });\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Node, ParseContext, Editor } from './../../../patchers/types.js';\n\nexport default class YieldFromPatcher extends NodePatcher {\n  expression: NodePatcher;\n  \n  constructor(node: Node, context: ParseContext, editor: Editor, expression: NodePatcher) {\n    super(node, context, editor);\n    this.expression = expression;\n  }\n  \n  initialize() {\n    this.yields();\n    this.expression.setRequiresExpression();\n  }\n\n  /**\n   * 'yield' 'from' EXPRESSION\n   */\n  patchAsExpression({ needsParens=true }={}) {\n    let src = this.sourceTokenAtIndex(this.contentStartTokenIndex);\n    this.overwrite(src.start, src.end, 'yield*');\n    \n    this.expression.patch({ needsParens });\n  }\n}\n","import ArrayInitialiserPatcher from './patchers/ArrayInitialiserPatcher.js';\nimport AssignOpPatcher from './patchers/AssignOpPatcher.js';\nimport BinaryOpPatcher from './patchers/BinaryOpPatcher.js';\nimport BlockPatcher from './patchers/BlockPatcher.js';\nimport BoolPatcher from './patchers/BoolPatcher.js';\nimport BoundFunctionPatcher from './patchers/BoundFunctionPatcher.js';\nimport BoundGeneratorFunctionPatcher from './patchers/BoundGeneratorFunctionPatcher.js';\nimport ChainedComparisonOpPatcher from './patchers/ChainedComparisonOpPatcher.js';\nimport ClassAssignOpPatcher from './patchers/ClassAssignOpPatcher.js';\nimport ClassPatcher from './patchers/ClassPatcher.js';\nimport CompoundAssignOpPatcher from './patchers/CompoundAssignOpPatcher.js';\nimport ConditionalPatcher from './patchers/ConditionalPatcher.js';\nimport ConstructorPatcher from './patchers/ConstructorPatcher.js';\nimport DefaultParamPatcher from './patchers/DefaultParamPatcher.js';\nimport DoOpPatcher from './patchers/DoOpPatcher.js';\nimport DynamicMemberAccessOpPatcher from './patchers/DynamicMemberAccessOpPatcher.js';\nimport EqualityPatcher from './patchers/EqualityPatcher.js';\nimport ExpOpPatcher from './patchers/ExpOpPatcher.js';\nimport ExistsOpCompoundAssignOpPatcher from './patchers/ExistsOpCompoundAssignOpPatcher.js';\nimport ExistsOpPatcher from './patchers/ExistsOpPatcher.js';\nimport ExpansionPatcher from './patchers/ExpansionPatcher.js';\nimport ExtendsOpPatcher from './patchers/ExtendsOpPatcher.js';\nimport FloorDivideOpPatcher from './patchers/FloorDivideOpPatcher.js';\nimport ForInPatcher from './patchers/ForInPatcher.js';\nimport ForOfPatcher from './patchers/ForOfPatcher.js';\nimport FunctionApplicationPatcher from './patchers/FunctionApplicationPatcher.js';\nimport FunctionPatcher from './patchers/FunctionPatcher.js';\nimport HeregexPatcher from './patchers/HeregexPatcher.js';\nimport IdentifierPatcher from './patchers/IdentifierPatcher.js';\nimport InOpPatcher from './patchers/InOpPatcher.js';\nimport InstanceofOpPatcher from './patchers/InstanceofOpPatcher.js';\nimport JavaScriptPatcher from './patchers/JavaScriptPatcher.js';\nimport LogicalNotOpPatcher from './patchers/LogicalNotOpPatcher.js';\nimport LogicalOpCompoundAssignOpPatcher from './patchers/LogicalOpCompoundAssignOpPatcher.js';\nimport LogicalOpPatcher from './patchers/LogicalOpPatcher.js';\nimport MemberAccessOpPatcher from './patchers/MemberAccessOpPatcher.js';\nimport ModuloOpPatcher from './patchers/ModuloOpPatcher.js';\nimport NewOpPatcher from './patchers/NewOpPatcher.js';\nimport ObjectInitialiserMemberPatcher from './patchers/ObjectInitialiserMemberPatcher.js';\nimport ObjectInitialiserPatcher from './patchers/ObjectInitialiserPatcher.js';\nimport OfOpPatcher from './patchers/OfOpPatcher.js';\nimport PassthroughPatcher from './../../patchers/PassthroughPatcher.js';\nimport ProgramPatcher from './patchers/ProgramPatcher.js';\nimport ProtoMemberAccessOpPatcher from './patchers/ProtoMemberAccessOpPatcher.js';\nimport RangePatcher from './patchers/RangePatcher.js';\nimport RegExpPatcher from './patchers/RegExpPatcher.js';\nimport RestPatcher from './patchers/RestPatcher.js';\nimport ReturnPatcher from './patchers/ReturnPatcher.js';\nimport SeqOpPatcher from './patchers/SeqOpPatcher.js';\nimport SlicePatcher from './patchers/SlicePatcher.js';\nimport SoakedDynamicMemberAccessOpPatcher from './patchers/SoakedDynamicMemberAccessOpPatcher.js';\nimport SoakedFunctionApplicationPatcher from './patchers/SoakedFunctionApplicationPatcher.js';\nimport SoakedMemberAccessOpPatcher from './patchers/SoakedMemberAccessOpPatcher.js';\nimport SpreadPatcher from './patchers/SpreadPatcher.js';\nimport StringPatcher from './patchers/StringPatcher.js';\nimport SuperPatcher from './patchers/SuperPatcher.js';\nimport SwitchCasePatcher from './patchers/SwitchCasePatcher.js';\nimport SwitchPatcher from './patchers/SwitchPatcher.js';\nimport ThisPatcher from './patchers/ThisPatcher.js';\nimport ThrowPatcher from './patchers/ThrowPatcher.js';\nimport TransformCoffeeScriptStage from '../TransformCoffeeScriptStage.js';\nimport TryPatcher from './patchers/TryPatcher.js';\nimport UnaryExistsOpPatcher from './patchers/UnaryExistsOpPatcher.js';\nimport UnaryMathOpPatcher from './patchers/UnaryMathOpPatcher.js';\nimport UnaryOpPatcher from './patchers/UnaryOpPatcher.js';\nimport UnaryTypeofOpPatcher from './patchers/UnaryTypeofOpPatcher.js';\nimport WhilePatcher from './patchers/WhilePatcher.js';\nimport GeneratorFunctionPatcher from './patchers/GeneratorFunctionPatcher.js';\nimport YieldPatcher from './patchers/YieldPatcher.js';\nimport YieldFromPatcher from './patchers/YieldFromPatcher.js';\nimport type NodePatcher from './../../patchers/NodePatcher.js';\nimport type { Node } from '../../patchers/types.js';\n\nexport default class MainStage extends TransformCoffeeScriptStage {\n  patcherConstructorForNode(node: Node): ?Class<NodePatcher> {\n    switch (node.type) {\n      case 'Identifier':\n        return IdentifierPatcher;\n\n      case 'String':\n        return StringPatcher;\n      case 'Int':\n      case 'Float':\n      case 'Null':\n      case 'Undefined':\n      case 'PostIncrementOp':\n      case 'PostDecrementOp':\n      case 'PreIncrementOp':\n      case 'PreDecrementOp':\n      case 'Quasi':\n        return PassthroughPatcher;\n\n      case 'FunctionApplication':\n        return FunctionApplicationPatcher;\n\n      case 'SoakedFunctionApplication':\n        return SoakedFunctionApplicationPatcher;\n\n      case 'MemberAccessOp':\n        return MemberAccessOpPatcher;\n\n      case 'DynamicMemberAccessOp':\n        return DynamicMemberAccessOpPatcher;\n\n      case 'EQOp':\n      case 'NEQOp':\n      case 'LTOp':\n      case 'GTOp':\n      case 'LTEOp':\n      case 'GTEOp':\n        return EqualityPatcher;\n\n      case 'ObjectInitialiserMember':\n        return ObjectInitialiserMemberPatcher;\n\n      case 'ObjectInitialiser':\n        return ObjectInitialiserPatcher;\n\n      case 'This':\n        return ThisPatcher;\n  \n      case 'Yield':\n       return YieldPatcher;\n    \n      case 'YieldFrom':\n       return YieldFromPatcher;\n    \n      case 'GeneratorFunction':\n       return GeneratorFunctionPatcher;\n    \n      case 'Function':\n        return FunctionPatcher;\n\n      case 'BoundFunction':\n        return BoundFunctionPatcher;\n\n      case 'BoundGeneratorFunction':\n        return BoundGeneratorFunctionPatcher;\n\n      case 'Bool':\n        return BoolPatcher;\n\n      case 'Conditional':\n        return ConditionalPatcher;\n\n      case 'ArrayInitialiser':\n        return ArrayInitialiserPatcher;\n\n      case 'Block':\n        return BlockPatcher;\n\n      case 'AssignOp':\n        return AssignOpPatcher;\n\n      case 'DefaultParam':\n        return DefaultParamPatcher;\n\n      case 'CompoundAssignOp':\n        switch (node.op) {\n          case 'LogicalAndOp':\n          case 'LogicalOrOp':\n            return LogicalOpCompoundAssignOpPatcher;\n\n          case 'ExistsOp':\n            return ExistsOpCompoundAssignOpPatcher;\n\n          default:\n            return CompoundAssignOpPatcher;\n        }\n\n      case 'Return':\n        return ReturnPatcher;\n\n      case 'PlusOp':\n      case 'SubtractOp':\n      case 'DivideOp':\n      case 'MultiplyOp':\n      case 'RemOp':\n      case 'BitAndOp':\n      case 'BitOrOp':\n      case 'BitXorOp':\n      case 'LeftShiftOp':\n      case 'SignedRightShiftOp':\n      case 'UnsignedRightShiftOp':\n        return BinaryOpPatcher;\n\n      case 'ModuloOp':\n        return ModuloOpPatcher;\n\n      case 'RegExp':\n        return RegExpPatcher;\n\n      case 'Heregex':\n        return HeregexPatcher;\n\n      case 'ExistsOp':\n        return ExistsOpPatcher;\n\n      case 'LogicalAndOp':\n      case 'LogicalOrOp':\n        return LogicalOpPatcher;\n\n      case 'LogicalNotOp':\n        return LogicalNotOpPatcher;\n\n      case 'SoakedMemberAccessOp':\n        return SoakedMemberAccessOpPatcher;\n\n      case 'SoakedDynamicMemberAccessOp':\n        return SoakedDynamicMemberAccessOpPatcher;\n\n      case 'ForIn':\n        return ForInPatcher;\n\n      case 'ForOf':\n        return ForOfPatcher;\n\n      case 'While':\n        return WhilePatcher;\n\n      case 'NewOp':\n        return NewOpPatcher;\n\n      case 'InOp':\n        return InOpPatcher;\n\n      case 'Slice':\n        return SlicePatcher;\n\n      case 'Expansion':\n        return ExpansionPatcher;\n\n      case 'Rest':\n        return RestPatcher;\n\n      case 'Spread':\n        return SpreadPatcher;\n\n      case 'Range':\n        return RangePatcher;\n\n      case 'Throw':\n        return ThrowPatcher;\n\n      case 'UnaryPlusOp':\n      case 'UnaryNegateOp':\n      case 'BitNotOp':\n        return UnaryMathOpPatcher;\n\n      case 'TypeofOp':\n        return UnaryTypeofOpPatcher;\n\n      case 'DeleteOp':\n        return UnaryOpPatcher;\n\n      case 'UnaryExistsOp':\n        return UnaryExistsOpPatcher;\n\n      case 'ClassProtoAssignOp':\n        return ClassAssignOpPatcher;\n\n      case 'Super':\n        return SuperPatcher;\n\n      case 'Class':\n        return ClassPatcher;\n\n      case 'Constructor':\n        return ConstructorPatcher;\n\n      case 'Try':\n        return TryPatcher;\n\n      case 'Switch':\n        return SwitchPatcher;\n\n      case 'SwitchCase':\n        return SwitchCasePatcher;\n\n      case 'DoOp':\n        return DoOpPatcher;\n\n      case 'ProtoMemberAccessOp':\n        return ProtoMemberAccessOpPatcher;\n\n      case 'Program':\n        return ProgramPatcher;\n\n      case 'InstanceofOp':\n        return InstanceofOpPatcher;\n\n      case 'OfOp':\n        return OfOpPatcher;\n\n      case 'ChainedComparisonOp':\n        return ChainedComparisonOpPatcher;\n\n      case 'SeqOp':\n        return SeqOpPatcher;\n\n      case 'JavaScript':\n        return JavaScriptPatcher;\n\n      case 'FloorDivideOp':\n        return FloorDivideOpPatcher;\n\n      case 'ExpOp':\n        return ExpOpPatcher;\n\n      case 'ExtendsOp':\n        return ExtendsOpPatcher;\n\n      default:\n        return null;\n    }\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Editor, Node, ParseContext } from './../../../patchers/types.js';\nimport { COMMA } from 'coffee-lex';\n\nexport default class ArrayInitialiserPatcher extends NodePatcher {\n  members: Array<NodePatcher>;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, members: Array<NodePatcher>) {\n    super(node, context, editor);\n    this.members = members;\n  }\n\n  patchAsExpression() {\n    for (let member of this.members) {\n      // If the last token of the arg is a comma, then the actual delimiter must\n      // be a newline and the comma is unnecessary and can cause a syntax error\n      // when combined with other normalize stage transformations. So just\n      // remove the redundant comma.\n      let lastToken = member.lastToken();\n      if (lastToken.type === COMMA) {\n        this.remove(lastToken.start, lastToken.end);\n      }\n      member.patch();\n    }\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport getStartOfLine from './../../../utils/getStartOfLine.js';\n\nimport type { Node, ParseContext, Editor } from './../../../patchers/types.js';\n\nexport default class BlockPatcher extends NodePatcher {\n  statements: Array<NodePatcher>;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, statements: Array<NodePatcher>) {\n    super(node, context, editor);\n    this.statements = statements;\n  }\n\n  patchAsExpression() {\n    this.patchAsStatement();\n  }\n\n  patchAsStatement() {\n    if (this.node.inline) {\n      for (let statement of this.statements) {\n        statement.patch();\n      }\n      return;\n    }\n\n    // Having inconsistent indentation within a block is allowed in some cases\n    // when there are implicit function calls, but when function call parens are\n    // added, the inconsistent indentation can make the CoffeeScript invalid. So\n    // we need to correct any inconsistent indentation in the normalize step so\n    // that the result CoffeeScript will always be valid.\n    let blockIndentLength = null;\n    for (let statement of this.statements) {\n      let indentLength = this.getIndentLength(statement);\n      if (indentLength !== null) {\n        if (blockIndentLength === null) {\n          blockIndentLength = indentLength;\n        } else {\n          let charsToRemove = indentLength - blockIndentLength;\n          if (charsToRemove < 0) {\n            throw this.error(\n              'Unexpected statement at an earlier indentation level than an ' +\n              'earlier statement in the block.');\n          }\n          if (charsToRemove > 0) {\n            this.remove(statement.outerStart - charsToRemove, statement.outerStart);\n          }\n        }\n      }\n      statement.patch();\n    }\n  }\n\n  /**\n   * If this statement starts immediately after its line's initial indentation,\n   * return the length of that indentation. Otherwise, return null.\n   */\n  getIndentLength(statement) {\n    let startOfLine = getStartOfLine(this.context.source, statement.outerStart);\n    let indentText = this.context.source.slice(startOfLine, statement.outerStart);\n    if (/^[ \\t]*$/.test(indentText)) {\n      return indentText.length;\n    } else {\n      return null;\n    }\n  }\n}\n","import PassthroughPatcher from '../../../patchers/PassthroughPatcher.js';\n\nexport default class AssignOpPatcher extends PassthroughPatcher {\n  key: NodePatcher;\n  expression: NodePatcher;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, key: NodePatcher, expression: NodePatcher) {\n    super(node, context, editor, key, expression);\n    this.key = key;\n    this.expression = expression;\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport AssignOpPatcher from './AssignOpPatcher.js';\n\nimport type { Node, ParseContext, Editor } from './../../../patchers/types.js';\n\nexport default class ClassPatcher extends NodePatcher {\n  nameAssignee: ?NodePatcher;\n  superclass: ?NodePatcher;\n  body: ?BlockPatcher;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, nameAssignee: ?NodePatcher, parent: ?NodePatcher, body: ?BlockPatcher) {\n    super(node, context, editor);\n    this.nameAssignee = nameAssignee;\n    this.superclass = parent;\n    this.body = body;\n  }\n\n  /**\n   * Handle code within class bodies by restructuring the class to use a static\n   * method instead.\n   *\n   * Current limitations:\n   * - Doesn't handle anonymous classes.\n   * - Doesn't handle classes used in an expression context.\n   * - Doesn't deconflict the \"initClass\" name of the static method.\n   * - Doesn't deconflict the variable assignments that are moved outside the\n   *   class body.\n   * - Technically this changes the execution order of the class body, although\n   *   it does so in a way that is unlikely to cause problems in reasonable\n   *   code.\n   */\n  patchAsStatement() {\n    if (this.nameAssignee) {\n      this.nameAssignee.patch();\n    }\n    if (this.superclass) {\n      this.superclass.patch();\n    }\n    if (this.body) {\n      this.body.patch();\n    }\n\n    if (!this.body) {\n      return;\n    }\n\n    if (this.body.statements.length === 0) {\n      return;\n    }\n\n    let insertPoint = this.getInitClassInsertPoint();\n    let nonMethodPatchers = this.getNonMethodPatchers(insertPoint);\n\n    if (nonMethodPatchers.length > 0) {\n      let assignmentNames = this.generateInitClassMethod(nonMethodPatchers, insertPoint);\n      let indent = this.getIndent();\n      this.insert(this.outerEnd, `\\n${indent}${this.nameAssignee.node.data}.initClass()`);\n      for (let assignmentName of assignmentNames) {\n        this.insert(this.outerStart, `${assignmentName} = undefined\\n${indent}`);\n      }\n    }\n  }\n\n  /**\n   * For now, code in class bodies is only supported for statement classes.\n   */\n  patchAsExpression() {\n    this.body.patch();\n  }\n\n  getInitClassInsertPoint() {\n    if (this.superclass) {\n      return this.superclass.outerEnd;\n    }\n    if (this.nameAssignee) {\n      return this.nameAssignee.outerEnd;\n    }\n    if (this.body) {\n      return this.body.outerStart;\n    }\n    return this.outerStart;\n  }\n\n  /**\n   * Find the statements in the class body that can't be converted to JS\n   * methods. These will later be moved to the top of the class in a static\n   * method.\n   */\n  getNonMethodPatchers(initialDeleteStart) {\n    let nonMethodPatchers = [];\n    let deleteStart = initialDeleteStart;\n    for (let patcher of this.body.statements) {\n      if (!this.isClassMethod(patcher)) {\n        nonMethodPatchers.push({\n          patcher,\n          deleteStart,\n        });\n      }\n      deleteStart = patcher.outerEnd;\n    }\n    return nonMethodPatchers;\n  }\n\n  isClassMethod(patcher) {\n    if (patcher.node.type === 'Constructor') {\n      return true;\n    }\n    if (this.isClassAssignment(patcher.node)) {\n      if (patcher.node.expression.type === 'Function' ||\n          patcher.node.expression.type === 'BoundFunction' ||\n          patcher.node.expression.type === 'GeneratorFunction' ||\n          patcher.node.expression.type === 'BoundGeneratorFunction') {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  isClassAssignment(node) {\n    if (node.type === 'ClassProtoAssignOp') {\n      return true;\n    }\n    if (node.type === 'AssignOp') {\n      let {assignee} = node;\n      if (assignee.type === 'MemberAccessOp') {\n        if (assignee.expression.type === 'This') {\n          return true;\n        }\n        if (this.nameAssignee) {\n          let className = this.nameAssignee.node.data;\n          if (assignee.expression.type === 'Identifier' &&\n              assignee.expression.data === className) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Create the initClass static method by moving nodes from the class body into\n   * the static method and indenting them one level.\n   *\n   * Also return an array of variables that were assigned so that later code can\n   * declare them outside the class body to make them accessible within the\n   * class.\n   */\n  generateInitClassMethod(nonMethodPatchers, insertPoint) {\n    let bodyIndent = this.body.getIndent();\n    let indentString = this.getProgramIndentString();\n    this.insert(insertPoint, `\\n${bodyIndent}@initClass: ->`);\n    let assignmentNames = [];\n    for (let {patcher, deleteStart} of nonMethodPatchers) {\n      let assignmentName = this.getAssignmentName(patcher);\n      if (assignmentName) {\n        assignmentNames.push(assignmentName);\n      }\n      let statementCode = this.getNonMethodStatementCode(patcher, deleteStart);\n      statementCode = statementCode.replace(/\\n/g, `\\n${indentString}`);\n      this.insert(insertPoint, statementCode);\n      this.remove(deleteStart, patcher.outerEnd);\n    }\n    this.insert(insertPoint, `\\n${bodyIndent}${indentString}return`);\n    return assignmentNames;\n  }\n\n  /**\n   * Determine the variable assigned in the given statement, if any, since any\n   * assigned variables need to be declared externally so they are available\n   * within the class body. Note that this is incomplete at the moment and only\n   * covers the common case of a single variable being defined.\n   */\n  getAssignmentName(statementPatcher) {\n    if (statementPatcher.node.type === 'AssignOp' &&\n      statementPatcher.node.assignee.type === 'Identifier') {\n      return statementPatcher.node.assignee.data;\n    }\n    if (statementPatcher instanceof ClassPatcher) {\n      return statementPatcher.nameAssignee.node.data;\n    }\n    return null;\n  }\n\n  getNonMethodStatementCode(statementPatcher, deleteStart) {\n    if (statementPatcher instanceof AssignOpPatcher &&\n        this.isClassAssignment(statementPatcher.node)) {\n      let {key, expression} = statementPatcher;\n      let prefixCode = this.slice(deleteStart, key.outerStart);\n      let keyCode = this.slice(key.outerStart, key.outerEnd);\n      let suffixCode = this.slice(key.outerEnd, expression.outerEnd);\n\n      let equalIndex = suffixCode.indexOf('=');\n      let colonIndex = suffixCode.indexOf(':');\n      if (equalIndex === -1 || colonIndex < equalIndex) {\n        suffixCode = suffixCode.replace(/:/, ' =');\n      }\n\n      if (statementPatcher.node.type === 'ClassProtoAssignOp') {\n        // a: b -> @prototype.a = b\n        return `${prefixCode}@prototype.${keyCode}${suffixCode}`;\n      } else {\n        // @a: b -> @a = b\n        return `${prefixCode}${keyCode}${suffixCode}`;\n      }\n    } else if (statementPatcher instanceof ClassPatcher &&\n        statementPatcher.nameAssignee) {\n      // Nested classes need a special case: they need to be converted to an\n      // assignment statement so that the name can be declared outside the outer\n      // class body and the initialized within initClass.\n      let className = statementPatcher.nameAssignee.node.data;\n      let prefix = this.slice(deleteStart, statementPatcher.outerStart);\n      let suffix = this.slice(statementPatcher.outerStart, statementPatcher.outerEnd);\n      return `${prefix}${className} = ${suffix}`;\n    } else {\n      return this.slice(deleteStart, statementPatcher.outerEnd);\n    }\n  }\n}\n","import NodePatcher from '../../../patchers/NodePatcher.js';\nimport type { Node, ParseContext, Editor } from './../../../patchers/types.js';\nimport type { SourceTokenListIndex } from 'coffee-lex';\nimport { IF } from 'coffee-lex';\n\n/**\n * Normalizes conditionals by rewriting post-`if` into standard `if`, e.g.\n *\n *   return [] unless list?\n *\n * becomes\n *\n *   unless list? then return []\n */\nexport default class ConditionalPatcher extends NodePatcher {\n  condition: NodePatcher;\n  consequent: ?NodePatcher;\n  alternate: ?NodePatcher;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, condition: NodePatcher, consequent: NodePatcher, alternate: ?NodePatcher) {\n    super(node, context, editor);\n    this.condition = condition;\n    this.consequent = consequent;\n    this.alternate = alternate;\n  }\n\n  patchAsExpression() {\n    if (this.isPostIf()) {\n      this.patchPostIf();\n    } else {\n      this.condition.patch();\n      if (this.consequent !== null) {\n        this.consequent.patch();\n      }\n      if (this.alternate !== null) {\n        this.alternate.patch();\n      }\n    }\n  }\n\n  /**\n   * `CONSEQUENT 'if' CONDITION` → `if CONDITION then CONSEQUENT`\n   * `CONSEQUENT 'unless' CONDITION` → `unless CONDITION then CONSEQUENT`\n   */\n  patchPostIf() {\n    this.condition.patch();\n    this.consequent.patch();\n\n    let ifTokenIndex = this.getIfTokenIndex();\n    let ifToken = this.sourceTokenAtIndex(ifTokenIndex);\n\n    if (ifToken) {\n      let consequentCode = this.slice(this.consequent.outerStart, this.consequent.outerEnd);\n      this.remove(this.consequent.outerStart, ifToken.start);\n      this.insert(this.condition.outerEnd, ` then ${consequentCode}`);\n    }\n  }\n\n  isPostIf(): boolean {\n    return this.consequent !== null\n      && this.condition.contentStart > this.consequent.contentStart;\n  }\n\n  getIfTokenIndex(): SourceTokenListIndex {\n    let start = this.contentStartTokenIndex;\n    let index = this.condition.outerStartTokenIndex;\n\n    while (index !== start) {\n      let token = this.sourceTokenAtIndex(index);\n      if (token && token.type === IF) {\n        break;\n      }\n      index = index.previous();\n    }\n\n    if (!index) {\n      throw this.error('unable to find `if` token in conditional');\n    }\n\n    return index;\n  }\n}\n","import NodePatcher from '../../../patchers/NodePatcher.js';\nimport type { Node, ParseContext, Editor, SourceToken } from './../../../patchers/types.js';\nimport { FOR } from 'coffee-lex';\n\nexport default class ForPatcher extends NodePatcher {\n  keyAssignee: ?NodePatcher;\n  valAssignee: ?NodePatcher;\n  target: NodePatcher;\n  filter: ?NodePatcher;\n  body: NodePatcher;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, keyAssignee: ?NodePatcher, valAssignee: ?NodePatcher, target: NodePatcher, filter: ?NodePatcher, body: NodePatcher) {\n    super(node, context, editor);\n    this.keyAssignee = keyAssignee;\n    this.valAssignee = valAssignee;\n    this.target = target;\n    this.filter = filter;\n    this.body = body;\n  }\n\n  patchAsExpression() {\n    if (this.keyAssignee) {\n      this.keyAssignee.patch();\n    }\n    if (this.valAssignee) {\n      this.valAssignee.patch();\n    }\n    this.target.patch();\n    if (this.filter) {\n      this.filter.patch();\n    }\n    this.body.patch();\n\n    if (this.isPostFor()) {\n      this.normalize();\n    }\n  }\n\n  patchAsStatement() {\n    this.patchAsExpression();\n  }\n\n  /**\n   * @private\n   */\n  isPostFor(): boolean {\n    return this.body.contentStart < this.target.contentStart;\n  }\n\n  /**\n   * @private\n   */\n  normalize() {\n    let forToken = this.getForToken();\n    let forThroughEnd = this.slice(forToken.start, this.contentEnd);\n    let startUntilFor = this.slice(this.contentStart, this.body.outerEnd);\n    this.overwrite(\n      this.contentStart,\n      this.contentEnd,\n      `${forThroughEnd} then ${startUntilFor}`\n    );\n  }\n\n  /**\n   * @private\n   */\n  getForToken(): SourceToken {\n    if (this.isPostFor()) {\n      let afterForToken = this.getFirstHeaderPatcher();\n      let index = this.indexOfSourceTokenBetweenPatchersMatching(\n        this.body, afterForToken,\n        token => token.type === FOR\n      );\n\n      if (!index) {\n        throw this.error(`cannot find 'for' token in loop`);\n      }\n\n      return this.sourceTokenAtIndex(index);\n    } else {\n      let token = this.sourceTokenAtIndex(this.contentStartTokenIndex);\n\n      if (!token || token.type !== FOR) {\n        throw this.error(`expected 'for' at start of loop`);\n      }\n\n      return token;\n    }\n  }\n\n  /**\n   * @private\n   */\n  getFirstHeaderPatcher(): NodePatcher {\n    let candidates = [this.keyAssignee, this.valAssignee, this.target];\n    let result = null;\n    candidates.forEach(candidate => {\n      if (!candidate) { return; }\n      if (result === null || candidate.contentStart < result.contentStart) {\n        result = candidate;\n      }\n    });\n    if (result === null) {\n      throw this.error(`cannot get first patcher of 'for' loop header`);\n    }\n    return result;\n  }\n}\n","import ForPatcher from './ForPatcher.js';\nimport type NodePatcher from '../../../patchers/NodePatcher.js';\nimport type { Node, ParseContext, Editor } from './../../../patchers/types.js';\n\nexport default class ForInPatcher extends ForPatcher {\n  step: ?NodePatcher;\n  \n  constructor(node: Node, context: ParseContext, editor: Editor, keyAssignee: ?NodePatcher, valAssignee: ?NodePatcher, target: NodePatcher, step: ?NodePatcher, filter: ?NodePatcher, body: NodePatcher) {\n    super(node, context, editor, keyAssignee, valAssignee, target, filter, body);\n    this.step = step;\n  }\n\n  patchAsExpression() {\n    super.patchAsExpression();\n    if (this.step) {\n      this.step.patch();\n    }\n  }\n}\n","import ForPatcher from './ForPatcher.js';\n\nexport default class ForOfPatcher extends ForPatcher {}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Editor, Node, ParseContext } from './../../../patchers/types.js';\nimport { CALL_START, CALL_END, COMMA, EXISTENCE, NEWLINE, RBRACE, RBRACKET, RPAREN } from 'coffee-lex';\n\nexport default class FunctionApplicationPatcher extends NodePatcher {\n  fn: NodePatcher;\n  args: Array<NodePatcher>;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, fn: NodePatcher, args: Array<NodePatcher>) {\n    super(node, context, editor);\n    this.fn = fn;\n    this.args = args;\n  }\n\n  patchAsExpression() {\n    let implicitCall = this.isImplicitCall();\n    let { args } = this;\n\n    this.fn.patch();\n\n    if (this.isImplicitSuper()) {\n      this.insert(this.fn.contentEnd, '(arguments...)');\n      return;\n    }\n\n    if (implicitCall) {\n      let firstArg = args[0];\n      let hasOneArg = args.length === 1;\n      let firstArgIsOnNextLine = !firstArg ? false :\n        /\\n/.test(this.context.source.slice(this.fn.outerEnd, firstArg.outerStart));\n      let funcEnd = this.getFuncEnd();\n      if ((hasOneArg && firstArg.node.virtual) || firstArgIsOnNextLine) {\n        this.insert(funcEnd, '(');\n      } else {\n        this.overwrite(funcEnd, firstArg.outerStart, '(');\n      }\n    }\n\n    for (let arg of args) {\n      // If the last token of the arg is a comma, then the actual delimiter must\n      // be a newline and the comma is unnecessary and can cause a syntax error\n      // when combined with other normalize stage transformations. So just\n      // remove the redundant comma.\n      let lastToken = arg.lastToken();\n      if (lastToken.type === COMMA) {\n        this.remove(lastToken.start, lastToken.end);\n      }\n      arg.patch();\n    }\n\n    if (implicitCall) {\n      this.insertImplicitCloseParen();\n    }\n  }\n\n  /**\n   * We need to be careful when inserting the close-paren after a function call,\n   * since an incorrectly-placed close-paren can cause a parsing error in the\n   * MainStage due to subtle indentation rules in the CoffeeScript parser.\n   *\n   * In particular, we prefer to place the close paren after an existing } or ],\n   * or before an existing ), if we can, since that is least likely to confuse\n   * any indentation parsing. But in some cases it's best to instead insert the\n   * close-paren properly-indented on its own line.\n   */\n  insertImplicitCloseParen() {\n    let argListCode = this.slice(\n      this.args[0].contentStart, this.args[this.args.length - 1].contentEnd);\n    let isArgListMultiline = argListCode.indexOf('\\n') !== -1;\n    let lastTokenType = this.lastToken().type;\n    if (!isArgListMultiline || lastTokenType === RBRACE || lastTokenType === RBRACKET) {\n      this.insert(this.contentEnd, ')');\n      return;\n    }\n\n    let followingCloseParen = this.getFollowingCloseParenIfExists();\n    if (followingCloseParen) {\n      this.insert(followingCloseParen.start, ')');\n      return;\n    }\n\n    let { args } = this;\n    let lastArg = args[args.length - 1];\n    if (lastArg.isMultiline()) {\n      this.insert(this.contentEnd, `\\n${this.getIndent()})`);\n      return;\n    }\n\n    this.insert(this.contentEnd, ')');\n  }\n\n  getFollowingCloseParenIfExists() {\n    let tokenIndex = this.contentEndTokenIndex;\n    let token;\n    do {\n      tokenIndex = tokenIndex.next();\n      if (tokenIndex === null) {\n        return null;\n      }\n      token = this.sourceTokenAtIndex(tokenIndex);\n      if (token === null) {\n        return null;\n      }\n    } while (token.type === NEWLINE);\n\n    if (token.type === CALL_END || token.type === RPAREN) {\n      return token;\n    }\n    return null;\n  }\n\n  /**\n   * Determine if parens need to be inserted. Needs to handle implicit soaked\n   * function calls (where there's a question mark between the function and the\n   * args).\n   *\n   * Note that we do not add parentheses for constructor invocations with no\n   * arguments and no parentheses; that usage is correct in JavaScript, so we\n   * leave it as-is.\n   */\n  isImplicitCall(): boolean {\n    if (this.args.length === 0) {\n      return false;\n    }\n    let searchStart = this.fn.outerEnd;\n    let searchEnd = this.args[0].outerStart;\n    return this.indexOfSourceTokenBetweenSourceIndicesMatching(\n      searchStart, searchEnd, token => token.type === CALL_START) === null;\n  }\n\n  /**\n   * Get the source index after the function and the question mark, if any.\n   * This is the start of the region to insert an open-paren if necessary\n   */\n  getFuncEnd() {\n    if (this.node.type === 'SoakedFunctionApplication') {\n      let questionMarkTokenIndex = this.indexOfSourceTokenAfterSourceTokenIndex(\n        this.fn.outerEndTokenIndex, EXISTENCE);\n      let questionMarkToken = this.sourceTokenAtIndex(questionMarkTokenIndex);\n      return questionMarkToken.end;\n    } else {\n      return this.fn.outerEnd;\n    }\n  }\n\n  isImplicitSuper(): boolean {\n    if (this.fn.node.type !== 'Super') {\n      return false;\n    }\n\n    if (this.args.length !== 1) {\n      return false;\n    }\n\n    let arg = this.args[0].node;\n\n    return (\n      arg.virtual &&\n      arg.type === 'Spread' &&\n      arg.expression.type === 'Identifier' &&\n      arg.expression.data === 'arguments'\n    );\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Editor, Node, ParseContext } from './../../../patchers/types.js';\nimport { COMMA } from 'coffee-lex';\n\n/**\n * Handles object literals.\n */\nexport default class ObjectInitialiserPatcher extends NodePatcher {\n  members: Array<NodePatcher>;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, members: Array<NodePatcher>) {\n    super(node, context, editor);\n    this.members = members;\n  }\n\n  patchAsExpression() {\n    for (let member of this.members) {\n      // If the last token of the arg is a comma, then the actual delimiter must\n      // be a newline and the comma is unnecessary and can cause a syntax error\n      // when combined with other normalize stage transformations. So just\n      // remove the redundant comma.\n      let lastToken = member.lastToken();\n      if (lastToken.type === COMMA) {\n        this.remove(lastToken.start, lastToken.end);\n      }\n      member.patch();\n    }\n  }\n}\n","import PassthroughPatcher from '../../../patchers/PassthroughPatcher.js';\n\nexport default class ObjectInitialiserMemberPatcher extends PassthroughPatcher {\n  key: NodePatcher;\n  expression: NodePatcher;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, key: NodePatcher, expression: NodePatcher) {\n    super(node, context, editor, key, expression);\n    this.key = key;\n    this.expression = expression;\n  }\n}\n","import PassthroughPatcher from '../../../patchers/PassthroughPatcher.js';\nimport determineIndent from '../../../utils/determineIndent.js';\n\nexport default class ProgramPatcher extends PassthroughPatcher {\n  shouldTrimContentRange() {\n    return true;\n  }\n\n  /**\n   * Gets the indent string used for each indent in this program.\n   */\n  getProgramIndentString(): string {\n    if (!this._indentString) {\n      this._indentString = determineIndent(this.context.source);\n    }\n    return this._indentString;\n  }\n}\n","import NodePatcher from '../../../patchers/NodePatcher.js';\nimport type { Node, ParseContext, Editor } from './../../../patchers/types.js';\n\n/**\n * Normalizes `while` loops by rewriting post-`while` into standard `while`, e.g.\n *\n *   a() while b()\n *\n * becomes\n *\n *   while b() then a()\n */\nexport default class WhilePatcher extends NodePatcher {\n  condition: NodePatcher;\n  guard: ?NodePatcher;\n  body: NodePatcher;\n  \n  constructor(node: Node, context: ParseContext, editor: Editor, condition: NodePatcher, guard: ?NodePatcher, body: NodePatcher) {\n    super(node, context, editor);\n    this.condition = condition;\n    this.guard = guard;\n    this.body = body;\n  }\n\n  patchAsExpression() {\n    this.condition.patch();\n    if (this.guard) {\n      this.guard.patch();\n    }\n    if (this.body) {\n      this.body.patch();\n    }\n\n    if (this.isPostWhile()) {\n      this.normalize();\n    }\n  }\n\n  patchAsStatement() {\n    this.patchAsExpression();\n  }\n\n  /**\n   * `BODY 'while' CONDITION ('when' GUARD)?` → `while CONDITION [when GUARD] then BODY`\n   * `BODY 'until' CONDITION ('when' GUARD)?` → `until CONDITION [when GUARD] then BODY`\n   *\n   * @private\n   */\n  normalize() {\n    let patchedCondition = this.slice(\n      this.condition.outerStart,\n      this.condition.outerEnd\n    );\n    let patchedBody = this.slice(\n      this.body.outerStart,\n      this.body.outerEnd\n    );\n    let patchedGuard = this.guard ? this.slice(\n      this.guard.outerStart,\n      this.guard.outerEnd\n    ) : null;\n    let whileToken = this.node.isUntil ? 'until' : 'while';\n    this.overwrite(\n      this.contentStart,\n      this.contentEnd,\n      `${whileToken} ${patchedCondition} ${patchedGuard ? `when ${patchedGuard} ` : ''}then ${patchedBody}`\n    );\n  }\n\n  /**\n   * @private\n   */\n  isPostWhile(): boolean {\n    return this.condition.contentStart > this.body.contentStart;\n  }\n}\n","import PassthroughPatcher from '../../../patchers/PassthroughPatcher.js';\n\nexport default class DefaultParamPatcher extends PassthroughPatcher {\n  param: NodePatcher;\n  value: NodePatcher;\n\n  constructor(node: Node, context: ParseContext, editor: Editor, param: NodePatcher, value: NodePatcher) {\n    super(node, context, editor, param, value);\n    this.param = param;\n    this.value = value;\n  }\n}\n","import PassthroughPatcher from '../../../patchers/PassthroughPatcher.js';\nimport DefaultParamPatcher from './DefaultParamPatcher.js';\nimport ObjectInitialiserMemberPatcher from './ObjectInitialiserMemberPatcher.js';\n\nexport default class MemberAccessOpPatcher extends PassthroughPatcher {\n  shouldTrimContentRange() {\n    return true;\n  }\n\n  patch() {\n    super.patch();\n    let callback = this.findAddStatementCallback();\n    if (callback) {\n      let content = this.slice(this.contentStart, this.contentEnd);\n      this.overwrite(this.contentStart, this.contentEnd, callback(this.node.memberName, content));\n    }\n  }\n\n  findAddStatementCallback() {\n    let patcher = this;\n\n    while (patcher) {\n      if (patcher.addStatementAtScopeHeader) {\n        return patcher.addStatementAtScopeHeader;\n      }\n      // Don't consider this node if we're on the right side of a default param\n      // (e.g. `(foo = @bar) ->`) or if we're on the left side of an object\n      // destructure (e.g. the logical `a` key in `({@a}) ->`).\n      if (patcher.parent instanceof DefaultParamPatcher &&\n          patcher.parent.value === patcher) {\n        break;\n      }\n      if (patcher.parent instanceof ObjectInitialiserMemberPatcher &&\n          patcher.parent.key === patcher) {\n        break;\n      }\n      patcher = patcher.parent;\n    }\n    return null;\n  }\n}\n","import NodePatcher from './../../../patchers/NodePatcher.js';\nimport type { Node, ParseContext, Editor } from './../../../patchers/types.js';\n\nexport default class FunctionPatcher extends NodePatcher {\n  parameters: Array<NodePatcher>;\n  body: ?NodePatcher;\n  \n  constructor(node: Node, context: ParseContext, editor: Editor, parameters: Array<NodePatcher>, body: ?NodePatcher) {\n    super(node, context, editor);\n    this.parameters = parameters;\n    this.body = body;\n  }\n\n  patchAsExpression() {\n    // To avoid knowledge of all the details how assignments can be nested in nodes,\n    // we add a callback to the function node before patching the parameters and remove it afterwards.\n    // This is detected and used by the MemberAccessOpPatcher to claim a free binding for this parameter\n    // (from the functions scope, not the body's scope)\n\n    let assignments = [];\n    this.addStatementAtScopeHeader = (memberName: string) => {\n      let varName = this.claimFreeBinding(memberName);\n      assignments.push(`@${memberName} = ${varName}`);\n      this.log(`Replacing parameter @${memberName} with ${varName}`);\n      return varName;\n    };\n\n    this.parameters.forEach(parameter => parameter.patch());\n\n    delete this.addStatementAtScopeHeader;\n\n    // If there were assignments from parameters insert them\n    if (this.body) {\n      // before the actual body\n      if (assignments.length) {\n        let text;\n        if (this.body.node.inline) {\n          text = `${assignments.join('; ')}; `;\n        } else {\n          let indent = this.body.getIndent(0);\n          text = `${assignments.join(`\\n${indent}`)}\\n${indent}`;\n        }\n        this.insert(this.body.contentStart, `${text}`);\n      }\n      this.body.patch();\n    } else if (assignments.length) {\n      // as the body if there is no body\n      // Add a return statement for non-constructor methods without body to avoid bad implicit return\n      if (this.node.parentNode.type !== 'Constructor') {\n        assignments.push('return');\n      }\n      let indent = this.getIndent(1);\n      let text = assignments.join(`\\n${indent}`);\n      this.insert(this.contentEnd, `\\n${indent}${text}`);\n    }\n  }\n}\n","import ArrayInitialiserPatcher from './patchers/ArrayInitialiserPatcher.js';\nimport BlockPatcher from './patchers/BlockPatcher.js';\nimport ClassPatcher from './patchers/ClassPatcher.js';\nimport AssignOpPatcher from './patchers/AssignOpPatcher.js';\nimport ConditionalPatcher from './patchers/ConditionalPatcher.js';\nimport ForInPatcher from './patchers/ForInPatcher.js';\nimport ForOfPatcher from './patchers/ForOfPatcher.js';\nimport FunctionApplicationPatcher from './patchers/FunctionApplicationPatcher.js';\nimport NodePatcher from '../../patchers/NodePatcher.js';\nimport ObjectInitialiserPatcher from './patchers/ObjectInitialiserPatcher.js';\nimport ObjectInitialiserMemberPatcher from './patchers/ObjectInitialiserMemberPatcher.js';\nimport PassthroughPatcher from '../../patchers/PassthroughPatcher.js';\nimport ProgramPatcher from './patchers/ProgramPatcher.js';\nimport TransformCoffeeScriptStage from '../TransformCoffeeScriptStage.js';\nimport WhilePatcher from './patchers/WhilePatcher.js';\nimport MemberAccessOpPatcher from './patchers/MemberAccessOpPatcher.js';\nimport FunctionPatcher from './patchers/FunctionPatcher.js';\nimport DefaultParamPatcher from './patchers/DefaultParamPatcher.js';\nimport type { Node } from '../../patchers/types.js';\n\nexport default class NormalizeStage extends TransformCoffeeScriptStage {\n  static get outputExtension(): string {\n    return '.coffee';\n  }\n\n  patcherConstructorForNode(node: Node): ?Class<NodePatcher> {\n    switch (node.type) {\n      case 'ArrayInitialiser':\n        return ArrayInitialiserPatcher;\n\n      case 'MemberAccessOp':\n        return MemberAccessOpPatcher;\n\n      case 'Block':\n        return BlockPatcher;\n\n      case 'BoundFunction':\n      case 'Function':\n        return FunctionPatcher;\n\n      case 'Conditional':\n        return ConditionalPatcher;\n\n      case 'ForIn':\n        return ForInPatcher;\n\n      case 'ForOf':\n        return ForOfPatcher;\n\n      case 'FunctionApplication':\n      case 'NewOp':\n      case 'SoakedFunctionApplication':\n        return FunctionApplicationPatcher;\n\n      case 'While':\n        return WhilePatcher;\n\n      case 'Class':\n        return ClassPatcher;\n\n      case 'AssignOp':\n      case 'ClassProtoAssignOp':\n        return AssignOpPatcher;\n\n      case 'Program':\n        return ProgramPatcher;\n\n      case 'DefaultParam':\n        return DefaultParamPatcher;\n\n      case 'ObjectInitialiser':\n        return ObjectInitialiserPatcher;\n\n      case 'ObjectInitialiserMember':\n        return ObjectInitialiserMemberPatcher;\n      \n      default:\n        return PassthroughPatcher;\n    }\n  }\n}\n","/**\n * Convert the given code to use the specified newline string, either '\\n' or\n * '\\r\\n'.\n *\n * @flow\n */\nexport default function convertNewlines(source: string, newlineStr: string): string {\n  if (newlineStr === '\\n') {\n    return source.replace(/\\r\\n/g, '\\n');\n  } else if (newlineStr === '\\r\\n') {\n    source = source.replace(/\\r\\n/g, '\\n');\n    return source.replace(/\\n/g, '\\r\\n');\n  } else {\n    throw new Error(`Unexpected newling string to convert to: ${JSON.stringify(newlineStr)}`);\n  }\n}\n","/**\n * Determine the most common newline string in the given code, either '\\n' or\n * '\\r\\n'. Prefer '\\n' in the case of a tie.\n *\n * @flow\n */\nexport default function detectNewlineStr(source: string): string {\n  let numLFs = 0;\n  let numCRLFs = 0;\n  for (let i = 0; i < source.length; i++) {\n    if (source[i] === '\\n' && (i === 0 || source[i - 1] !== '\\r')) {\n      numLFs++;\n    }\n    if (source.slice(i, i + 2) === '\\r\\n') {\n      numCRLFs++;\n    }\n  }\n  return numCRLFs > numLFs ? '\\r\\n' : '\\n';\n}\n","/**\n * Display a range of code, e.g. for a token or an AST node.\n *\n * The line and column are displayed as 1-indexed, to agree with most editors,\n * and the actual 0-indexed code index is also displayed.\n *\n * For example, if a program is just \"foo\", then the \"foo\" token has this range:\n * [1:1(0)-1:4(3)]\n */\nexport default function formatRange(startIndex: number, endIndex: number, context) {\n  return `[${formatIndex(startIndex, context)}-${formatIndex(endIndex, context)}]`;\n}\n\nfunction formatIndex(index: number, context) {\n  if (index > context.source.length) {\n    index = context.source.length;\n  }\n  let {line, column} = context.linesAndColumns.locationForIndex(index);\n  return `${line + 1}:${column + 1}(${index})`;\n}\n","import formatRange from './formatRange.js';\n\nexport default function formatCoffeeLexTokens(context): string {\n  let tokens = context.sourceTokens;\n  let resultLines = tokens.map(token =>\n    `${formatRange(token.start, token.end, context)}: ${token.type.name}`\n  );\n  return resultLines.map(line => line + '\\n').join('');\n}\n","import formatRange from './formatRange.js';\n\nexport default function formatCoffeeScriptLocationData(locationData, context) {\n  let {first_line, first_column, last_line, last_column} = locationData;\n  let firstIndex = context.linesAndColumns.indexForLocation({line: first_line, column: first_column});\n  let lastIndex = context.linesAndColumns.indexForLocation({line: last_line, column: last_column}) + 1;\n  return formatRange(firstIndex, lastIndex, context);\n}\n","import formatCoffeeScriptLocationData from './formatCoffeeScriptLocationData.js';\n\nexport default function formatCoffeeScriptAst(context): string {\n  let resultLines = formatAstNodeLines(context.ast, context);\n  return resultLines.map(line => line + '\\n').join('');\n}\n\nfunction formatAstNodeLines(node, context) {\n  let propLines = [];\n  let blacklistedProps = ['locationData'];\n  // Show the non-node children first.\n  for (let key of Object.keys(node)) {\n    let value = node[key];\n    if (shouldTraverse(value) || blacklistedProps.indexOf(key) !== -1) {\n      continue;\n    }\n    let valueText;\n    try {\n      valueText = JSON.stringify(value);\n    } catch (e) {\n      valueText = '(error)';\n    }\n    propLines.push(`${key}: ${valueText}`);\n  }\n\n  // Then show the node children.\n  for (let key of Object.keys(node)) {\n    let value = node[key];\n    if (!shouldTraverse(value)) {\n      continue;\n    }\n\n    if (Array.isArray(value) && value.length === 0) {\n      propLines.push(`${key}: []`);\n    } else if (Array.isArray(value)) {\n      propLines.push(`${key}: [`);\n      for (let child of value) {\n        propLines.push(...formatAstNodeLines(child, context).map(s => '  ' + s));\n      }\n      propLines.push(`]`);\n    } else {\n      let childLines = formatAstNodeLines(value, context);\n      childLines[0] = `${key}: ${childLines[0]}`;\n      propLines.push(...childLines);\n    }\n  }\n  return [\n    `${node.constructor.name} ${formatCoffeeScriptLocationData(node.locationData, context)} {`,\n    ...propLines.map(s => '  ' + s),\n    '}',\n  ];\n}\n\nfunction shouldTraverse(value) {\n  if (Array.isArray(value)) {\n    return value.length === 0 || isNode(value[0]);\n  }\n  return isNode(value);\n}\n\n/**\n * CoffeeScript AST nodes are always instances of a custom class, so use the\n * constructor name to distinguish between node children and non-node children.\n */\nfunction isNode(value) {\n  if (!value) {\n    return false;\n  }\n  return ['String', 'Number', 'Boolean', 'Array', 'Object'].indexOf(value.constructor.name) === -1;\n}\n","import formatCoffeeScriptLocationData from './formatCoffeeScriptLocationData.js';\n\nexport default function formatCoffeeScriptLexerTokens(tokens, context): string {\n  let resultLines = tokens.map(([tag, value, locationData]) =>\n    `${formatCoffeeScriptLocationData(locationData, context)}: ${tag}: ${JSON.stringify(value)}`\n  );\n  return resultLines.map(line => line + '\\n').join('');\n}\n","import formatRange from './formatRange.js';\nimport {childPropertyNames} from './traverse.js';\n\nexport default function formatDecaffeinateParserAst(ast): string {\n  let resultLines = formatAstNodeLines(ast, ast.context);\n  return resultLines.map(line => line + '\\n').join('');\n}\n\nfunction formatAstNodeLines(node, context) {\n  let propLines = [];\n  let childPropNames = childPropertyNames(node);\n  let blacklistedProps = childPropNames.concat(\n    ['raw', 'line', 'column', 'type', 'range', 'virtual', 'scope', 'parentNode', 'context']\n  );\n  for (let key of Object.keys(node)) {\n    if (blacklistedProps.indexOf(key) !== -1) {\n      continue;\n    }\n    let valueText;\n    try {\n      valueText = JSON.stringify(node[key]);\n    } catch (e) {\n      valueText = '(error)';\n    }\n    propLines.push(`${key}: ${valueText}`);\n  }\n\n  for (let childProp of childPropNames) {\n    let value = node[childProp];\n    if (value === null) {\n      propLines.push(`${childProp}: null`);\n    } else if (Array.isArray(value) && value.length === 0) {\n      propLines.push(`${childProp}: []`);\n    } else if (Array.isArray(value)) {\n      propLines.push(`${childProp}: [`);\n      for (let child of value) {\n        propLines.push(...formatAstNodeLines(child, context).map(s => '  ' + s));\n      }\n      propLines.push(`]`);\n    } else {\n      let childLines = formatAstNodeLines(value, context);\n      childLines[0] = `${childProp}: ${childLines[0]}`;\n      propLines.push(...childLines);\n    }\n  }\n  let rangeStr;\n  if (node.virtual) {\n    rangeStr = '(virtual)';\n  } else {\n    rangeStr = formatRange(node.range[0], node.range[1], context);\n  }\n  return [\n    `${node.type} ${rangeStr} {`,\n    ...propLines.map(s => '  ' + s),\n    '}',\n  ];\n}\n","/* @flow */\nimport LinesAndColumns from 'lines-and-columns';\nimport PatchError from './PatchError.js';\n\n/**\n * If the given exception is an error with code location information, extract\n * its start and end position and return a PatchError to use in its place.\n * Otherwise, return null.\n */\nexport default function resolveToPatchError(err: any, content: string , stageName: string): ?PatchError {\n  let makePatchError = (start, end, source) => new PatchError(\n    `${stageName} failed to parse: ${err.message}`,\n    source,\n    start,\n    end\n  );\n\n  if (err.pos) {\n    // Handle JavaScript parse errors.\n    let { pos } = err;\n    if (pos === content.length) {\n      pos--;\n    }\n    // In most cases, we can use the source code we already have, but for\n    // esnext, the code might be an intermediate code state, so use that from\n    // the exception if possible.\n    let source = err.source || content;\n    return makePatchError(pos, pos + 1, source);\n  } else if (err.syntaxError) {\n    // Handle CoffeeScript parse errors.\n    let { first_line, first_column, last_line, last_column } = err.syntaxError.location;\n    let lineMap = new LinesAndColumns(content);\n    let firstIndex = lineMap.indexForLocation({line: first_line, column: first_column});\n    let lastIndex = lineMap.indexForLocation({line: last_line, column: last_column}) + 1;\n    if (firstIndex !== null && firstIndex !== undefined && lastIndex !== null && lastIndex !== undefined) {\n      return makePatchError(firstIndex, lastIndex, content);\n    }\n  }\n  return null;\n}\n","/* @flow */\n/* eslint-disable no-process-exit */\n\nimport PatchError from './utils/PatchError.js';\nimport type { Readable, Writable } from 'stream';\nimport type { WriteStream } from 'tty';\nimport { convert } from './index.js';\nimport { join, dirname, basename, extname } from 'path';\nimport { stat, readdir, createReadStream, createWriteStream } from 'fs';\n\n/**\n * Run the script with the user-supplied arguments.\n */\nexport default function run(args: Array<string>) {\n  let options = parseArguments(args);\n\n  if (options.paths.length) {\n    runWithPaths(options.paths);\n  } else {\n    runWithStream('stdin', process.stdin, process.stdout);\n  }\n}\n\ntype Options = {\n  paths: Array<string>\n};\n\nfunction parseArguments(args: Array<string>): Options {\n  let paths = [];\n\n  for (let i = 0; i < args.length; i++) {\n    let arg = args[i];\n    switch (arg) {\n      case '-h':\n      case '--help':\n        usage();\n        process.exit(0);\n        break;\n\n      default:\n        paths.push(arg);\n        break;\n    }\n  }\n\n  return { paths };\n}\n\n/**\n * Run decaffeinate on the given paths, changing them in place.\n */\nfunction runWithPaths(paths: Array<string>, callback: ?((errors: Array<Error>) => void)=null) {\n  let errors = [];\n  let pending = paths.slice();\n\n  function processPath(path: string) {\n    stat(path, (err, info) => {\n      if (err) { errors.push(err); }\n      else if (info.isDirectory()) {\n        processDirectory(path);\n      } else {\n        processFile(path);\n      }\n    });\n  }\n\n  function processDirectory(path: string) {\n    readdir(path, (err, children) => {\n      if (err) { errors.push(err); }\n      else {\n        pending.unshift(\n          ...children\n            .filter(child => extname(child) === '.coffee')\n            .map(child => join(path, child))\n        );\n      }\n      processNext();\n    });\n  }\n\n  function processFile(path: string) {\n    let outputPath = join(dirname(path), basename(path, extname(path))) + '.js';\n    console.log(`${path} → ${outputPath}`);\n    runWithStream(\n      path,\n      createReadStream(path, { encoding: 'utf8' }),\n      createWriteStream(outputPath, { encoding: 'utf8' }),\n      err => {\n        if (err) { errors.push(err); }\n        processNext();\n      }\n    );\n  }\n\n  function processNext() {\n    if (pending.length > 0) {\n      processPath(pending.shift());\n    } else if (callback) {\n      callback(errors);\n    }\n  }\n\n  processNext();\n}\n\n/**\n * Run decaffeinate reading from input and writing to corresponding output.\n */\nfunction runWithStream(name: string, input: Readable, output: Writable | WriteStream, callback: ?((error?: ?Error) => void) = null) {\n  let error = null;\n  let data = '';\n\n  input.setEncoding('utf8');\n\n  input.on('data', chunk => data += chunk);\n\n  input.on('end', () => {\n    let converted;\n    try {\n      converted = convert(data);\n    } catch (err) {\n      if (PatchError.detect(err)) {\n        console.error(`${name}: ${PatchError.prettyPrint(err)}`);\n        process.exit(1);\n      } else {\n        throw err;\n      }\n    }\n    if (converted) {\n      let { code } = converted;\n      output.end(code, () => {\n        if (callback) {\n          callback(error);\n        }\n      });\n    }\n  });\n\n  output.on('error', err => error = err);\n}\n\n/**\n * Print usage help.\n */\nfunction usage() {\n  let exe = basename(process.argv[1]);\n  console.log('%s [OPTIONS] PATH [PATH …]', exe);\n  console.log('%s [OPTIONS] < INPUT', exe);\n  console.log();\n  console.log('Move your CoffeeScript source to JavaScript using modern syntax.');\n  console.log();\n  console.log('OPTIONS');\n  console.log();\n  console.log('  -h, --help     Display this help message.');\n  console.log();\n  console.log('EXAMPLES');\n  console.log();\n  console.log('  # Convert a .coffee file to a .js file.');\n  console.log('  $ decaffeinate index.coffee');\n  console.log();\n  console.log('  # Pipe an example from the command-line.');\n  console.log('  $ echo \"a = 1\" | decaffeinate');\n  console.log();\n  console.log('  # On OS X this may come in handy:');\n  console.log('  $ pbpaste | decaffeinate | pbcopy');\n  console.log();\n  console.log('  # Process everything in a directory.');\n  console.log('  $ decaffeinate src/');\n  console.log();\n  console.log('  # Redirect input from a file.');\n  console.log('  $ decaffeinate < index.coffee');\n}\n","import { tokens } from 'decaffeinate-coffeescript';\nimport AddVariableDeclarationsStage from './stages/add-variable-declarations/index.js';\nimport SemicolonsStage from './stages/semicolons/index.js';\nimport EsnextStage from './stages/esnext/index.js';\nimport MainStage from './stages/main/index.js';\nimport NormalizeStage from './stages/normalize/index.js';\nimport convertNewlines from './utils/convertNewlines.js';\nimport detectNewlineStr from './utils/detectNewlineStr.js';\nimport formatCoffeeLexAst from './utils/formatCoffeeLexTokens.js';\nimport formatCoffeeScriptAst from './utils/formatCoffeeScriptAst.js';\nimport formatCoffeeScriptLexerTokens from './utils/formatCoffeeScriptLexerTokens.js';\nimport formatDecaffeinateParserAst from './utils/formatDecaffeinateParserAst.js';\nimport parse from './utils/parse.js';\nimport PatchError from './utils/PatchError.js';\nimport resolveToPatchError from './utils/resolveToPatchError.js';\n\nexport { default as run } from './cli';\nexport { PatchError };\n\ntype Options = {\n  filename: ?string,\n  runToStage: ?string,\n};\n\ntype ConversionResult = {\n  code: string,\n  maps: Array<Object>\n};\n\ntype Stage = {\n  name: string;\n  run: (content: string, filename: string) => { code: string, map: Object }\n};\n\n/**\n * Convert CoffeeScript source code into modern JavaScript preserving comments\n * and formatting.\n */\nexport function convert(source: string, options: ?Options={}): ConversionResult {\n  let originalNewlineStr = detectNewlineStr(source);\n  source = convertNewlines(source, '\\n');\n  let stages = [\n    NormalizeStage,\n    MainStage,\n    AddVariableDeclarationsStage,\n    SemicolonsStage,\n    EsnextStage\n  ];\n  let runToStage = options.runToStage;\n  if (runToStage !== null && runToStage !== undefined) {\n    let stageIndex = stages.findIndex(stage => stage.name === runToStage);\n    if (stageIndex !== -1) {\n      stages = stages.slice(0, stageIndex + 1);\n    } else {\n      return convertCustomStage(source, runToStage);\n    }\n  }\n  let result = runStages(source, options.filename || 'input.coffee', stages);\n  result.code = convertNewlines(result.code, originalNewlineStr);\n  return result;\n}\n\nfunction runStages(initialContent: string, initialFilename: string, stages: Array<Stage>): ConversionResult {\n  let maps = [];\n  let content = initialContent;\n  let filename = initialFilename;\n  stages.forEach(stage => {\n    let { code, map } = runStage(stage, content, filename);\n    if (code !== content) {\n      maps.push(map);\n      content = code;\n      filename = map.file;\n    }\n  });\n  return { code: content, maps };\n}\n\nfunction runStage(stage: Stage, content: string, filename: string): { code: string, map: Object } {\n  try {\n    return stage.run(content, filename);\n  } catch (err) {\n    let patchError = resolveToPatchError(err, content, stage.name);\n    if (patchError !== null) {\n      throw patchError;\n    }\n    throw err;\n  }\n}\n\nfunction convertCustomStage(source: string, stageName: string): ConversionResult {\n  let ast = parse(source);\n  if (stageName === 'coffeescript-lexer') {\n    return {\n      code: formatCoffeeScriptLexerTokens(tokens(source), ast.context),\n      maps: [],\n    };\n  } else if (stageName === 'coffeescript-parser') {\n    return {\n      code: formatCoffeeScriptAst(ast.context),\n      maps: [],\n    };\n  } else if (stageName === 'coffee-lex') {\n    return {\n      code: formatCoffeeLexAst(ast.context),\n      maps: [],\n    };\n  } else if (stageName === 'decaffeinate-parser') {\n    return {\n      code: formatDecaffeinateParserAst(ast),\n      maps: [],\n    };\n  } else {\n    throw new Error(`Unrecognized stage name: ${stageName}`);\n  }\n}\n"],"names":["logger","name","isLoggingEnabled","args","log","process","env","AddVariableDeclarationsStage","content","filename","editor","MagicString","toString","generateMap","basename","BABYLON_PLUGINS","SemicolonsStage","ast","parse","sourceType","plugins","config","buildConfig","insertions","forEach","index","appendLeft","removals","start","end","remove","EsnextStage","convert","node","parent","type","declarations","length","id","test","code","map","printTable","table","buffer","widths","rows","cell","i","output","column","columns","align","repeat","row","PatchError","message","source","error","Error","lineMap","LinesAndColumns","startLoc","locationForIndex","endLoc","displayStartLine","Math","max","line","displayEndLine","startOfLine","indexForLocation","endOfLine","lineSource","trimRight","slice","push","highlightLength","string","replace","DEFAULT_INDENT","determineIndent","indent","detectIndent","amount","getStartOfLine","offset","lfIndex","lastIndexOf","getIndent","indentOffset","indentCharacter","adjustIndent","adjustment","currentIndent","determinedIndent","isFunction","allowBound","isCall","NON_SEMANTIC_SOURCE_TOKEN_TYPES","COMMENT","HERECOMMENT","NEWLINE","isSemanticToken","token","indexOf","NodePatcher","context","adjustedIndentLevel","constructor","withPrettyErrors","setupLocationInformation","virtual","contentStart","range","contentEnd","shouldTrimContentRange","trimContentRange","tokens","sourceTokens","firstSourceTokenIndex","indexOfTokenStartingAtSourceIndex","lastSourceTokenIndex","indexOfTokenEndingAtSourceIndex","contentStartTokenIndex","contentEndTokenIndex","outerStartTokenIndex","outerEndTokenIndex","innerStartTokenIndex","innerEndTokenIndex","previousSurroundingTokenIndex","lastIndexOfTokenMatchingPredicate","previous","nextSurroundingTokenIndex","indexOfTokenMatchingPredicate","next","previousSurroundingToken","tokenAtIndex","nextSurroundingToken","LPAREN","CALL_START","RPAREN","CALL_END","innerStart","innerEnd","outerStart","outerEnd","startChar","lastChar","options","forcedToPatchAsExpression","patchAsForcedExpression","willPatchAsExpression","patchAsExpression","patchAsStatement","sliceStart","beforeCode","patch","startIndex","substr","body","err","PatcherError","detect","addParens","statementShouldAddParens","insert","JSON","stringify","adjustBoundsToInclude","boundingPatcher","getBoundingPatcher","isNodeFunctionApplication","allowPatchingOuterBounds","getEditingBounds","isIndexEditable","assertEditableIndex","overwrite","move","setExpression","force","canPatchAsExpression","prefersToPatchAsExpression","_expression","_implicitlyReturns","implicitReturnPatcher","patcher","setRequiresExpression","implicitReturnWillBreak","_returns","setExplicitlyReturns","statementNeedsParens","isSurroundedByParentheses","getProgramSourceTokens","left","right","predicate","indexOfSourceTokenBetweenSourceIndicesMatching","sourceTokenAtIndex","getOriginalSource","indexOfSourceTokenAfterSourceTokenIndex","beforeToken","afterToken","leftTokenType","rightTokenType","parenRange","rangeOfMatchingTokensContainingTokenIndex","rparenIndex","rparen","arguments","some","arg","getAdjustedIndentLevel","indentStr","indentLength","getProgramIndentString","currentIndentLevel","desiredIndentLevel","indentString","indentToChange","abs","hasIndentedThisLine","getEndOfLine","min","patcherError","stack","registerHelper","parens","ref","isRepeatable","claimFreeBinding","scope","receiver","yieldController","ArrayInitialiserPatcher","members","member","isLast","needsComma","hasSourceTokenAfter","COMMA","ExpansionPatcher","AssignOpPatcher","assignee","expression","isExpansionAssignment","patchExpansionAssignment","expansionAssignmentNeedsParens","expansionIndex","getExpansionIndex","assignees","expansionNode","expressionCode","assigneeBeforeExpansion","arrReference","key","BinaryOpPatcher","needsParens","getOperator","patchOperator","sourceOfToken","getOperatorToken","operatorTokenIndex","indexOfSourceTokenBetweenPatchersMatching","operatorTokenPredicate","OPERATOR","EXISTENCE","FunctionApplicationPatcher","fn","commaTokenIndex","compare","commaToken","FunctionPatcher","parameters","implicitReturnsDisabled","setImplicitlyReturns","param","method","patchFunctionStart","parameter","patchFunctionBody","arrow","getArrowToken","hasParamStart","leftBrace","rightBrace","inline","closeParenIndex","closeParen","arrowIndex","FUNCTION","expectedArrowType","actualArrowType","_implicitReturnsDisabled","ReturnPatcher","BlockPatcher","statements","shouldPatchInline","every","statement","removeStart","startOfLineIndex","SEMICOLON","hasImplicitReturn","implicitlyReturns","explicitlyReturns","patchImplicitReturnStart","patchImplicitReturnEnd","statementNeedsSemicolon","appendLineAfter","semicolonTokenIndex","getSemicolonSourceTokenBetween","semicolonToken","separator","lastStatement","terminatorTokenIndex","insertionPoint","statementToInsertBefore","insertIndex","allCodePathsPresent","BoolPatcher","PassthroughPatcher","children","Array","isArray","child","IdentifierPatcher","data","ManuallyBoundFunctionPatcher","MemberAccessOpPatcher","_skipImplicitDotCreation","lhsNeedsParens","isShorthandPrototype","operator","getMemberOperatorSourceToken","hasImplicitOperator","PROTO","lastIndex","lastToken","dotIndex","DOT","firstIndex","firstToken","AT","memberName","getMemberName","IDENTIFIER","isBefore","makeRepeatable","getFullMemberName","BoundGeneratorFunctionPatcher","GeneratorFunctionPatcher","escape","skipPattern","escapeStrings","original","str","appendRight","InterpolatedPatcher","quasis","expressions","interpolationStart","getInterpolationStartTokenAtIndex","interpolationStartIndex","INTERPOLATION_START","quasi","toArray","STRING_PADDING","paddingCode","numNewlines","match","STRING_LINE_SEPARATOR","StringPatcher","shouldBecomeTemplateLiteral","openQuoteToken","closeQuoteToken","TSSTRING_START","TDSTRING_START","patchInterpolations","removePadding","escapeQuasis","raw","ObjectBodyMemberPatcher","isMethod","patchAsMethod","patchAsProperty","isGeneratorMethod","isComputed","isMethodNameComputed","patchKey","patchExpression","computedKeyPatcher","getComputedKeyPatcher","needsBrackets","BoundFunctionPatcher","ThisPatcher","isShorthandThis","ObjectInitialiserMemberPatcher","patchAsShorthand","expand","memberAccessKey","valueCode","patchAndGetCode","ObjectInitialiserPatcher","implicitObject","isImplicitObject","curlyBraceInsertionPosition","textToInsert","shouldIndent","shouldExpandCurlyBraces","tokenIndexBeforeOuterStartTokenIndex","precedingTokenIndex","precedingToken","precedingTokenText","lastCharOfToken","needsSpace","patchMembers","needsParentheses","isMultiline","indexOfFirstToken","LBRACE","isObjectInitialiserBlock","traverse","callback","descended","descend","value","property","parentNode","shouldDescend","childPropertyNames","ORDER","names","hasInlineBody","parameterListNeedsParentheses","willPatchBodyInline","surroundInParens","referencesArguments","ChainedComparisonOpPatcher","negated","getMiddleOperands","middleAgain","middle","result","comparison","unshift","negate","ClassBoundMethodFunctionPatcher","ClassAssignOpPatcher","isStaticMethod","memberNameToken","getMemberNameSourceToken","colonIndex","COLON","colonToken","memberObject","className","nameAssignee","ConstructorPatcher","disableImplicitReturns","boundMethods","boundInstanceMethods","indexOfSuperStatement","callsSuper","bindings","insertStatementsAtIndex","ClassBlockPatcher","hasConstructor","methodIndent","methodBodyIndent","getClassPatcher","isSubclass","filter","isBoundInstanceMethod","ClassPatcher","superclass","hasParens","anonymous","isAnonymous","isNamespaced","classToken","getClassToken","getName","getBraceInsertionOffset","classSourceToken","CLASS","CompoundAssignOpPatcher","operatorIndex","ConditionalPatcher","condition","consequent","alternate","willPatchAsTernary","isUnless","thenTokenIndex","getThenTokenIndex","thenToken","elseTokenIndex","getElseSourceTokenIndex","elseToken","willPatchAsIIFE","patchAsIIFE","baseIndent","conditionIndent","setShouldPatchInline","patchConditionForStatement","patchConsequentForStatement","patchAlternateForStatement","ifToken","getIfSourceTokenIndex","conditionHasParentheses","rightBracePosition","isElseIf","IF","leftBracePosition","ifTokenIndex","indexOfSourceTokenStartingAtSourceIndex","ELSE","THEN","DefaultParamPatcher","DoOpPatcher","doTokenIndex","getDoTokenIndex","doToken","nextToken","valueSource","getPatchedSource","join","DO","DynamicMemberAccessOpPatcher","indexingExpr","EqualityPatcher","compareToken","getCompareToken","getCompareOperator","compareTokenIndex","ExpOpPatcher","ExistsOpCompoundAssignOpPatcher","assigneeAgain","needsTypeofCheck","hasBinding","lhsHasSoakOperation","foundSoak","ExistsOpPatcher","leftAgain","EXTENDS_HELPER","ExtendsOpPatcher","helper","FloorDivideOpPatcher","LoopPatcher","iifeBodyIndent","getLoopIndent","setIndent","getLoopBodyIndent","resultBinding","getResultArrayBinding","prefix","yielding","suffix","yields","loopHeaderEndIndex","shouldConvertInlineBodyToNonInline","allBodyCodePathsPresent","itemBinding","getResultArrayElementBinding","_allBodyCodePathsPresent","undefined","_resultArrayBinding","_resultArrayElementBinding","ForPatcher","keyAssignee","valAssignee","target","_filterCode","getOuterLoopBodyIndent","insertLineBefore","getFilterCode","patchBodyWithPossibleItemVariable","insertLineAfter","tokenIndex","RELATION","_indexBinding","computeIndexBinding","indexBindingCandidates","getTargetReference","_targetReference","requiresExtractingTarget","targetBindingCandidate","RANGE_HELPER","MAXIMUM_LITERAL_RANGE_ELEMENTS","RangePatcher","canBecomeLiteralArray","patchAsLiteralArray","inclusive","isInclusive","ascending","list","getLiteralRange","first","last","UP","DOWN","UNKNOWN","ForInPatcher","step","canPatchAsMapExpression","removeThenToken","assigneeCode","getValueBinding","getIndexBinding","patchBodyForExpressionLoop","bodyNeedsParens","insertPoint","shouldPatchAsForOf","patchForOfLoop","patchForLoopHeader","patchForLoopBody","shouldPatchAsInitTestUpdateLoop","_valueBinding","getTargetCode","firstHeaderPatcher","lastHeaderPatcher","getLastHeaderPatcher","getInitCode","getTestCode","getUpdateCode","reduce","patchPossibleNewlineAfterLoopHeader","valueAssignment","patchBodyAndFilter","relationToken","getRelationToken","valueBinding","getStep","isLiteral","update","init","direction","getIndexDirection","indexBinding","number","_step","Step","hasFixedRange","hasDynamicRange","hasExplicitStep","isVirtual","root","apply","ForOfPatcher","removeOwnTokenIfExists","shouldExtractTarget","keyBinding","targetReference","valAssigneeString","isOwn","ownIndex","OWN","ownToken","CLOSE_TOKEN_BASE_LENGTH","HeregexPatcher","openToken","closeToken","InOpPatcher","isNot","arrayNeedsParens","leftCode","NegatableBinaryOpPatcher","javaScriptOperator","InstanceofOpPatcher","JavaScriptPatcher","UnaryOpPatcher","LogicalNotOpPatcher","canHandleNegationInternally","LogicalOpCompoundAssignOpPatcher","isOrOp","op","LogicalOpPatcher","operatorToken","MOD_HELPER","ModuloOpPatcher","NewOpPatcher","OfOpPatcher","blank","Object","create","BLOCK_COMMENT_DELIMITER","ProgramPatcher","helpers","_indentString","patchContinuations","patchComments","append","CONTINUATION","patchShebangComment","patchLineComment","patchBlockComment","comment","atStartOfLine","lastStartOfLine","lineUpAsterisks","expectedIndent","leadingHashIndexes","commentBody","coffeeIndex","trim","ProtoMemberAccessOpPatcher","RegExpPatcher","SpreadPatcher","RestPatcher","SeqOpPatcher","SlicePatcher","indexStart","getIndexStartSourceToken","getSliceSourceToken","indexEnd","getIndexEndSourceToken","LBRACKET","isAfter","RANGE","RBRACKET","GUARD_HELPER","SoakedMemberAccessOpPatcher","_shouldSkipSoakPatch","soakContainer","findSoakContainer","varName","GUARD_FUNC_HELPER","GUARD_METHOD_HELPER","SoakedFunctionApplicationPatcher","patchMethodCall","patchDynamicMethodCall","patchNonMethodCall","setSkipImplicitDotCreation","setShouldSkipSoakPatch","callStartToken","getCallStartToken","SoakedDynamicMemberAccessOpPatcher","objVarName","methodVarName","canParentHandleSoak","SuperPatcher","getContainingMethodName","SwitchCasePatcher","conditions","whenToken","getWhenToken","getCommaTokens","comma","getThenToken","hasBreak","getBreakToken","shouldAddBreak","WHEN","commaIndex","BREAK","SwitchPatcher","cases","casePatcher","switchToken","getSwitchToken","overwriteElse","appendToEndOfLine","getElseToken","SWITCH","switchCase","ThrowPatcher","throwToken","THROW","spacing","nativeFind","array","iterator","find","element","call","prototype","flatMap","memo","item","concat","leftHandIdentifiers","Scope","getBinding","getOwnPropertyNames","unkey","declares","binding","counter","assigns","identifier","parts","getOwnNames","getBindingsForNode","decaffeinateParse","attachScope","processNode","TransformCoffeeScriptStage","stage","build","inputExtension","outputExtension","patchers","patcherForNode","initialize","_patcherConstructorForNode","override","patcherClassForChildNode","associateParent","patcherConstructorForNode","props","patcherClassOverrideForNode","TryPatcher","catchAssignee","catchBody","finallyBody","tryToken","getTryToken","catchToken","getCatchToken","finallyToken","getFinallyToken","afterCatchHeader","addErrorParens","getErrorBinding","tryTokenIndex","TRY","searchEnd","catchTokenIndex","CATCH","searchStart","finallyTokenIndex","FINALLY","_errorBinding","UnaryExistsOpPatcher","UnaryMathOpPatcher","UnaryTypeofOpPatcher","WhilePatcher","guard","whileToken","getWhileTokenIndex","isLoop","LOOP","conditionNeedsParens","isUntil","guardNeedsParens","thenIndex","whileTokenIndex","WHILE","nextTokenIndex","YieldPatcher","YieldFromPatcher","src","MainStage","blockIndentLength","getIndentLength","charsToRemove","indentText","getInitClassInsertPoint","nonMethodPatchers","getNonMethodPatchers","assignmentNames","generateInitClassMethod","assignmentName","initialDeleteStart","deleteStart","isClassMethod","isClassAssignment","bodyIndent","getAssignmentName","statementCode","getNonMethodStatementCode","statementPatcher","prefixCode","keyCode","suffixCode","equalIndex","isPostIf","patchPostIf","getIfTokenIndex","consequentCode","isPostFor","normalize","forToken","getForToken","forThroughEnd","startUntilFor","afterForToken","getFirstHeaderPatcher","FOR","candidates","candidate","implicitCall","isImplicitCall","isImplicitSuper","firstArg","hasOneArg","firstArgIsOnNextLine","funcEnd","getFuncEnd","insertImplicitCloseParen","argListCode","isArgListMultiline","lastTokenType","RBRACE","followingCloseParen","getFollowingCloseParenIfExists","lastArg","questionMarkTokenIndex","questionMarkToken","isPostWhile","patchedCondition","patchedBody","patchedGuard","findAddStatementCallback","addStatementAtScopeHeader","assignments","text","NormalizeStage","convertNewlines","newlineStr","detectNewlineStr","numLFs","numCRLFs","formatRange","endIndex","formatIndex","linesAndColumns","formatCoffeeLexTokens","resultLines","formatCoffeeScriptLocationData","locationData","first_line","first_column","last_line","last_column","formatCoffeeScriptAst","formatAstNodeLines","propLines","blacklistedProps","keys","shouldTraverse","valueText","e","s","childLines","isNode","formatCoffeeScriptLexerTokens","tag","formatDecaffeinateParserAst","childPropNames","childProp","rangeStr","resolveToPatchError","stageName","makePatchError","pos","syntaxError","location","run","parseArguments","paths","stdin","stdout","exit","runWithPaths","errors","pending","processPath","path","info","isDirectory","processDirectory","extname","processFile","outputPath","dirname","createReadStream","encoding","createWriteStream","processNext","shift","runWithStream","input","setEncoding","on","chunk","converted","prettyPrint","usage","exe","argv","originalNewlineStr","stages","runToStage","stageIndex","findIndex","convertCustomStage","runStages","initialContent","initialFilename","maps","runStage","file","patchError","formatCoffeeLexAst"],"mappings":"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"}