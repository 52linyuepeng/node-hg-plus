'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var decaffeinateCoffeescript = require('decaffeinate-coffeescript');
var addVariableDeclarations = _interopDefault(require('add-variable-declarations'));
var MagicString = _interopDefault(require('magic-string'));
var path = require('path');
var asi = _interopDefault(require('automatic-semicolon-insertion'));
var buildConfig = _interopDefault(require('ast-processor-babylon-config'));
var babylon = require('babylon');
var esnext = require('esnext');
var LinesAndColumns = _interopDefault(require('lines-and-columns'));
var repeat = _interopDefault(require('repeating'));
var detectIndent = _interopDefault(require('detect-indent'));
var coffeeLex = require('coffee-lex');
var util = require('util');
var decaffeinateParser = require('decaffeinate-parser');
var fs = require('fs');

function logger(name) {
  if (isLoggingEnabled(name)) {
    return function () {
      var _console;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (_console = console).log.apply(_console, [name].concat(args));
    };
  } else {
    return function () {};
  }
}

function isLoggingEnabled(name) {
  return !!process.env['DEBUG:' + name] || !!process.env['DEBUG:*'];
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



var set = function set(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var AddVariableDeclarationsStage = function () {
  function AddVariableDeclarationsStage() {
    classCallCheck(this, AddVariableDeclarationsStage);
  }

  createClass(AddVariableDeclarationsStage, null, [{
    key: 'run',
    value: function run(content, filename) {
      var log = logger(this.name);
      log(content);

      var editor = new MagicString(content);
      addVariableDeclarations(content, editor);
      return {
        code: editor.toString(),
        map: editor.generateMap({
          source: filename,
          file: path.basename(filename, '.js') + '-' + this.name + '.js',
          includeContent: true
        })
      };
    }
  }]);
  return AddVariableDeclarationsStage;
}();

var BABYLON_PLUGINS = ['flow', 'jsx', 'asyncFunctions', 'asyncGenerators', 'classConstructorCall', 'classProperties', 'decorators', 'doExpressions', 'exponentiationOperator', 'exportExtensions', 'functionBind', 'functionSent', 'objectRestSpread', 'trailingFunctionCommas'];

var SemicolonsStage = function () {
  function SemicolonsStage() {
    classCallCheck(this, SemicolonsStage);
  }

  createClass(SemicolonsStage, null, [{
    key: 'run',
    value: function run(content, filename) {
      var log = logger(this.name);
      log(content);

      var editor = new MagicString(content);
      var ast = babylon.parse(content, { sourceType: 'module', plugins: BABYLON_PLUGINS });
      var config = buildConfig(content, ast);

      asi(config);

      config.insertions.forEach(function (_ref) {
        var index = _ref.index;
        var content = _ref.content;
        return editor.appendLeft(index, content);
      });
      config.removals.forEach(function (_ref2) {
        var start = _ref2.start;
        var end = _ref2.end;
        return editor.remove(start, end);
      });

      return {
        code: editor.toString(),
        map: editor.generateMap({
          source: filename,
          file: path.basename(filename, '.js') + '-' + this.name + '.js',
          includeContent: true
        })
      };
    }
  }]);
  return SemicolonsStage;
}();

var EsnextStage = function () {
  function EsnextStage() {
    classCallCheck(this, EsnextStage);
  }

  createClass(EsnextStage, null, [{
    key: 'run',
    value: function run(content) {
      var log = logger(this.name);
      log(content);

      var _convert = esnext.convert(content, {
        'declarations.block-scope': {
          disableConst: function disableConst(_ref) {
            var node = _ref.node;
            var parent = _ref.parent;

            return (
              // Only use `const` for top-level variables…
              parent && parent.type !== 'Program' ||
              // … as the only variable in its declaration …
              node.declarations.length !== 1 ||
              // … without any sort of destructuring …
              node.declarations[0].id.type !== 'Identifier' ||
              // … starting with a capital letter.
              !/^[$_]?[A-Z]+$/.test(node.declarations[0].id.name)
            );
          }
        }
      });

      var code = _convert.code;

      return { code: code, map: {} };
    }
  }]);
  return EsnextStage;
}();

function printTable(table) {
  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';

  var widths = [];
  table.rows.forEach(function (row) {
    row.forEach(function (cell, i) {
      if (widths.length <= i) {
        widths[i] = cell.length;
      } else if (widths[i] < cell.length) {
        widths[i] = cell.length;
      }
    });
  });
  var output = '';
  table.rows.forEach(function (row) {
    row.forEach(function (cell, i) {
      var column = table.columns[i];
      if (column.align === 'left') {
        output += cell;
      } else if (column.align === 'right') {
        output += repeat(' ', widths[i] - cell.length) + cell;
      }
      if (i < row.length - 1) {
        output += buffer;
      }
    });
    output += '\n';
  });
  return output;
}

var PatchError = function (_Error) {
  inherits(PatchError, _Error);

  function PatchError(message, source, start, end, error) {
    classCallCheck(this, PatchError);

    var _this = possibleConstructorReturn(this, (PatchError.__proto__ || Object.getPrototypeOf(PatchError)).call(this, message));

    _this.message = message;
    _this.source = source;
    _this.start = start;
    _this.end = end;
    _this.error = error;
    return _this;
  }

  createClass(PatchError, [{
    key: 'toString',
    value: function toString() {
      return this.message;
    }

    /**
     * Due to babel's inability to simulate extending native types, we have our
     * own method for determining whether an object is an instance of
     * `PatchError`.
     *
     * @see http://stackoverflow.com/a/33837088/549363
     */

  }], [{
    key: 'detect',
    value: function detect(error) {
      return error instanceof Error && 'source' in error && 'start' in error && 'end' in error;
    }
  }, {
    key: 'prettyPrint',
    value: function prettyPrint(error) {
      var source = error.source;
      var start = error.start;
      var end = error.end;
      var message = error.message;

      var lineMap = new LinesAndColumns(source);
      var startLoc = lineMap.locationForIndex(start);
      var endLoc = lineMap.locationForIndex(end);

      if (!startLoc || !endLoc) {
        throw new Error('unable to find locations for range: [' + start + ', ' + end + ')');
      }

      var displayStartLine = Math.max(0, startLoc.line - 2);
      var displayEndLine = endLoc.line + 2;

      var rows = [];

      for (var line = displayStartLine; line <= displayEndLine; line++) {
        var startOfLine = lineMap.indexForLocation({ line: line, column: 0 });
        var endOfLine = lineMap.indexForLocation({ line: line + 1, column: 0 });
        if (startOfLine === null) {
          break;
        }
        if (endOfLine === null) {
          endOfLine = source.length;
        }
        var lineSource = trimRight(source.slice(startOfLine, endOfLine));
        if (startLoc.line !== endLoc.line) {
          if (line >= startLoc.line && line <= endLoc.line) {
            rows.push(['>', line + 1 + ' |', lineSource]);
          } else {
            rows.push(['', line + 1 + ' |', lineSource]);
          }
        } else if (line === startLoc.line) {
          var highlightLength = Math.max(endLoc.column - startLoc.column, 1);
          rows.push(['>', line + 1 + ' |', lineSource], ['', '|', repeat(' ', startLoc.column) + repeat('^', highlightLength)]);
        } else {
          rows.push(['', line + 1 + ' |', lineSource]);
        }
      }

      var columns = [{ id: 'marker', align: 'right' }, { id: 'line', align: 'right' }, { id: 'source', align: 'left' }];

      return message + '\n' + printTable({ rows: rows, columns: columns });
    }
  }]);
  return PatchError;
}(Error);

function trimRight(string) {
  return string.replace(/\s+$/, '');
}

var DEFAULT_INDENT = '  ';

function determineIndent(source) {
  var indent = detectIndent(source);
  if (indent.type === 'space' && indent.amount % 2 === 1) {
    return DEFAULT_INDENT;
  }
  return indent.indent || DEFAULT_INDENT;
}

/**
 * Finds the start of the line for the character at offset.
 */
function getStartOfLine(source, offset) {
  var lfIndex = source.lastIndexOf('\n', offset - 1);
  if (lfIndex < 0) {
    return 0;
  }
  return lfIndex + 1;
}

/**
 * Gets the indent string for the line containing offset.
 */
function getIndent$1(source, offset) {
  var startOfLine = getStartOfLine(source, offset);
  var indentOffset = startOfLine;
  var indentCharacter = void 0;

  switch (source[indentOffset]) {
    case ' ':
    case '\t':
      indentCharacter = source[indentOffset];
      break;

    default:
      return '';
  }

  while (source[indentOffset] === indentCharacter) {
    indentOffset++;
  }

  return source.slice(startOfLine, indentOffset);
}

/**
 * Adjust an indent in source at a specific offset by an amount.
 */
function adjustIndent(source, offset, adjustment) {
  var currentIndent = getIndent$1(source, offset);
  var determinedIndent = determineIndent(source);

  if (adjustment > 0) {
    while (adjustment--) {
      currentIndent += determinedIndent;
    }
  } else if (adjustment < 0) {
    currentIndent = currentIndent.slice(determinedIndent.length * -adjustment);
  }

  return currentIndent;
}

/**
 * Determines whether the node is a boolean, optionally with the given value.
 */


/**
 * Determines whether a node is a member access operation.
 */


/**
 * Determines whether a node is a static member access, e.g. `a.b`.
 */


/**
 * Determines whether a node is a dynamic member access, e.g. `a[b]`.
 */


/**
 * Determines whether a node represents a function, i.e. `->` or `=>`.
 */
function isFunction(node) {
  var allowBound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  return node.type === 'Function' || node.type === 'GeneratorFunction' || allowBound && node.type === 'BoundFunction';
}

/**
 * Determines  whether a node is the body of a function.
 *
 * @example
 *
 *   -> 1  # the literal `1` is the function body
 *
 *   ->
 *     2   # the block containing `2` as a statement is the function body
 */


/**
 * Determines whether the node is a conditional (i.e. `if` or `unless`).
 */


/**
 * Determines whether a node represents a `for` loop.
 */


/**
 * Determines whether a node represents a `while` loop.
 */


/**
 * Determines whether a node is the true-part or false-part of a conditional.
 */




function isCall(node) {
  switch (node && node.type) {
    case 'FunctionApplication':
    case 'NewOp':
      return true;

    default:
      return false;
  }
}







var NON_SEMANTIC_SOURCE_TOKEN_TYPES = [coffeeLex.COMMENT, coffeeLex.HERECOMMENT, coffeeLex.NEWLINE];

/**
 * This isn't a great name because newlines do have semantic meaning in
 * CoffeeScript, but it's close enough.
 */
function isSemanticToken(token) {
  return NON_SEMANTIC_SOURCE_TOKEN_TYPES.indexOf(token.type) < 0;
}

var NodePatcher = function () {
  function NodePatcher(node, context, editor) {
    var _this = this;

    classCallCheck(this, NodePatcher);
    this.adjustedIndentLevel = 0;

    this.log = logger(this.constructor.name);

    this.node = node;
    this.context = context;
    this.editor = editor;

    this.withPrettyErrors(function () {
      return _this.setupLocationInformation();
    });
  }

  /**
   * Allow patcher classes to override the class used to patch their children.
   */


  createClass(NodePatcher, [{
    key: 'setupLocationInformation',


    /**
     * @private
     */
    value: function setupLocationInformation() {
      var node = this.node;
      var context = this.context;


      if (node.virtual) {
        return;
      }

      /**
       * `contentStart` and `contentEnd` is the exclusive range within the original source that
       * composes this patcher's node. For example, here's the contentStart and contentEnd of
       * `a + b` in the expression below:
       *
       *   console.log(a + b)
       *               ^    ^
       */
      this.contentStart = node.range[0];
      this.contentEnd = node.range[1];

      if (this.shouldTrimContentRange()) {
        this.trimContentRange();
      }

      var tokens$$1 = context.sourceTokens;
      var firstSourceTokenIndex = tokens$$1.indexOfTokenStartingAtSourceIndex(this.contentStart);
      var lastSourceTokenIndex = tokens$$1.indexOfTokenEndingAtSourceIndex(this.contentEnd);

      if (!firstSourceTokenIndex || !lastSourceTokenIndex) {
        if (node.type === 'Program') {
          // Just an empty program.
          return;
        }

        throw this.error('cannot find first or last token in ' + node.type + ' node');
      }

      this.contentStartTokenIndex = firstSourceTokenIndex;
      this.contentEndTokenIndex = lastSourceTokenIndex;

      var outerStartTokenIndex = firstSourceTokenIndex;
      var outerEndTokenIndex = lastSourceTokenIndex;

      var innerStartTokenIndex = firstSourceTokenIndex;
      var innerEndTokenIndex = lastSourceTokenIndex;

      for (;;) {
        var previousSurroundingTokenIndex = tokens$$1.lastIndexOfTokenMatchingPredicate(isSemanticToken, outerStartTokenIndex.previous());
        var nextSurroundingTokenIndex = tokens$$1.indexOfTokenMatchingPredicate(isSemanticToken, outerEndTokenIndex.next());

        if (!previousSurroundingTokenIndex || !nextSurroundingTokenIndex) {
          break;
        }

        var previousSurroundingToken = tokens$$1.tokenAtIndex(previousSurroundingTokenIndex);
        var nextSurroundingToken = tokens$$1.tokenAtIndex(nextSurroundingTokenIndex);

        if (!previousSurroundingToken || previousSurroundingToken.type !== coffeeLex.LPAREN && previousSurroundingToken.type !== coffeeLex.CALL_START) {
          break;
        }

        if (!nextSurroundingToken || nextSurroundingToken.type !== coffeeLex.RPAREN && nextSurroundingToken.type !== coffeeLex.CALL_END) {
          break;
        }

        if (innerStartTokenIndex === firstSourceTokenIndex) {
          innerStartTokenIndex = previousSurroundingTokenIndex;
        }

        if (innerEndTokenIndex === lastSourceTokenIndex) {
          innerEndTokenIndex = nextSurroundingTokenIndex;
        }

        outerStartTokenIndex = previousSurroundingTokenIndex;
        outerEndTokenIndex = nextSurroundingTokenIndex;
      }

      this.innerStartTokenIndex = innerStartTokenIndex;
      this.innerEndTokenIndex = innerEndTokenIndex;

      this.outerStartTokenIndex = outerStartTokenIndex;
      this.outerEndTokenIndex = outerEndTokenIndex;

      /**
       * `innerStart`, `innerEnd`, `outerStart` and `outerEnd` refer to the
       * positions around surrounding parentheses. In most nodes they are the same
       * as `contentStart` and `contentEnd`. For example:
       *
       *              innerStart
       *                  |
       *       outerStart | contentStart
       *                | | |
       *                ▼ ▼ ▼
       *            1 * ((  2 + 3  ))
       *                         ▲ ▲ ▲
       *                         | | |
       *                contentEnd | outerEnd
       *                           |
       *                        innerEnd
       */
      if (innerStartTokenIndex === firstSourceTokenIndex) {
        this.innerStart = this.contentStart;
      } else {
        this.innerStart = tokens$$1.tokenAtIndex(innerStartTokenIndex).end;
      }
      if (innerEndTokenIndex === lastSourceTokenIndex) {
        this.innerEnd = this.contentEnd;
      } else {
        this.innerEnd = tokens$$1.tokenAtIndex(innerEndTokenIndex).start;
      }
      this.outerStart = tokens$$1.tokenAtIndex(outerStartTokenIndex).start;
      this.outerEnd = tokens$$1.tokenAtIndex(outerEndTokenIndex).end;
    }

    /**
     * Called to trim the range of content for this node. Override in subclasses
     * to customize its behavior, or override `shouldTrimContentRange` to enable
     * or disable it.
     */

  }, {
    key: 'trimContentRange',
    value: function trimContentRange() {
      var context = this.context;

      for (;;) {
        var startChar = context.source[this.contentStart];

        if (startChar === ' ' || startChar === '\t') {
          this.contentStart++;
        } else {
          break;
        }
      }

      for (;;) {
        var lastChar = context.source[this.contentEnd - 1];

        if (lastChar === ' ' || lastChar === '\t') {
          this.contentEnd--;
        } else {
          break;
        }
      }
    }

    /**
     * Decides whether to trim the content range of this node.
     */

  }, {
    key: 'shouldTrimContentRange',
    value: function shouldTrimContentRange() {
      return false;
    }

    /**
     * Called when the patcher tree is complete so we can do any processing that
     * requires communication with other patchers.
     */

  }, {
    key: 'initialize',
    value: function initialize() {}

    /**
     * Calls methods on `editor` to transform the source code represented by
     * `node` from CoffeeScript to JavaScript. By default this method delegates
     * to other patcher methods which can be overridden individually.
     */

  }, {
    key: 'patch',
    value: function patch() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.withPrettyErrors(function () {
        if (_this2.forcedToPatchAsExpression()) {
          _this2.patchAsForcedExpression(options);
        } else if (_this2.willPatchAsExpression()) {
          _this2.patchAsExpression(options);
        } else {
          _this2.patchAsStatement(options);
        }
      });
    }

    /**
     * Patch the given expression and get the underlying generated code. This is
     * more robust than calling patch and slice directly, since it also includes
     * code inserted at contentStart (which normally isn't picked up by slice
     * because it's inserted to the left of the index boundary). To accomplish
     * this, we look at the range from contentStart - 1 to contentStart before and
     * after patching and include anything new that was added.
     */

  }, {
    key: 'patchAndGetCode',
    value: function patchAndGetCode() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var sliceStart = this.contentStart > 0 ? this.contentStart - 1 : 0;
      var beforeCode = this.slice(sliceStart, this.contentStart);
      this.patch(options);
      var code = this.slice(sliceStart, this.contentEnd);
      var startIndex = 0;
      while (startIndex < beforeCode.length && startIndex < code.length && beforeCode[startIndex] === code[startIndex]) {
        startIndex++;
      }
      return code.substr(startIndex);
    }

    /**
     * Catch errors and throw them again annotated with the current node.
     */

  }, {
    key: 'withPrettyErrors',
    value: function withPrettyErrors(body) {
      try {
        body();
      } catch (err) {
        if (!PatchError.detect(err)) {
          throw this.error(err.message, this.contentStart, this.contentEnd, err);
        } else {
          throw err;
        }
      }
    }

    /**
     * Override this to patch the node as an expression.
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      throw this.error('\'patchAsExpression\' must be overridden in subclasses');
    }

    /**
     * Override this to patch the node as a statement.
     */

  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var addParens = this.statementShouldAddParens();
      if (addParens) {
        this.insert(this.outerStart, '(');
      }
      this.patchAsExpression(options);
      if (addParens) {
        this.insert(this.outerEnd, ')');
      }
    }

    /**
     * Override this to patch the node as an expression that would not normally be
     * an expression, often by wrapping it in an immediately invoked function
     * expression (IIFE).
     */

  }, {
    key: 'patchAsForcedExpression',
    value: function patchAsForcedExpression() {
      this.patchAsExpression();
    }

    /**
     * Insert content at the specified index.
     */

  }, {
    key: 'insert',
    value: function insert(index, content) {
      if (typeof index !== 'number') {
        throw new Error('cannot insert ' + JSON.stringify(content) + ' at non-numeric index ' + index);
      }
      this.log('INSERT RIGHT', index, JSON.stringify(content), 'BEFORE', JSON.stringify(this.context.source.slice(index, index + 8)));

      this.adjustBoundsToInclude(index);
      this.editor.appendLeft(index, content);
    }
  }, {
    key: 'allowPatchingOuterBounds',
    value: function allowPatchingOuterBounds() {
      return false;
    }

    /**
     * @protected
     */

  }, {
    key: 'getEditingBounds',
    value: function getEditingBounds() {
      var boundingPatcher = this.getBoundingPatcher();
      // When we're a function arg, there isn't a great patcher to use to
      // determine our bounds (we're allowed to patch from the previous
      // comma/paren to the next comma/paren), so loosen the restriction to the
      // entire function.
      if (boundingPatcher.parent && this.isNodeFunctionApplication(boundingPatcher.parent.node)) {
        boundingPatcher = boundingPatcher.parent;
      }
      if (this.allowPatchingOuterBounds()) {
        return [boundingPatcher.outerStart, boundingPatcher.outerEnd];
      } else {
        return [boundingPatcher.innerStart, boundingPatcher.innerEnd];
      }
    }

    /**
     * @protected
     */

  }, {
    key: 'isIndexEditable',
    value: function isIndexEditable(index) {
      var _getEditingBounds = this.getEditingBounds();

      var _getEditingBounds2 = slicedToArray(_getEditingBounds, 2);

      var start = _getEditingBounds2[0];
      var end = _getEditingBounds2[1];

      return index >= start && index <= end;
    }

    /**
     * @protected
     */

  }, {
    key: 'assertEditableIndex',
    value: function assertEditableIndex(index) {
      if (!this.isIndexEditable(index)) {
        var _getEditingBounds3 = this.getEditingBounds();

        var _getEditingBounds4 = slicedToArray(_getEditingBounds3, 2);

        var start = _getEditingBounds4[0];
        var end = _getEditingBounds4[1];

        throw this.error('cannot edit index ' + index + ' because it is not editable (i.e. outside [' + start + ', ' + end + '))', start, end);
      }
    }

    /**
     * When editing outside a node's bounds we expand the bounds to fit, if
     * possible. Note that if a node or a node's parent is wrapped in parentheses
     * we cannot adjust the bounds beyond the inside of the parentheses.
     *
     * @private
     */

  }, {
    key: 'adjustBoundsToInclude',
    value: function adjustBoundsToInclude(index) {
      this.assertEditableIndex(index);

      if (index < this.innerStart) {
        this.log('Moving `innerStart` from', this.innerStart, 'to', index);
        this.innerStart = index;
      }

      if (index > this.innerEnd) {
        this.log('Moving `innerEnd` from', this.innerEnd, 'to', index);
        this.innerEnd = index;
      }

      if (index < this.outerStart) {
        this.log('Moving `outerStart` from', this.outerStart, 'to', index);
        this.outerStart = index;
      }

      if (index > this.outerEnd) {
        this.log('Moving `outerEnd` from', this.outerEnd, 'to', index);
        this.outerEnd = index;
      }

      if (this.parent) {
        this.parent.adjustBoundsToInclude(index);
      }
    }

    /**
     * Replace the content between the start and end indexes with new content.
     */

  }, {
    key: 'overwrite',
    value: function overwrite(start, end, content) {
      if (typeof start !== 'number' || typeof end !== 'number') {
        throw new Error('cannot overwrite non-numeric range [' + start + ', ' + end + ') ' + ('with ' + JSON.stringify(content)));
      }
      this.log('OVERWRITE', '[' + start + ', ' + end + ')', JSON.stringify(this.context.source.slice(start, end)), '→', JSON.stringify(content));
      this.editor.overwrite(start, end, content);
    }

    /**
     * Remove the content between the start and end indexes.
     */

  }, {
    key: 'remove',
    value: function remove(start, end) {
      if (typeof start !== 'number' || typeof end !== 'number') {
        throw new Error('cannot remove non-numeric range [' + start + ', ' + end + ')');
      }
      this.log('REMOVE', '[' + start + ', ' + end + ')', JSON.stringify(this.context.source.slice(start, end)));
      this.editor.remove(start, end);
    }

    /**
     * Moves content in a range to another index.
     */

  }, {
    key: 'move',
    value: function move(start, end, index) {
      if (typeof start !== 'number' || typeof end !== 'number') {
        throw this.error('cannot remove non-numeric range [' + start + ', ' + end + ')');
      }
      if (typeof index !== 'number') {
        throw this.error('cannot move to non-numeric index: ' + index);
      }
      this.log('MOVE', '[' + start + ', ' + end + ') \u2192 ' + index, JSON.stringify(this.context.source.slice(start, end)), 'BEFORE', JSON.stringify(this.context.source.slice(index, index + 8)));
      this.editor.move(start, end, index);
    }

    /**
     * Get the current content between the start and end indexes.
     */

  }, {
    key: 'slice',
    value: function slice(start, end) {
      return this.editor.slice(start, end);
    }

    /**
     * Determines whether this node starts with a string.
     */

  }, {
    key: 'startsWith',
    value: function startsWith(string) {
      return this.context.source.slice(this.contentStart, this.contentStart + string.length) === string;
    }

    /**
     * Determines whether this node ends with a string.
     */

  }, {
    key: 'endsWith',
    value: function endsWith(string) {
      return this.context.source.slice(this.contentEnd - string.length, this.contentEnd) === string;
    }

    /**
     * Tells us to force this patcher to generate an expression, or else throw.
     */

  }, {
    key: 'setRequiresExpression',
    value: function setRequiresExpression() {
      this.setExpression(true);
    }

    /**
     * Tells us to try to patch as an expression, returning whether it can.
     */

  }, {
    key: 'setExpression',
    value: function setExpression() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (force) {
        if (!this.canPatchAsExpression()) {
          throw this.error('cannot represent ' + this.node.type + ' as an expression');
        }
      } else if (!this.prefersToPatchAsExpression()) {
        return false;
      }
      this._expression = true;
      return true;
    }

    /**
     * Override this to express whether the patcher prefers to be represented as
     * an expression. By default it's simply an alias for `canPatchAsExpression`.
     */

  }, {
    key: 'prefersToPatchAsExpression',
    value: function prefersToPatchAsExpression() {
      return this.canPatchAsExpression();
    }

    /**
     * Override this if a node cannot be represented as an expression.
     */

  }, {
    key: 'canPatchAsExpression',
    value: function canPatchAsExpression() {
      return true;
    }

    /**
     * Gets whether this patcher is working on a statement or an expression.
     */

  }, {
    key: 'willPatchAsExpression',
    value: function willPatchAsExpression() {
      return this._expression;
    }

    /**
     * Gets whether this patcher was forced to patch its node as an expression.
     */

  }, {
    key: 'forcedToPatchAsExpression',
    value: function forcedToPatchAsExpression() {
      return this.willPatchAsExpression() && !this.prefersToPatchAsExpression();
    }

    /**
     * Gets whether this patcher's node implicitly returns.
     */

  }, {
    key: 'implicitlyReturns',
    value: function implicitlyReturns() {
      return this._implicitlyReturns || false;
    }

    /**
     * Causes the node to be returned from its function.
     */

  }, {
    key: 'setImplicitlyReturns',
    value: function setImplicitlyReturns() {
      this._implicitlyReturns = true;
    }

    /**
     * Gets the ancestor that can make implicit returns explicit. Classes that
     * override this method should override `implicitReturnWillBreak`.
     */

  }, {
    key: 'implicitReturnPatcher',
    value: function implicitReturnPatcher() {
      return this.parent.implicitReturnPatcher();
    }

    /**
     * Patch the beginning of an implicitly-returned descendant.
     */

  }, {
    key: 'patchImplicitReturnStart',
    value: function patchImplicitReturnStart(patcher) {
      patcher.setRequiresExpression();
      this.insert(patcher.outerStart, 'return ');
    }

    /**
     * Determines whether the implicit return code will stop execution of
     * statements in the current block. Classes that override this method should
     * also override `implicitReturnPatcher`.
     */

  }, {
    key: 'implicitReturnWillBreak',
    value: function implicitReturnWillBreak() {
      return this.parent.implicitReturnWillBreak();
    }

    /**
     * Patch the end of an implicitly-returned descendant.
     */

  }, {
    key: 'patchImplicitReturnEnd',
    value: function patchImplicitReturnEnd(patcher) {} // eslint-disable-line no-unused-vars
    // Nothing to do.


    /**
     * Gets whether this patcher's node returns explicitly from its function.
     */

  }, {
    key: 'explicitlyReturns',
    value: function explicitlyReturns() {
      return this._returns || false;
    }

    /**
     * Marks this patcher's as containing a node that explicitly returns.
     */

  }, {
    key: 'setExplicitlyReturns',
    value: function setExplicitlyReturns() {
      this._returns = true;
      if (this.parent) {
        this.parent.setExplicitlyReturns();
      }
    }

    /**
     * Determines whether this patcher's node needs a semicolon after it. This
     * should be overridden in subclasses as appropriate.
     */

  }, {
    key: 'statementNeedsSemicolon',
    value: function statementNeedsSemicolon() {
      return true;
    }

    /**
     * Determines whether, when appearing as a statement, this patcher's node
     * needs to be surrounded by parentheses.
     *
     * Subclasses should override this and, typically, delegate to their leftmost
     * child patcher. Subclasses may return `false` when they will insert text at
     * the start of the node.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }

    /**
     * Determines whether this patcher's node should add parentheses when used in
     * a statement context.
     */

  }, {
    key: 'statementShouldAddParens',
    value: function statementShouldAddParens() {
      return this.statementNeedsParens() && !this.isSurroundedByParentheses();
    }

    /**
     * Gets the tokens for the whole program.
     */

  }, {
    key: 'getProgramSourceTokens',
    value: function getProgramSourceTokens() {
      return this.context.sourceTokens;
    }

    /**
     * Gets the index of the token starting at a particular source index.
     */

  }, {
    key: 'indexOfSourceTokenStartingAtSourceIndex',
    value: function indexOfSourceTokenStartingAtSourceIndex(index) {
      return this.getProgramSourceTokens().indexOfTokenStartingAtSourceIndex(index);
    }

    /**
     * Gets the index of the token between left and right patchers that matches
     * a predicate function.
     */

  }, {
    key: 'indexOfSourceTokenBetweenPatchersMatching',
    value: function indexOfSourceTokenBetweenPatchersMatching(left, right, predicate) {
      return this.indexOfSourceTokenBetweenSourceIndicesMatching(left.outerEnd, right.outerStart, predicate);
    }

    /**
     * Gets the index of the token between source locations that matches a
     * predicate function.
     */

  }, {
    key: 'indexOfSourceTokenBetweenSourceIndicesMatching',
    value: function indexOfSourceTokenBetweenSourceIndicesMatching(left, right, predicate) {
      return this.getProgramSourceTokens().indexOfTokenMatchingPredicate(function (token) {
        return token.start >= left && token.start <= right && predicate(token);
      });
    }

    /**
     * Gets the token at a particular index.
     */

  }, {
    key: 'sourceTokenAtIndex',
    value: function sourceTokenAtIndex(index) {
      return this.getProgramSourceTokens().tokenAtIndex(index);
    }

    /**
     * Gets the source encompassed by the given token.
     */

  }, {
    key: 'sourceOfToken',
    value: function sourceOfToken(token) {
      return this.context.source.slice(token.start, token.end);
    }

    /**
     * Gets the first token in the content of this node.
     */

  }, {
    key: 'firstToken',
    value: function firstToken() {
      return this.sourceTokenAtIndex(this.contentStartTokenIndex);
    }

    /**
     * Gets the last token in the content of this node.
     */

  }, {
    key: 'lastToken',
    value: function lastToken() {
      return this.sourceTokenAtIndex(this.contentEndTokenIndex);
    }

    /**
     * Gets the original source of this patcher's node.
     */

  }, {
    key: 'getOriginalSource',
    value: function getOriginalSource() {
      return this.context.source.slice(this.contentStart, this.contentEnd);
    }

    /**
     * Determines whether this patcher's node spanned multiple lines.
     */

  }, {
    key: 'isMultiline',
    value: function isMultiline() {
      return !this.node.virtual && /\n/.test(this.getOriginalSource());
    }

    /**
     * Gets the patched source of this patcher's node.
     */

  }, {
    key: 'getPatchedSource',
    value: function getPatchedSource() {
      return this.slice(this.contentStart, this.contentEnd);
    }

    /**
     * Gets the index of a token after `contentStart` with the matching type, ignoring
     * non-semantic types by default.
     */

  }, {
    key: 'indexOfSourceTokenAfterSourceTokenIndex',
    value: function indexOfSourceTokenAfterSourceTokenIndex(start, type) {
      var predicate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : isSemanticToken;

      var index = this.getProgramSourceTokens().indexOfTokenMatchingPredicate(predicate, start.next());
      if (!index) {
        return null;
      }
      var token = this.sourceTokenAtIndex(index);
      if (!token || token.type !== type) {
        return null;
      }
      return index;
    }

    /**
     * Determines whether this patcher's node is followed by a particular token.
     */

  }, {
    key: 'hasSourceTokenAfter',
    value: function hasSourceTokenAfter(type) {
      var predicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : isSemanticToken;

      return this.indexOfSourceTokenAfterSourceTokenIndex(this.outerEndTokenIndex, type, predicate) !== null;
    }

    /**
     * Determines whether this patcher's node is surrounded by parentheses.
     * Also check if these parents are matching, to avoid false positives on things like `(a) && (b)`
     */

  }, {
    key: 'isSurroundedByParentheses',
    value: function isSurroundedByParentheses() {
      var beforeToken = this.sourceTokenAtIndex(this.outerStartTokenIndex);
      var afterToken = this.sourceTokenAtIndex(this.outerEndTokenIndex);

      if (!beforeToken || !afterToken) {
        return false;
      }

      var leftTokenType = coffeeLex.LPAREN;
      var rightTokenType = coffeeLex.RPAREN;

      if (beforeToken.type === coffeeLex.LPAREN && afterToken.type === coffeeLex.RPAREN) {
        // nothing
      } else if (beforeToken.type === coffeeLex.CALL_START && afterToken.type === coffeeLex.CALL_END) {
        leftTokenType = coffeeLex.CALL_START;
        rightTokenType = coffeeLex.CALL_END;
      } else {
        return false;
      }

      var parenRange = this.getProgramSourceTokens().rangeOfMatchingTokensContainingTokenIndex(leftTokenType, rightTokenType, this.outerStartTokenIndex);
      if (!parenRange) return false;
      var rparenIndex = parenRange[1].previous();
      var rparen = this.sourceTokenAtIndex(rparenIndex);
      return rparen === afterToken;
    }
  }, {
    key: 'surroundInParens',
    value: function surroundInParens() {
      if (!this.isSurroundedByParentheses()) {
        this.insert(this.outerStart, '(');
        this.insert(this.outerEnd, ')');
      }
    }
  }, {
    key: 'getBoundingPatcher',
    value: function getBoundingPatcher() {
      var _this3 = this;

      if (this.isSurroundedByParentheses()) {
        return this;
      } else if (this.parent) {
        if (this.isNodeFunctionApplication(this.parent.node) && this.parent.node.arguments.some(function (arg) {
          return arg === _this3.node;
        })) {
          return this;
        }
        return this.parent.getBoundingPatcher();
      } else {
        return this;
      }
    }
  }, {
    key: 'isNodeFunctionApplication',
    value: function isNodeFunctionApplication(node) {
      return node.type === 'FunctionApplication' || node.type === 'SoakedFunctionApplication' || node.type === 'NewOp';
    }

    /**
     * Determines whether this patcher's node can be negated without prepending
     * a `!`, which turns it into a unary operator node.
     */

  }, {
    key: 'canHandleNegationInternally',
    value: function canHandleNegationInternally() {
      return false;
    }

    /**
     * Negates this patcher's node when patching.
     */

  }, {
    key: 'negate',
    value: function negate() {
      this.insert(this.outerStart, '!');
    }

    /**
     * Gets the indent string for the line that starts this patcher's node.
     */

  }, {
    key: 'getIndent',
    value: function getIndent() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      return adjustIndent(this.context.source, this.contentStart, this.getAdjustedIndentLevel() + offset);
    }

    /**
     * Force the indentation level of this node, adjusting it forward or backward
     * if necessary. This also sets the "adjusted indent" level, so that later
     * calls to getIndent will return this value.
     */

  }, {
    key: 'setIndent',
    value: function setIndent(indentStr) {
      var currentIndent = this.getIndent();
      var indentLength = this.getProgramIndentString().length;
      var currentIndentLevel = currentIndent.length / indentLength;
      var desiredIndentLevel = indentStr.length / indentLength;
      this.indent(desiredIndentLevel - currentIndentLevel);
    }

    /**
     * Get the amount the adjusted indent level differs from the original level.
     */

  }, {
    key: 'getAdjustedIndentLevel',
    value: function getAdjustedIndentLevel() {
      return this.adjustedIndentLevel + (this.parent ? this.parent.getAdjustedIndentLevel() : 0);
    }

    /**
     * Gets the indent string used for each indent in this program.
     */

  }, {
    key: 'getProgramIndentString',
    value: function getProgramIndentString() {
      return this.parent.getProgramIndentString();
    }

    /**
     * Indent this node a number of times. To unindent, pass a negative number.
     *
     * Note that because this method inserts indents immediately before the first
     * non-whitespace character of each line in the node's source, it should be
     * called *before* any other editing is done to the node's source to ensure
     * that strings inserted before child nodes appear after the indent, not
     * before.
     */

  }, {
    key: 'indent',
    value: function indent() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      if (offset === 0) {
        return;
      }

      this.adjustedIndentLevel += offset;
      var indentString = this.getProgramIndentString();
      var indentToChange = repeat(indentString, Math.abs(offset));
      var start = this.outerStart;
      var end = this.outerEnd;
      var source = this.context.source;

      // See if there are already non-whitespace characters before the start. If
      // so, skip the start to the next line, since we don't want to put
      // indentation in the middle of a line.

      for (var i = start - 1; i >= 0 && source[i] !== '\n'; i--) {
        if (source[i] !== '\t' && source[i] !== ' ') {
          while (start < end && source[start] !== '\n') {
            start++;
          }
          break;
        }
      }

      var hasIndentedThisLine = false;
      for (var _i = start; _i < end; _i++) {
        switch (source[_i]) {
          case '\n':
            hasIndentedThisLine = false;
            break;

          case ' ':
          case '\t':
            break;

          default:
            if (!hasIndentedThisLine) {
              if (offset > 0) {
                this.insert(_i, indentToChange);
              } else if (source.slice(_i - indentToChange.length, _i) === indentToChange) {
                this.remove(_i - indentToChange.length, _i);
              } else {
                throw this.error('cannot unindent line by ' + offset + ' without enough indent', _i - indentToChange.length, _i);
              }
              hasIndentedThisLine = true;
            }
            break;
        }
      }
    }

    /**
     * Gets the index ending the line following this patcher's node.
     *
     * @private
     */

  }, {
    key: 'getEndOfLine',
    value: function getEndOfLine() {
      var source = this.context.source;

      for (var i = this.outerEnd - '\n'.length; i < source.length; i++) {
        if (source[i] === '\n') {
          return i;
        }
      }
      return source.length;
    }

    /**
     * Appends the given content on a new line after the end of the current line.
     */

  }, {
    key: 'appendLineAfter',
    value: function appendLineAfter(content) {
      var indentOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var boundingPatcher = this.getBoundingPatcher();
      var endOfLine = this.getEndOfLine();
      this.insert(Math.min(endOfLine, boundingPatcher.innerEnd), '\n' + this.getIndent(indentOffset) + content);
    }

    /**
     * Appends the given content at the end of the current line.
     */

  }, {
    key: 'appendToEndOfLine',
    value: function appendToEndOfLine(content) {
      var boundingPatcher = this.getBoundingPatcher();
      var endOfLine = this.getEndOfLine();
      this.insert(Math.min(endOfLine, boundingPatcher.innerEnd), content);
    }

    /**
     * Generate an error referring to a particular section of the source.
     */

  }, {
    key: 'error',
    value: function error(message) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.contentStart;
      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.contentEnd;

      var _error = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var patcherError = new PatchError(message, this.context.source, start, end, _error);
      if (_error) {
        patcherError.stack = _error.stack;
      }
      return patcherError;
    }

    /**
     * Register a helper to be reused in several places.
     */

  }, {
    key: 'registerHelper',
    value: function registerHelper(name, code) {
      return this.parent.registerHelper(name, code);
    }

    /**
     * Determines whether this node can be repeated without side-effects. Most
     * nodes are not repeatable, so that is the default. Subclasses should
     * override this to indicate whether they are repeatable without any changes.
     */

  }, {
    key: 'isRepeatable',
    value: function isRepeatable() {
      return false;
    }

    /**
     * Alter this node to enable it to be repeated without side-effects. Though
     * a default implementation is provided, subclasses should override this to
     * provide a more appropriate version for their particular node type.
     */

  }, {
    key: 'makeRepeatable',
    value: function makeRepeatable(parens) {
      var ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (this.isRepeatable()) {
        // If we can repeat it, just return the original source.
        return this.getOriginalSource();
      } else {
        // Can't repeat it, so we assign it to a free variable and return that,
        // i.e. `a + b` → `(ref = a + b)`.
        if (parens) {
          this.insert(this.innerStart, '(');
        }
        ref = this.claimFreeBinding(ref);
        this.insert(this.innerStart, ref + ' = ');
        if (parens) {
          this.insert(this.innerEnd, ')');
        }
        return ref;
      }
    }

    /**
     * Claim a binding that is unique in the current scope.
     */

  }, {
    key: 'claimFreeBinding',
    value: function claimFreeBinding() {
      var ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      return this.node.scope.claimFreeBinding(this.node, ref);
    }

    /**
     * Determines whether all the possible code paths in this node are present.
     */

  }, {
    key: 'allCodePathsPresent',
    value: function allCodePathsPresent() {
      return true;
    }
  }, {
    key: 'yields',
    value: function yields() {
      var receiver = this.parent;
      while (receiver) {
        if (receiver.yieldController) {
          return receiver.yieldController();
        }
        receiver = receiver.parent;
      }
    }
  }], [{
    key: 'patcherClassForChildNode',
    value: function patcherClassForChildNode() {
      return null;
    }

    /**
     * Allow patcher classes that would patch a node to chose a different class.
     */

  }, {
    key: 'patcherClassOverrideForNode',
    value: function patcherClassOverrideForNode(node) {
      // eslint-disable-line no-unused-vars
      return null;
    }
  }]);
  return NodePatcher;
}();

var ArrayInitialiserPatcher = function (_NodePatcher) {
  inherits(ArrayInitialiserPatcher, _NodePatcher);

  function ArrayInitialiserPatcher(node, context, editor, members) {
    classCallCheck(this, ArrayInitialiserPatcher);

    var _this = possibleConstructorReturn(this, (ArrayInitialiserPatcher.__proto__ || Object.getPrototypeOf(ArrayInitialiserPatcher)).call(this, node, context, editor));

    _this.members = members;
    return _this;
  }

  createClass(ArrayInitialiserPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.members.forEach(function (member) {
        return member.setRequiresExpression();
      });
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _this2 = this;

      this.members.forEach(function (member, i, members) {
        var isLast = i === members.length - 1;
        var needsComma = !isLast && !member.hasSourceTokenAfter(coffeeLex.COMMA);
        member.patch();
        if (needsComma) {
          _this2.insert(member.outerEnd, ',');
        }
      });
    }
  }]);
  return ArrayInitialiserPatcher;
}(NodePatcher);

var ExpansionPatcher = function (_NodePatcher) {
  inherits(ExpansionPatcher, _NodePatcher);

  function ExpansionPatcher() {
    classCallCheck(this, ExpansionPatcher);
    return possibleConstructorReturn(this, (ExpansionPatcher.__proto__ || Object.getPrototypeOf(ExpansionPatcher)).apply(this, arguments));
  }

  createClass(ExpansionPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      // Any code handling expansions should process them without calling patch.
      // If patch ends up being called, then that means that we've hit an
      // unsupported case that's trying to treat this node as a normal expression.
      throw this.error('expansions (e.g. `[a, ..., b] = c`) are not supported yet in all ' + 'cases, see https://github.com/decaffeinate/decaffeinate/issues/268');
    }
  }]);
  return ExpansionPatcher;
}(NodePatcher);

var AssignOpPatcher = function (_NodePatcher) {
  inherits(AssignOpPatcher, _NodePatcher);

  function AssignOpPatcher(node, context, editor, assignee, expression) {
    classCallCheck(this, AssignOpPatcher);

    var _this = possibleConstructorReturn(this, (AssignOpPatcher.__proto__ || Object.getPrototypeOf(AssignOpPatcher)).call(this, node, context, editor));

    _this.assignee = assignee;
    _this.expression = expression;
    return _this;
  }

  createClass(AssignOpPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.assignee.setRequiresExpression();
      this.expression.setRequiresExpression();
    }

    /**
     * Assignment operators have lower precedence than negation, so we need to add
     * parens.
     */

  }, {
    key: 'negate',
    value: function negate() {
      this.insert(this.innerStart, '!(');
      this.insert(this.innerEnd, ')');
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (this.isExpansionAssignment()) {
        this.patchExpansionAssignment();
      } else {
        this.assignee.patch();
        this.expression.patch();
      }
    }
  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      if (this.isExpansionAssignment()) {
        return this.expansionAssignmentNeedsParens();
      } else {
        // The assignment needs parentheses when the LHS needs parens.
        return this.assignee.statementShouldAddParens();
      }
    }
  }, {
    key: 'expansionAssignmentNeedsParens',
    value: function expansionAssignmentNeedsParens() {
      if (!this.expression.isRepeatable()) {
        // The left side will be an "array" variable.
        return false;
      }
      var expansionIndex = this.getExpansionIndex();
      if (expansionIndex === this.assignee.members.length - 1) {
        // Simple case where we leave the array assignment mostly intact.
        return this.assignee.statementShouldAddParens();
      } else if (expansionIndex === 0) {
        // The first non-expansion assignee will end up on the left side.
        return this.assignee.members[1].statementShouldAddParens();
      } else {
        return this.assignee.members[0].statementShouldAddParens();
      }
    }
  }, {
    key: 'isExpansionAssignment',
    value: function isExpansionAssignment() {
      return this.getExpansionIndex() !== -1;
    }

    /**
     * If there is an expansion assignment, return the index of the expansion node.
     * Otherwise, return -1.
     */

  }, {
    key: 'getExpansionIndex',
    value: function getExpansionIndex() {
      if (!(this.assignee instanceof ArrayInitialiserPatcher)) {
        return -1;
      }
      for (var i = 0; i < this.assignee.members.length; i++) {
        if (this.assignee.members[i] instanceof ExpansionPatcher) {
          return i;
        }
      }
      return -1;
    }
  }, {
    key: 'patchExpansionAssignment',
    value: function patchExpansionAssignment() {
      var _this2 = this;

      var expansionIndex = this.getExpansionIndex();
      var assignees = this.assignee.members;
      var expansionNode = assignees[expansionIndex];

      assignees.forEach(function (assignee, i) {
        // Patch everything but the expansion node, since expansion nodes expect
        // to not be patched.
        if (i !== expansionIndex) {
          assignee.patch();
        }
      });
      this.expression.patch();
      var expressionCode = this.slice(this.expression.contentStart, this.expression.contentEnd);

      // Easy case: [a, b, ...] = c  ->  [a, b] = c
      if (expansionIndex === assignees.length - 1) {
        var assigneeBeforeExpansion = assignees[assignees.length - 2];
        this.remove(assigneeBeforeExpansion.outerEnd, expansionNode.outerEnd);
        return;
      }

      // Split into independent assignments. For example, the transformation from
      // [a, ..., b, c] = d()
      // to
      // array = d(), a = array[0], b = array[array.length - 2], c = array[array.length - 1];
      //
      // takes these steps:
      // * Remove the "...,".
      // * Insert "array = d(), " on the left.
      // * Remove "["
      // * Insert " = array[index]" after each assignment (the comma is already there).
      // * Remove "] = d()"

      // Remove "...,". We know there's an assignee after the expansion because
      // otherwise we would have returned above.
      this.remove(expansionNode.outerStart, assignees[expansionIndex + 1].outerStart);

      var arrReference = void 0;
      if (this.expression.isRepeatable()) {
        arrReference = expressionCode;
      } else {
        arrReference = this.claimFreeBinding('array');
        this.insert(this.outerStart, arrReference + ' = ' + expressionCode + ', ');
      }

      // Remove opening "[".
      this.remove(this.contentStart, assignees[0].outerStart);

      assignees.forEach(function (assignee, i) {
        if (i === expansionIndex) {
          return;
        }
        var key = void 0;
        if (i < expansionIndex) {
          key = '' + i;
        } else {
          key = arrReference + '.length - ' + (assignees.length - i);
        }
        _this2.insert(assignee.outerEnd, ' = ' + arrReference + '[' + key + ']');
      });

      // Remove closing "]" and right-side expression.
      this.remove(assignees[assignees.length - 1].outerEnd, this.contentEnd);
    }
  }]);
  return AssignOpPatcher;
}(NodePatcher);

var BinaryOpPatcher = function (_NodePatcher) {
  inherits(BinaryOpPatcher, _NodePatcher);

  function BinaryOpPatcher(node, context, editor, left, right) {
    classCallCheck(this, BinaryOpPatcher);

    var _this = possibleConstructorReturn(this, (BinaryOpPatcher.__proto__ || Object.getPrototypeOf(BinaryOpPatcher)).call(this, node, context, editor));

    _this.left = left;
    _this.right = right;
    return _this;
  }

  createClass(BinaryOpPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.left.setRequiresExpression();
      this.right.setRequiresExpression();
    }

    /**
     * Binary operators have lower precedence than negation, so we need to add
     * parens.
     */

  }, {
    key: 'negate',
    value: function negate() {
      this.insert(this.innerStart, '!(');
      this.insert(this.innerEnd, ')');
    }

    /**
     * LEFT OP RIGHT
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _ref$needsParens = _ref.needsParens;
      var needsParens = _ref$needsParens === undefined ? false : _ref$needsParens;

      var addParens = needsParens && !this.isSurroundedByParentheses();
      if (addParens) {
        this.insert(this.outerStart, '(');
      }
      if (this.left instanceof BinaryOpPatcher) {
        this.left.patch({ needsParens: this.getOperator() !== this.left.getOperator() });
      } else {
        this.left.patch({ needsParens: true });
      }
      this.patchOperator();
      if (this.right instanceof BinaryOpPatcher) {
        this.right.patch({ needsParens: this.getOperator() !== this.right.getOperator() });
      } else {
        this.right.patch({ needsParens: true });
      }
      if (addParens) {
        this.insert(this.outerEnd, ')');
      }
    }
  }, {
    key: 'patchOperator',
    value: function patchOperator() {
      // override point for subclasses
    }
  }, {
    key: 'getOperator',
    value: function getOperator() {
      return this.sourceOfToken(this.getOperatorToken());
    }
  }, {
    key: 'getOperatorToken',
    value: function getOperatorToken() {
      var operatorTokenIndex = this.indexOfSourceTokenBetweenPatchersMatching(this.left, this.right, this.operatorTokenPredicate());
      if (!operatorTokenIndex) {
        throw this.error('expected operator between binary operands');
      }
      return this.sourceTokenAtIndex(operatorTokenIndex);
    }
  }, {
    key: 'operatorTokenPredicate',
    value: function operatorTokenPredicate() {
      return function (token) {
        return token.type === coffeeLex.OPERATOR || token.type === coffeeLex.EXISTENCE;
      };
    }

    /**
     * IF `LEFT` needs parens then `LEFT + RIGHT` needs parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.left.statementShouldAddParens();
    }
  }]);
  return BinaryOpPatcher;
}(NodePatcher);

var FunctionApplicationPatcher = function (_NodePatcher) {
  inherits(FunctionApplicationPatcher, _NodePatcher);

  function FunctionApplicationPatcher(node, context, editor, fn, args) {
    classCallCheck(this, FunctionApplicationPatcher);

    var _this = possibleConstructorReturn(this, (FunctionApplicationPatcher.__proto__ || Object.getPrototypeOf(FunctionApplicationPatcher)).call(this, node, context, editor));

    _this.fn = fn;
    _this.args = args;
    return _this;
  }

  createClass(FunctionApplicationPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.fn.setRequiresExpression();
      this.args.forEach(function (arg) {
        return arg.setRequiresExpression();
      });
    }

    /**
     * Note that we don't need to worry about implicit function applications,
     * since the normalize stage would have already added parens.
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _this2 = this;

      var args = this.args;
      var outerEndTokenIndex = this.outerEndTokenIndex;


      this.fn.patch();

      args.forEach(function (arg, i) {
        arg.patch();
        var isLast = i === args.length - 1;
        var commaTokenIndex = arg.node.virtual ? null : _this2.indexOfSourceTokenAfterSourceTokenIndex(arg.outerEndTokenIndex, coffeeLex.COMMA, isSemanticToken);
        // Ignore commas after the end of the function call.
        if (commaTokenIndex && commaTokenIndex.compare(outerEndTokenIndex) <= 0) {
          commaTokenIndex = null;
        }
        var commaToken = commaTokenIndex && _this2.sourceTokenAtIndex(commaTokenIndex);
        if (isLast && commaToken) {
          _this2.remove(arg.outerEnd, commaToken.end);
        } else if (!isLast && !commaToken) {
          _this2.insert(arg.outerEnd, ',');
        }
      });
    }

    /**
     * Probably can't happen, but just for completeness.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.fn.statementShouldAddParens();
    }
  }]);
  return FunctionApplicationPatcher;
}(NodePatcher);

var FunctionPatcher = function (_NodePatcher) {
  inherits(FunctionPatcher, _NodePatcher);

  function FunctionPatcher(node, context, editor, parameters, body) {
    classCallCheck(this, FunctionPatcher);

    var _this = possibleConstructorReturn(this, (FunctionPatcher.__proto__ || Object.getPrototypeOf(FunctionPatcher)).call(this, node, context, editor));

    _this.parameters = parameters;
    _this.body = body;
    return _this;
  }

  createClass(FunctionPatcher, [{
    key: 'initialize',
    value: function initialize() {
      if (this.body && !this.implicitReturnsDisabled()) {
        this.body.setImplicitlyReturns();
      }
      this.parameters.forEach(function (param) {
        return param.setRequiresExpression();
      });
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.insert(this.innerStart, '(');
      this.patchAsExpression(options);
      this.insert(this.innerEnd, ')');
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _this2 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _ref$method = _ref.method;
      var method = _ref$method === undefined ? false : _ref$method;

      this.patchFunctionStart({ method: method });
      this.parameters.forEach(function (parameter, i) {
        var isLast = i === _this2.parameters.length - 1;
        var needsComma = !isLast && !parameter.hasSourceTokenAfter(coffeeLex.COMMA);
        parameter.patch();
        if (needsComma) {
          _this2.insert(parameter.outerEnd, ',');
        }
      });
      this.patchFunctionBody({ method: method });
    }
  }, {
    key: 'patchFunctionStart',
    value: function patchFunctionStart(_ref2) {
      var _ref2$method = _ref2.method;
      var method = _ref2$method === undefined ? false : _ref2$method;

      var arrow = this.getArrowToken();

      if (!method) {
        this.insert(this.contentStart, 'function');
      }

      if (!this.hasParamStart()) {
        this.insert(this.contentStart, '() ');
      }

      this.overwrite(arrow.start, arrow.end, '{');
    }
  }, {
    key: 'patchFunctionBody',
    value: function patchFunctionBody() {
      if (this.body) {
        if (this.isSurroundedByParentheses()) {
          this.body.patch({ leftBrace: false, rightBrace: false });
          this.insert(this.innerEnd, this.body.inline() ? ' }' : '}');
        } else if (this.parent instanceof FunctionApplicationPatcher && this.parent.args[this.parent.args.length - 1] === this) {
          // If we're the last argument to a function, place the } just before the
          // close-paren. There will always be a close-paren because all implicit
          // parentheses were added in the normalize stage.
          this.body.patch({ leftBrace: false, rightBrace: false });
          var closeParenIndex = this.parent.indexOfSourceTokenBetweenSourceIndicesMatching(this.contentEnd, this.parent.contentEnd, function (token) {
            return token.type === coffeeLex.CALL_END;
          });
          var closeParen = this.sourceTokenAtIndex(closeParenIndex);
          this.insert(closeParen.start, this.body.inline() ? ' }' : '}');
        } else {
          this.body.patch({ leftBrace: false });
        }
      } else {
        // No body, so BlockPatcher can't insert it for us.
        this.insert(this.innerEnd, '}');
      }
    }
  }, {
    key: 'getArrowToken',
    value: function getArrowToken() {
      var arrowIndex = this.contentStartTokenIndex;
      if (this.hasParamStart()) {
        var parenRange = this.getProgramSourceTokens().rangeOfMatchingTokensContainingTokenIndex(coffeeLex.LPAREN, coffeeLex.RPAREN, this.contentStartTokenIndex);
        var rparenIndex = parenRange[1].previous();
        arrowIndex = this.indexOfSourceTokenAfterSourceTokenIndex(rparenIndex, coffeeLex.FUNCTION);
      }
      var arrow = this.sourceTokenAtIndex(arrowIndex);
      var expectedArrowType = this.expectedArrowType();
      var actualArrowType = this.sourceOfToken(arrow);
      if (actualArrowType !== expectedArrowType) {
        throw this.error('expected \'' + expectedArrowType + '\' but found ' + actualArrowType, arrow.start, arrow.end);
      }
      return arrow;
    }
  }, {
    key: 'expectedArrowType',
    value: function expectedArrowType() {
      return '->';
    }
  }, {
    key: 'hasParamStart',
    value: function hasParamStart() {
      return this.sourceTokenAtIndex(this.contentStartTokenIndex).type === coffeeLex.LPAREN;
    }
  }, {
    key: 'implicitReturnPatcher',
    value: function implicitReturnPatcher() {
      return this;
    }
  }, {
    key: 'implicitReturnWillBreak',
    value: function implicitReturnWillBreak() {
      return true;
    }
  }, {
    key: 'setExplicitlyReturns',
    value: function setExplicitlyReturns() {}
    // Stop propagation of return info at functions.


    /**
     * Call before initialization to prevent this function from implicitly
     * returning its last statement.
     */

  }, {
    key: 'disableImplicitReturns',
    value: function disableImplicitReturns() {
      this._implicitReturnsDisabled = true;
    }

    /**
     * Determines whether this function has implicit returns disabled.
     */

  }, {
    key: 'implicitReturnsDisabled',
    value: function implicitReturnsDisabled() {
      return this._implicitReturnsDisabled;
    }

    /**
     * Functions in CoffeeScript are always anonymous and therefore need parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return true;
    }
  }]);
  return FunctionPatcher;
}(NodePatcher);

var ReturnPatcher = function (_NodePatcher) {
  inherits(ReturnPatcher, _NodePatcher);

  function ReturnPatcher(node, context, editor, expression) {
    classCallCheck(this, ReturnPatcher);

    var _this = possibleConstructorReturn(this, (ReturnPatcher.__proto__ || Object.getPrototypeOf(ReturnPatcher)).call(this, node, context, editor));

    _this.expression = expression;
    return _this;
  }

  createClass(ReturnPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.setExplicitlyReturns();
      if (this.expression !== null) {
        this.expression.setRequiresExpression();
      }
    }

    /**
     * Return statements cannot be expressions.
     */

  }, {
    key: 'canPatchAsExpression',
    value: function canPatchAsExpression() {
      return false;
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      if (this.expression) {
        this.expression.patch();
      }
    }
  }]);
  return ReturnPatcher;
}(NodePatcher);

var BlockPatcher = function (_NodePatcher) {
  inherits(BlockPatcher, _NodePatcher);

  function BlockPatcher(node, context, editor, statements) {
    classCallCheck(this, BlockPatcher);

    var _this = possibleConstructorReturn(this, (BlockPatcher.__proto__ || Object.getPrototypeOf(BlockPatcher)).call(this, node, context, editor));

    _this.statements = statements;
    _this.shouldPatchInline = null;
    return _this;
  }

  createClass(BlockPatcher, [{
    key: 'canPatchAsExpression',
    value: function canPatchAsExpression() {
      return this.statements.every(function (statement) {
        return statement.prefersToPatchAsExpression();
      });
    }
  }, {
    key: 'setExpression',
    value: function setExpression() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var willPatchAsExpression = get$1(BlockPatcher.prototype.__proto__ || Object.getPrototypeOf(BlockPatcher.prototype), 'setExpression', this).call(this, force);
      if (willPatchAsExpression && this.prefersToPatchAsExpression()) {
        this.statements.forEach(function (statement) {
          return statement.setExpression();
        });
      }
    }
  }, {
    key: 'setImplicitlyReturns',
    value: function setImplicitlyReturns() {
      this.statements[this.statements.length - 1].setImplicitlyReturns();
    }

    /**
     * Force the patcher to treat the block as inline (semicolon-separated
     * statements) or not (newline-separated statements).
     */

  }, {
    key: 'setShouldPatchInline',
    value: function setShouldPatchInline(shouldPatchInline) {
      this.shouldPatchInline = shouldPatchInline;
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var _this2 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _ref$leftBrace = _ref.leftBrace;
      var leftBrace = _ref$leftBrace === undefined ? true : _ref$leftBrace;
      var _ref$rightBrace = _ref.rightBrace;
      var rightBrace = _ref$rightBrace === undefined ? true : _ref$rightBrace;

      if (leftBrace) {
        this.insert(this.innerStart, '{');
      }

      this.statements.forEach(function (statement, i, statements) {
        if (i === statements.length - 1 && _this2.parent instanceof FunctionPatcher) {
          if (statement instanceof ReturnPatcher && !statement.expression) {
            var removeStart = void 0;
            if (statements.length > 1) {
              var startOfLineIndex = _this2.context.sourceTokens.lastIndexOfTokenMatchingPredicate(function (token) {
                return token.type === coffeeLex.NEWLINE || token.type === coffeeLex.SEMICOLON;
              }, statement.outerStartTokenIndex);
              removeStart = _this2.sourceTokenAtIndex(startOfLineIndex).start;
            } else {
              removeStart = statement.outerStart;
            }
            _this2.remove(removeStart, statement.outerEnd);
            return;
          }
        }
        if (statement.isSurroundedByParentheses()) {
          statement.setRequiresExpression();
        }
        var hasImplicitReturn = statement.implicitlyReturns() && !statement.explicitlyReturns();
        var implicitReturnPatcher = hasImplicitReturn ? _this2.implicitReturnPatcher() : null;
        if (implicitReturnPatcher) {
          implicitReturnPatcher.patchImplicitReturnStart(statement);
        }
        statement.patch();
        if (implicitReturnPatcher) {
          implicitReturnPatcher.patchImplicitReturnEnd(statement);
        }
        if (statement.statementNeedsSemicolon()) {
          _this2.insert(statement.outerEnd, ';');
        }
      });

      if (rightBrace) {
        if (this.inline()) {
          this.insert(this.innerEnd, ' }');
        } else {
          this.appendLineAfter('}', -1);
        }
      }
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _this3 = this;

      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _ref2$leftBrace = _ref2.leftBrace;
      var leftBrace = _ref2$leftBrace === undefined ? this.statements.length > 1 : _ref2$leftBrace;
      var _ref2$rightBrace = _ref2.rightBrace;
      var rightBrace = _ref2$rightBrace === undefined ? this.statements.length > 1 : _ref2$rightBrace;

      if (leftBrace) {
        this.insert(this.innerStart, '(');
      }
      this.statements.forEach(function (statement, i, statements) {
        statement.patch();
        if (i !== statements.length - 1) {
          var semicolonTokenIndex = _this3.getSemicolonSourceTokenBetween(statement, statements[i + 1]);
          if (semicolonTokenIndex) {
            var semicolonToken = _this3.sourceTokenAtIndex(semicolonTokenIndex);
            _this3.overwrite(semicolonToken.start, semicolonToken.end, ',');
          } else {
            _this3.insert(statement.outerEnd, ',');
          }
        }
      });
      if (rightBrace) {
        this.insert(this.innerEnd, ')');
      }
    }

    /**
     * Insert statements somewhere in this block.
     */

  }, {
    key: 'insertStatementsAtIndex',
    value: function insertStatementsAtIndex(statements, index) {
      var _this4 = this;

      var separator = this.inline() ? '; ' : ';\n';
      if (index === this.statements.length) {
        (function () {
          var lastStatement = _this4.statements[_this4.statements.length - 1];
          var terminatorTokenIndex = _this4.context.sourceTokens.indexOfTokenMatchingPredicate(function (token) {
            return token.type === coffeeLex.NEWLINE || token.type === coffeeLex.SEMICOLON;
          }, lastStatement.outerEndTokenIndex);
          var insertionPoint = terminatorTokenIndex ? _this4.sourceTokenAtIndex(terminatorTokenIndex).start : lastStatement.outerEnd;
          var indent = lastStatement.getIndent();
          statements.forEach(function (line) {
            return _this4.insert(insertionPoint, '' + separator + indent + line);
          });
        })();
      } else {
        (function () {
          var statementToInsertBefore = _this4.statements[index];
          var insertionPoint = statementToInsertBefore.outerStart;
          var indent = statementToInsertBefore.getIndent();
          statements.forEach(function (line) {
            return _this4.insert(insertionPoint, '' + line + separator + indent);
          });
        })();
      }
    }

    /**
     * Insert a statement before the current block. Since blocks can be patched in
     * a number of ways, this needs to handle a few cases:
     * - If it's completely inline, we don't deal with any indentation and just
     *   put a semicolon-separated statement before the start.
     * - If it's a normal non-inline block, we insert the statement beforehand
     *   with the given indentation. However, `this.outerStart` is the first
     *   non-whitespace character of the first line, so it's already indented, so
     *   if we want to add a line with *less* indentation, it's a lot more tricky.
     *   We handle this by walking backward to the previous newline and inserting
     *   a new line from there. This allows the prepended line to have whatever
     *   indentation level we want.
     * - In some cases, such as nontrivial loop expressions with an inline body,
     *   the source CoffeeScript is inline, but we want the result to be
     *   non-inline, so we need to be a lot more careful. The normal non-inline
     *   strategy won't work because there's no newline to walk back to in the
     *   source CoffeeScript, so the strategy is to instead always insert at
     *   `this.outerStart`. That means that the indentation for the actual body
     *   needs to be done later, just before the body itself is patched. See the
     *   uses of shouldConvertInlineBodyToNonInline in LoopPatcher for an example.
     */

  }, {
    key: 'insertLineBefore',
    value: function insertLineBefore(statement, indent) {
      if (this.inline()) {
        this.insert(this.outerStart, statement + '; ');
      } else if (this.node.inline) {
        if (indent === null) {
          indent = this.getIndent();
        }
        this.insert(this.outerStart, '' + indent + statement + ';\n');
      } else {
        var insertIndex = this.outerStart;
        while (insertIndex > 0 && this.context.source[insertIndex] !== '\n') {
          insertIndex--;
        }
        this.insert(insertIndex, '\n' + indent + statement + ';');
      }
    }
  }, {
    key: 'insertLineAfter',
    value: function insertLineAfter(statement, indent) {
      if (this.inline()) {
        this.insert(this.outerEnd, '; ' + statement);
      } else {
        this.insert(this.outerEnd, '\n' + indent + statement + ';');
      }
    }

    /**
     * @private
     */

  }, {
    key: 'getSemicolonSourceTokenBetween',
    value: function getSemicolonSourceTokenBetween(left, right) {
      return this.indexOfSourceTokenBetweenPatchersMatching(left, right, function (token) {
        return token.type === coffeeLex.SEMICOLON;
      });
    }

    /**
     * Gets whether this patcher's block is inline (on the same line as the node
     * that contains it) or not.
     */

  }, {
    key: 'inline',
    value: function inline() {
      if (this.shouldPatchInline !== null) {
        return this.shouldPatchInline;
      }
      return this.node.inline;
    }

    /**
     * Blocks only exit via the last statement, so we check its code paths.
     */

  }, {
    key: 'allCodePathsPresent',
    value: function allCodePathsPresent() {
      return this.statements[this.statements.length - 1].allCodePathsPresent();
    }
  }]);
  return BlockPatcher;
}(NodePatcher);

var BoolPatcher = function (_NodePatcher) {
  inherits(BoolPatcher, _NodePatcher);

  function BoolPatcher() {
    classCallCheck(this, BoolPatcher);
    return possibleConstructorReturn(this, (BoolPatcher.__proto__ || Object.getPrototypeOf(BoolPatcher)).apply(this, arguments));
  }

  createClass(BoolPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      switch (this.getOriginalSource()) {
        case 'off':
        case 'no':
          this.overwrite(this.contentStart, this.contentEnd, 'false');
          break;

        case 'on':
        case 'yes':
          this.overwrite(this.contentStart, this.contentEnd, 'true');
          break;
      }
    }
  }]);
  return BoolPatcher;
}(NodePatcher);

var PassthroughPatcher = function (_NodePatcher) {
  inherits(PassthroughPatcher, _NodePatcher);

  function PassthroughPatcher(node, context, editor) {
    classCallCheck(this, PassthroughPatcher);

    var _this = possibleConstructorReturn(this, (PassthroughPatcher.__proto__ || Object.getPrototypeOf(PassthroughPatcher)).call(this, node, context, editor));

    for (var _len = arguments.length, children = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      children[_key - 3] = arguments[_key];
    }

    _this.children = children;
    return _this;
  }

  createClass(PassthroughPatcher, [{
    key: 'patch',
    value: function patch() {
      var _this2 = this;

      this.withPrettyErrors(function () {
        _this2.children.forEach(function (child) {
          if (Array.isArray(child)) {
            child.forEach(function (child) {
              return child && child.patch();
            });
          } else if (child) {
            child.patch();
          }
        });
      });
    }
  }, {
    key: 'isRepeatable',
    value: function isRepeatable() {
      return true;
    }
  }]);
  return PassthroughPatcher;
}(NodePatcher);

var IdentifierPatcher = function (_PassthroughPatcher) {
  inherits(IdentifierPatcher, _PassthroughPatcher);

  function IdentifierPatcher() {
    classCallCheck(this, IdentifierPatcher);
    return possibleConstructorReturn(this, (IdentifierPatcher.__proto__ || Object.getPrototypeOf(IdentifierPatcher)).apply(this, arguments));
  }

  createClass(IdentifierPatcher, [{
    key: 'negate',
    value: function negate() {
      this.insert(this.contentStart, '!');
    }
  }, {
    key: 'isRepeatable',
    value: function isRepeatable() {
      return true;
    }

    /**
     * Currently, break and continue are parsed as identifiers, but they need to
     * behave differently in some cases.
     */

  }, {
    key: 'canPatchAsExpression',
    value: function canPatchAsExpression() {
      return this.node.data !== 'break' && this.node.data !== 'continue';
    }
  }]);
  return IdentifierPatcher;
}(PassthroughPatcher);

/**
 * Handles bound functions that cannot become arrow functions.
 */

var ManuallyBoundFunctionPatcher = function (_FunctionPatcher) {
  inherits(ManuallyBoundFunctionPatcher, _FunctionPatcher);

  function ManuallyBoundFunctionPatcher() {
    classCallCheck(this, ManuallyBoundFunctionPatcher);
    return possibleConstructorReturn(this, (ManuallyBoundFunctionPatcher.__proto__ || Object.getPrototypeOf(ManuallyBoundFunctionPatcher)).apply(this, arguments));
  }

  createClass(ManuallyBoundFunctionPatcher, [{
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.insert(this.contentStart, '(');
      get$1(ManuallyBoundFunctionPatcher.prototype.__proto__ || Object.getPrototypeOf(ManuallyBoundFunctionPatcher.prototype), 'patchAsExpression', this).call(this, options);
      this.insert(this.contentEnd, '.bind(this))');
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      get$1(ManuallyBoundFunctionPatcher.prototype.__proto__ || Object.getPrototypeOf(ManuallyBoundFunctionPatcher.prototype), 'patchAsExpression', this).call(this, options);
      // If we're instructed to patch as a method, then it won't be legal to add
      // `.bind(this)`, so skip that step. Calling code is expected to bind us
      // some other way. In practice, this happens when patching class methods;
      // code will be added to the constructor to bind the method properly.
      if (!options.method) {
        this.insert(this.contentEnd, '.bind(this)');
      }
    }
  }, {
    key: 'expectedArrowType',
    value: function expectedArrowType() {
      return '=>';
    }
  }]);
  return ManuallyBoundFunctionPatcher;
}(FunctionPatcher);

var MemberAccessOpPatcher = function (_NodePatcher) {
  inherits(MemberAccessOpPatcher, _NodePatcher);

  function MemberAccessOpPatcher(node, context, editor, expression) {
    classCallCheck(this, MemberAccessOpPatcher);

    var _this = possibleConstructorReturn(this, (MemberAccessOpPatcher.__proto__ || Object.getPrototypeOf(MemberAccessOpPatcher)).call(this, node, context, editor));

    _this.expression = expression;
    _this._skipImplicitDotCreation = false;
    return _this;
  }

  createClass(MemberAccessOpPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.expression.setRequiresExpression();
    }
  }, {
    key: 'setSkipImplicitDotCreation',
    value: function setSkipImplicitDotCreation() {
      this._skipImplicitDotCreation = true;
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (this.lhsNeedsParens()) {
        this.insert(this.expression.outerStart, '(');
      }
      this.expression.patch();
      if (this.lhsNeedsParens()) {
        this.insert(this.expression.outerEnd, ')');
      }
      if (this.isShorthandPrototype()) {
        // `a::` → `a.prototype`
        //   ^^      ^^^^^^^^^^
        var operator = this.getMemberOperatorSourceToken();
        this.overwrite(operator.start, operator.end, '.prototype');
      }
      if (this.hasImplicitOperator() && !this._skipImplicitDotCreation) {
        // `@a` → `@.a`
        //          ^
        this.insert(this.expression.outerEnd, '.');
      }
    }
  }, {
    key: 'hasImplicitOperator',
    value: function hasImplicitOperator() {
      return !this.getMemberOperatorSourceToken();
    }
  }, {
    key: 'isShorthandPrototype',
    value: function isShorthandPrototype() {
      var token = this.getMemberOperatorSourceToken();
      return token ? token.type === coffeeLex.PROTO : false;
    }
  }, {
    key: 'getMemberOperatorSourceToken',
    value: function getMemberOperatorSourceToken() {
      var lastIndex = this.contentEndTokenIndex;
      var lastToken = this.sourceTokenAtIndex(lastIndex);

      if (lastToken.type === coffeeLex.PROTO) {
        // e.g. `a::`
        return lastToken;
      }

      var dotIndex = this.indexOfSourceTokenAfterSourceTokenIndex(this.expression.outerEndTokenIndex, coffeeLex.DOT);

      if (!dotIndex) {
        var firstIndex = this.contentStartTokenIndex;
        var firstToken = this.sourceTokenAtIndex(firstIndex);

        if (firstToken.type === coffeeLex.AT) {
          // e.g. `@a`, so it's okay that there's no dot
          return null;
        }

        throw this.error('cannot find \'.\' in member access');
      }

      // e.g. `a.b`
      return this.sourceTokenAtIndex(dotIndex);
    }
  }, {
    key: 'getMemberName',
    value: function getMemberName() {
      return this.node.memberName;
    }
  }, {
    key: 'getFullMemberName',
    value: function getFullMemberName() {
      return this.getMemberName();
    }
  }, {
    key: 'getMemberNameSourceToken',
    value: function getMemberNameSourceToken() {
      var tokens$$1 = this.context.sourceTokens;
      var index = tokens$$1.lastIndexOfTokenMatchingPredicate(function (token) {
        return token.type === coffeeLex.IDENTIFIER;
      }, this.contentEndTokenIndex);
      if (!index || index.isBefore(this.contentStartTokenIndex)) {
        throw this.error('unable to find member name token in access');
      }
      return tokens$$1.tokenAtIndex(index);
    }

    /**
     * Member access is repeatable (in CoffeeScript) if the expression we're
     * accessing a member of is also repeatable. Technically speaking even this is
     * not safe since member access can have side-effects via getters and setters,
     * but this is the way the official CoffeeScript compiler works so we follow
     * suit.
     */

  }, {
    key: 'isRepeatable',
    value: function isRepeatable() {
      return this.expression.isRepeatable();
    }

    /**
     * We can make member accesses repeatable by making the base expression
     * repeatable if it isn't already.
     */

  }, {
    key: 'makeRepeatable',
    value: function makeRepeatable(parens) {
      var ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      // eslint-disable-line no-unused-vars
      var expression = this.expression.makeRepeatable(true, 'base');
      return expression + '.' + this.getFullMemberName();
    }

    /**
     * If `BASE` needs parens, then `BASE.MEMBER` needs parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.expression.statementShouldAddParens();
    }
  }, {
    key: 'lhsNeedsParens',
    value: function lhsNeedsParens() {
      return this.expression.node.type === 'Int';
    }
  }]);
  return MemberAccessOpPatcher;
}(NodePatcher);

var BoundGeneratorFunctionPatcher = function (_ManuallyBoundFunctio) {
  inherits(BoundGeneratorFunctionPatcher, _ManuallyBoundFunctio);

  function BoundGeneratorFunctionPatcher() {
    classCallCheck(this, BoundGeneratorFunctionPatcher);
    return possibleConstructorReturn(this, (BoundGeneratorFunctionPatcher.__proto__ || Object.getPrototypeOf(BoundGeneratorFunctionPatcher)).apply(this, arguments));
  }

  createClass(BoundGeneratorFunctionPatcher, [{
    key: 'patchFunctionStart',
    value: function patchFunctionStart(_ref) {
      var _ref$method = _ref.method;
      var method = _ref$method === undefined ? false : _ref$method;

      var arrow = this.getArrowToken();

      if (!method) {
        this.insert(this.contentStart, 'function*');
      }

      if (!this.hasParamStart()) {
        this.insert(this.contentStart, '() ');
      }

      this.overwrite(arrow.start, arrow.end, '{');
    }
  }]);
  return BoundGeneratorFunctionPatcher;
}(ManuallyBoundFunctionPatcher);

/**
 * Handles generator functions, i.e. produced by embedding `yield` statements.
 */

var GeneratorFunctionPatcher = function (_FunctionPatcher) {
  inherits(GeneratorFunctionPatcher, _FunctionPatcher);

  function GeneratorFunctionPatcher() {
    classCallCheck(this, GeneratorFunctionPatcher);
    return possibleConstructorReturn(this, (GeneratorFunctionPatcher.__proto__ || Object.getPrototypeOf(GeneratorFunctionPatcher)).apply(this, arguments));
  }

  createClass(GeneratorFunctionPatcher, [{
    key: 'patchFunctionStart',
    value: function patchFunctionStart(_ref) {
      var _ref$method = _ref.method;
      var method = _ref$method === undefined ? false : _ref$method;

      var arrow = this.getArrowToken();

      if (!method) {
        this.insert(this.contentStart, 'function*');
      }

      if (!this.hasParamStart()) {
        this.insert(this.contentStart, '() ');
      }

      this.overwrite(arrow.start, arrow.end, '{');
    }
  }]);
  return GeneratorFunctionPatcher;
}(FunctionPatcher);

/**
 * Inserts string escape characters before certain characters/strings to be
 * escaped.
 *
 * The skipPattern parameter describes which already-escaped characters to skip
 * over. For normal strings, if we see any backslash, we skip it and the next
 * character, but for heregexes, we only skip a backslash followed by
 * whitespace.
 */
function escape(patcher, skipPattern, escapeStrings, start, end) {
  var source = patcher.original;

  var _loop = function _loop(_i) {
    if (skipPattern.test(source.slice(_i))) {
      _i++;
    } else if (escapeStrings.some(function (str) {
      return source.slice(_i, _i + str.length) === str;
    })) {
      patcher.appendRight(_i, '\\');
    }
    i = _i;
  };

  for (var i = start; i < end; i++) {
    _loop(i);
  }
}

var InterpolatedPatcher = function (_NodePatcher) {
  inherits(InterpolatedPatcher, _NodePatcher);

  function InterpolatedPatcher(node, context, editor, quasis, expressions) {
    classCallCheck(this, InterpolatedPatcher);

    var _this = possibleConstructorReturn(this, (InterpolatedPatcher.__proto__ || Object.getPrototypeOf(InterpolatedPatcher)).call(this, node, context, editor));

    _this.quasis = quasis;
    _this.expressions = expressions;
    return _this;
  }

  createClass(InterpolatedPatcher, [{
    key: 'initialize',
    value: function initialize() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.expressions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var expression = _step.value;

          expression.setRequiresExpression();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'patchInterpolations',
    value: function patchInterpolations() {
      for (var i = 0; i < this.expressions.length; i++) {
        var interpolationStart = this.getInterpolationStartTokenAtIndex(i);
        this.overwrite(interpolationStart.start, interpolationStart.start + 1, '$');
        this.expressions[i].patch();
      }
    }
  }, {
    key: 'getInterpolationStartTokenAtIndex',
    value: function getInterpolationStartTokenAtIndex(index) {
      var interpolationStartIndex = this.indexOfSourceTokenBetweenPatchersMatching(this.quasis[index], this.expressions[index], function (token) {
        return token.type === coffeeLex.INTERPOLATION_START;
      });
      if (!interpolationStartIndex) {
        this.error('Cannot find interpolation start for string interpolation.');
      }
      var interpolationStart = this.sourceTokenAtIndex(interpolationStartIndex);
      if (!interpolationStart || this.slice(interpolationStart.start, interpolationStart.start + 1) !== '#') {
        this.error("Cannot find '#' in interpolation start.");
      }
      return interpolationStart;
    }

    /**
     * Handle "padding" characters: characters like leading whitespace that should
     * be removed according to the lexing rules. In addition to STRING_PADDING
     * tokens, which indicate that the range should be removed, there are also
     * STRING_LINE_SEPARATOR tokens that indicate that the newlines should be
     * replaced with a space.
     *
     * To preserve the formatting of multiline strings a little better, newline
     * characters are escaped rather than removed.
     */

  }, {
    key: 'removePadding',
    value: function removePadding() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.quasis[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var quasi = _step2.value;

          var tokens$$1 = this.getProgramSourceTokens().slice(quasi.contentStartTokenIndex, quasi.contentEndTokenIndex.next()).toArray();
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = tokens$$1[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var token = _step3.value;

              if (token.type === coffeeLex.STRING_PADDING) {
                var paddingCode = this.slice(token.start, token.end);
                var numNewlines = (paddingCode.match(/\n/g) || []).length;
                this.overwrite(token.start, token.end, repeat('\\\n', numNewlines));
              } else if (token.type === coffeeLex.STRING_LINE_SEPARATOR) {
                this.insert(token.start, ' \\');
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'escapeQuasis',
    value: function escapeQuasis(skipPattern, escapeStrings) {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this.quasis[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var quasi = _step4.value;

          escape(this.editor, skipPattern, escapeStrings,
          // For now, clamp the quasi bounds to be strictly between the quotes.
          // Ideally, decaffeinate-parser would provide better location data
          // that would make this unnecessary.
          Math.max(quasi.contentStart, this.firstToken().end), Math.min(quasi.contentEnd, this.lastToken().start));
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  }, {
    key: 'isRepeatable',
    value: function isRepeatable() {
      return this.expressions.every(function (patcher) {
        return patcher.isRepeatable();
      });
    }
  }]);
  return InterpolatedPatcher;
}(NodePatcher);

/**
 * Patcher to handle all types of strings, whether or not they have
 * interpolations and whether or not they are multiline.
 */

var StringPatcher = function (_InterpolatedPatcher) {
  inherits(StringPatcher, _InterpolatedPatcher);

  function StringPatcher() {
    classCallCheck(this, StringPatcher);
    return possibleConstructorReturn(this, (StringPatcher.__proto__ || Object.getPrototypeOf(StringPatcher)).apply(this, arguments));
  }

  createClass(StringPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var shouldBecomeTemplateLiteral = this.shouldBecomeTemplateLiteral();

      var escapeStrings = [];
      var openQuoteToken = this.firstToken();
      var closeQuoteToken = this.lastToken();

      if (shouldBecomeTemplateLiteral) {
        escapeStrings.push('`');
        escapeStrings.push('${');
        this.overwrite(openQuoteToken.start, openQuoteToken.end, '`');
        this.overwrite(closeQuoteToken.start, closeQuoteToken.end, '`');
      } else if (openQuoteToken.type === coffeeLex.TSSTRING_START) {
        escapeStrings.push('\'');
        this.overwrite(openQuoteToken.start, openQuoteToken.end, '\'');
        this.overwrite(closeQuoteToken.start, closeQuoteToken.end, '\'');
      } else if (openQuoteToken.type === coffeeLex.TDSTRING_START) {
        escapeStrings.push('"');
        this.overwrite(openQuoteToken.start, openQuoteToken.end, '"');
        this.overwrite(closeQuoteToken.start, closeQuoteToken.end, '"');
      }

      this.patchInterpolations();
      this.removePadding();
      if (escapeStrings.length > 0) {
        this.escapeQuasis(/^\\/, escapeStrings);
      }
    }
  }, {
    key: 'shouldBecomeTemplateLiteral',
    value: function shouldBecomeTemplateLiteral() {
      return this.expressions.length > 0 || this.node.raw.indexOf('\n') > -1;
    }
  }]);
  return StringPatcher;
}(InterpolatedPatcher);

/**
 * Handles object properties.
 */
var ObjectBodyMemberPatcher = function (_NodePatcher) {
  inherits(ObjectBodyMemberPatcher, _NodePatcher);

  function ObjectBodyMemberPatcher(node, context, editor, key, expression) {
    classCallCheck(this, ObjectBodyMemberPatcher);

    var _this = possibleConstructorReturn(this, (ObjectBodyMemberPatcher.__proto__ || Object.getPrototypeOf(ObjectBodyMemberPatcher)).call(this, node, context, editor));

    _this.key = key;
    _this.expression = expression;
    return _this;
  }

  createClass(ObjectBodyMemberPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.key.setRequiresExpression();
      this.expression.setRequiresExpression();
    }

    /**
     * KEY : EXPRESSION
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.isMethod()) {
        this.patchAsMethod(options);
      } else {
        this.patchAsProperty(options);
      }
    }
  }, {
    key: 'patchAsMethod',
    value: function patchAsMethod() {
      if (this.isGeneratorMethod()) {
        this.insert(this.key.outerStart, '*');
      }
      var isComputed = this.isMethodNameComputed();
      if (isComputed) {
        // `{ 'hi there': ->` → `{ ['hi there': ->`
        //                         ^
        this.insert(this.key.outerStart, '[');
      }
      this.patchKey();
      if (isComputed) {
        // `{ ['hi there': ->` → `{ ['hi there']: ->`
        //                                     ^
        this.insert(this.key.outerEnd, ']');
      }
      // `{ ['hi there']: ->` → `{ ['hi there']->`
      //                ^^
      this.remove(this.key.outerEnd, this.expression.outerStart);
      // The function expression might be surrounded by parens, so remove them if
      // necessary.
      this.remove(this.expression.outerStart, this.expression.contentStart);
      this.remove(this.expression.contentEnd, this.expression.outerEnd);
      this.patchExpression();
    }
  }, {
    key: 'patchAsProperty',
    value: function patchAsProperty() {
      this.patchKey();
      this.patchExpression();
    }
  }, {
    key: 'patchKey',
    value: function patchKey() {
      var computedKeyPatcher = this.getComputedKeyPatcher();
      if (computedKeyPatcher !== null) {
        this.overwrite(this.key.outerStart, computedKeyPatcher.outerStart, '[');
        computedKeyPatcher.patch();
        this.overwrite(computedKeyPatcher.outerEnd, this.key.outerEnd, ']');
      } else {
        var needsBrackets = !(this.key instanceof StringPatcher && !this.key.shouldBecomeTemplateLiteral()) && !(this.key instanceof IdentifierPatcher);
        if (needsBrackets) {
          this.insert(this.key.outerStart, '[');
        }
        this.key.patch();
        if (needsBrackets) {
          this.insert(this.key.outerEnd, ']');
        }
      }
    }

    /**
     * As a special case, transform {"#{a.b}": c} to {[a.b]: c}, since a template
     * literal is the best way to do computed keys in CoffeeScript. This method
     * gets the patcher for that computed key node, if any.
     */

  }, {
    key: 'getComputedKeyPatcher',
    value: function getComputedKeyPatcher() {
      if (this.key instanceof StringPatcher && this.key.quasis.length === 2 && this.key.expressions.length === 1 && this.key.quasis[0].node.data === '' && this.key.quasis[1].node.data === '') {
        return this.key.expressions[0];
      }
      return null;
    }
  }, {
    key: 'patchExpression',
    value: function patchExpression() {
      this.expression.patch({ method: this.isMethod() });
    }

    /**
     * @protected
     */

  }, {
    key: 'isMethodNameComputed',
    value: function isMethodNameComputed() {
      return !(this.key instanceof IdentifierPatcher);
    }

    /**
     * In normal object bodies, we can use method syntax for normal arrow
     * functions and for normal generator functions. If we need to explicitly add
     * `.bind(this)`, then we won't be able to use the method form. But for
     * classes, since the binding is done in the constructor, we can still use
     * method syntax, so ClassAssignOpPatcher overrides this method for that case.
     * We also allow ClassBoundMethodFunctionPatcher since that only comes up in
     * the class case.
     *
     * @protected
     */

  }, {
    key: 'isMethod',
    value: function isMethod() {
      return this.expression instanceof FunctionPatcher && !(this.expression instanceof ManuallyBoundFunctionPatcher) && !(this.expression instanceof BoundFunctionPatcher);
    }

    /**
     * Note that we include BoundGeneratorFunctionPatcher, even though the object
     * case doesn't treat it as a method, since the class case should use a
     * generator method.
     *
     * @protected
     */

  }, {
    key: 'isGeneratorMethod',
    value: function isGeneratorMethod() {
      return this.expression instanceof GeneratorFunctionPatcher || this.expression instanceof BoundGeneratorFunctionPatcher;
    }
  }]);
  return ObjectBodyMemberPatcher;
}(NodePatcher);

var ThisPatcher = function (_NodePatcher) {
  inherits(ThisPatcher, _NodePatcher);

  function ThisPatcher() {
    classCallCheck(this, ThisPatcher);
    return possibleConstructorReturn(this, (ThisPatcher.__proto__ || Object.getPrototypeOf(ThisPatcher)).apply(this, arguments));
  }

  createClass(ThisPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (this.isShorthandThis()) {
        this.overwrite(this.contentStart, this.contentEnd, 'this');
      }
    }
  }, {
    key: 'isShorthandThis',
    value: function isShorthandThis() {
      return this.getOriginalSource() === '@';
    }
  }, {
    key: 'isRepeatable',
    value: function isRepeatable() {
      return true;
    }
  }, {
    key: 'makeRepeatable',
    value: function makeRepeatable(parens) {
      var ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      // eslint-disable-line no-unused-vars
      return 'this';
    }
  }]);
  return ThisPatcher;
}(NodePatcher);

/**
 * Handles object properties.
 */

var ObjectInitialiserMemberPatcher = function (_ObjectBodyMemberPatc) {
  inherits(ObjectInitialiserMemberPatcher, _ObjectBodyMemberPatc);

  function ObjectInitialiserMemberPatcher() {
    classCallCheck(this, ObjectInitialiserMemberPatcher);
    return possibleConstructorReturn(this, (ObjectInitialiserMemberPatcher.__proto__ || Object.getPrototypeOf(ObjectInitialiserMemberPatcher)).apply(this, arguments));
  }

  createClass(ObjectInitialiserMemberPatcher, [{
    key: 'patchAsProperty',
    value: function patchAsProperty() {
      if (this.key.node === this.expression.node) {
        this.patchAsShorthand({
          expand: this.key.node.type !== 'Identifier'
        });
      } else {
        get$1(ObjectInitialiserMemberPatcher.prototype.__proto__ || Object.getPrototypeOf(ObjectInitialiserMemberPatcher.prototype), 'patchAsProperty', this).call(this);
      }
    }

    /**
     * @private
     */

  }, {
    key: 'patchAsShorthand',
    value: function patchAsShorthand() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _ref$expand = _ref.expand;
      var expand = _ref$expand === undefined ? false : _ref$expand;
      var key = this.key;

      if (key instanceof MemberAccessOpPatcher) {
        key.patch();
        // e.g. `{ @name }`
        var memberAccessKey = key;
        if (!(memberAccessKey.expression instanceof ThisPatcher)) {
          throw this.error('expected property key member access on \'this\', e.g. \'@name\'');
        }
        // `{ @name }` → `{ name: @name }`
        //                  ^^^^^^
        this.insert(memberAccessKey.outerStart, memberAccessKey.getMemberName() + ': ');
      } else if (expand) {
        var isComputed = key instanceof StringPatcher && key.shouldBecomeTemplateLiteral();

        if (isComputed) {
          // `{ `a = ${1 + 1}` }` → `{ [`a = ${1 + 1}` }`
          //                           ^
          this.insert(key.outerStart, '[');
        }

        var valueCode = void 0;
        if (key.isRepeatable()) {
          valueCode = key.patchAndGetCode();
        } else {
          key.patch();
          valueCode = key.makeRepeatable();
        }

        if (isComputed) {
          this.insert(key.outerEnd, ']');
        }

        // `{ a } → { a: a }`
        //             ^^^
        this.insert(key.outerEnd, ': ' + valueCode);
      }
    }
  }]);
  return ObjectInitialiserMemberPatcher;
}(ObjectBodyMemberPatcher);

/**
 * Handles object literals.
 */

var ObjectInitialiserPatcher = function (_NodePatcher) {
  inherits(ObjectInitialiserPatcher, _NodePatcher);

  function ObjectInitialiserPatcher(node, context, editor, members) {
    classCallCheck(this, ObjectInitialiserPatcher);

    var _this = possibleConstructorReturn(this, (ObjectInitialiserPatcher.__proto__ || Object.getPrototypeOf(ObjectInitialiserPatcher)).call(this, node, context, editor));

    _this.members = members;
    return _this;
  }

  createClass(ObjectInitialiserPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.members.forEach(function (member) {
        return member.setRequiresExpression();
      });
    }

    /**
     * Objects as expressions are very similar to their CoffeeScript equivalents.
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var implicitObject = this.isImplicitObject();
      if (implicitObject) {
        var curlyBraceInsertionPosition = this.innerStart;
        var textToInsert = '{';
        var shouldIndent = false;
        if (this.shouldExpandCurlyBraces()) {
          if (this.implicitlyReturns() && !this.isSurroundedByParentheses()) {
            textToInsert = '{\n' + this.getIndent();
            shouldIndent = true;
          } else {
            var tokenIndexBeforeOuterStartTokenIndex = this.outerStartTokenIndex;
            if (!this.isSurroundedByParentheses()) {
              tokenIndexBeforeOuterStartTokenIndex = tokenIndexBeforeOuterStartTokenIndex.previous();
            }

            if (tokenIndexBeforeOuterStartTokenIndex) {
              var precedingTokenIndex = this.context.sourceTokens.lastIndexOfTokenMatchingPredicate(isSemanticToken, tokenIndexBeforeOuterStartTokenIndex);
              if (precedingTokenIndex) {
                var precedingToken = this.sourceTokenAtIndex(precedingTokenIndex);
                curlyBraceInsertionPosition = precedingToken.end;
                var precedingTokenText = this.sourceOfToken(precedingToken);
                var lastCharOfToken = precedingTokenText[precedingTokenText.length - 1];
                var needsSpace = lastCharOfToken === ':' || lastCharOfToken === '=' || lastCharOfToken === ',';
                if (needsSpace) {
                  textToInsert = ' {';
                }
              }
            }
          }
        }
        this.insert(curlyBraceInsertionPosition, textToInsert);
        if (shouldIndent) {
          this.indent();
        }
      }
      this.patchMembers();
      if (implicitObject) {
        if (this.shouldExpandCurlyBraces() && !this.isSurroundedByParentheses()) {
          this.appendLineAfter('}', -1);
        } else {
          this.insert(this.innerEnd, '}');
        }
      }
    }

    /**
     * Objects as statements need to be wrapped in parentheses, or else they'll be
     * confused with blocks. That is, this is not an object [1]:
     *
     *   { a: 0 };
     *
     * But this is fine:
     *
     *   ({ a: 0 });
     *
     * [1]: It is actually valid code, though. It's a block with a labeled
     * statement `a` with a single expression statement, being the literal 0.
     */

  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var needsParentheses = !this.isSurroundedByParentheses();
      var implicitObject = this.isImplicitObject();
      if (needsParentheses) {
        this.insert(this.contentStart, '(');
      }
      if (implicitObject) {
        if (this.shouldExpandCurlyBraces() && !this.isSurroundedByParentheses()) {
          this.insert(this.innerStart, '{\n' + this.getIndent());
          this.indent();
        } else {
          this.insert(this.innerStart, '{');
        }
      }
      this.patchMembers();
      if (implicitObject) {
        if (this.shouldExpandCurlyBraces() && !this.isSurroundedByParentheses()) {
          this.appendLineAfter('}', -1);
        } else {
          this.insert(this.innerEnd, '}');
        }
      }
      if (needsParentheses) {
        this.insert(this.contentEnd, ')');
      }
    }

    /**
     * @private
     */

  }, {
    key: 'shouldExpandCurlyBraces',
    value: function shouldExpandCurlyBraces() {
      return this.isMultiline() || this.parent instanceof ObjectInitialiserMemberPatcher;
    }

    /**
     * @private
     */

  }, {
    key: 'patchMembers',
    value: function patchMembers() {
      var _this2 = this;

      this.members.forEach(function (member, i, members) {
        member.patch();
        if (i !== members.length - 1) {
          if (!member.hasSourceTokenAfter(coffeeLex.COMMA)) {
            _this2.insert(member.outerEnd, ',');
          }
        }
      });
    }

    /**
     * Determines whether this object is implicit, i.e. it lacks braces.
     *
     *   a: b      # true
     *   { a: b }  # false
     */

  }, {
    key: 'isImplicitObject',
    value: function isImplicitObject() {
      var tokens$$1 = this.context.sourceTokens;
      var indexOfFirstToken = tokens$$1.indexOfTokenStartingAtSourceIndex(this.contentStart);
      return tokens$$1.tokenAtIndex(indexOfFirstToken).type !== coffeeLex.LBRACE;
    }

    /**
     * Starting a statement with an object always requires parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return true;
    }
  }]);
  return ObjectInitialiserPatcher;
}(NodePatcher);

/**
 * Determine if this is a block where the only contents are an object literal.
 */
function isObjectInitialiserBlock(patcher) {
  return patcher instanceof BlockPatcher && patcher.statements.length === 1 && patcher.statements[0] instanceof ObjectInitialiserPatcher;
}

/**
 * Traverses an AST node, calling a callback for each node in the hierarchy in
 * source order.
 */
function traverse(node, callback) {
  var descended = false;

  function descend(parent) {
    descended = true;

    childPropertyNames(parent).forEach(function (property) {
      var value = parent[property];
      if (Array.isArray(value)) {
        value.forEach(function (child) {
          child.parentNode = parent;
          traverse(child, callback);
        });
      } else if (value) {
        value.parentNode = parent;
        traverse(value, callback);
      }
    });
  }

  var shouldDescend = callback(node, descend, childPropertyNames(node).length === 0);

  if (!descended && shouldDescend !== false) {
    descend(node);
  }
}

var ORDER = {
  ArrayInitialiser: ['members'],
  AssignOp: ['assignee', 'expression'],
  BitAndOp: ['left', 'right'],
  BitNotOp: ['expression'],
  BitOrOp: ['left', 'right'],
  BitXorOp: ['left', 'right'],
  Block: ['statements'],
  Bool: [],
  BoundFunction: ['parameters', 'body'],
  BoundGeneratorFunction: ['parameters', 'body'],
  Break: [],
  ChainedComparisonOp: ['expression'],
  Class: ['nameAssignee', 'parent', 'body'],
  ClassProtoAssignOp: ['assignee', 'expression'],
  CompoundAssignOp: ['assignee', 'expression'],
  Conditional: ['condition', 'consequent', 'alternate'],
  Constructor: ['assignee', 'expression'],
  Continue: [],
  DefaultParam: ['param', 'default'],
  DeleteOp: ['expression'],
  DivideOp: ['left', 'right'],
  DoOp: ['expression'],
  DynamicMemberAccessOp: ['expression', 'indexingExpr'],
  EQOp: ['left', 'right'],
  ExistsOp: ['left', 'right'],
  Expansion: [],
  ExpOp: ['left', 'right'],
  ExtendsOp: ['left', 'right'],
  Float: [],
  FloorDivideOp: ['left', 'right'],
  ForIn: ['keyAssignee', 'valAssignee', 'target', 'step', 'filter', 'body'],
  ForOf: ['keyAssignee', 'valAssignee', 'target', 'filter', 'body'],
  Function: ['parameters', 'body'],
  FunctionApplication: ['function', 'arguments'],
  GeneratorFunction: ['parameters', 'body'],
  GTEOp: ['left', 'right'],
  GTOp: ['left', 'right'],
  Heregex: ['quasis', 'expressions'],
  Identifier: [],
  InOp: ['left', 'right'],
  InstanceofOp: ['left', 'right'],
  Int: [],
  JavaScript: [],
  LTEOp: ['left', 'right'],
  LTOp: ['left', 'right'],
  LeftShiftOp: ['left', 'right'],
  LogicalAndOp: ['left', 'right'],
  LogicalNotOp: ['expression'],
  LogicalOrOp: ['left', 'right'],
  MemberAccessOp: ['expression'],
  ModuloOp: ['left', 'right'],
  MultiplyOp: ['left', 'right'],
  NEQOp: ['left', 'right'],
  NewOp: ['ctor', 'arguments'],
  Null: [],
  ObjectInitialiser: ['members'],
  ObjectInitialiserMember: ['key', 'expression'],
  OfOp: ['left', 'right'],
  PlusOp: ['left', 'right'],
  PostDecrementOp: ['expression'],
  PostIncrementOp: ['expression'],
  PreDecrementOp: ['expression'],
  PreIncrementOp: ['expression'],
  Program: ['body'],
  ProtoMemberAccessOp: ['expression'],
  Quasi: [],
  Range: ['left', 'right'],
  RegExp: [],
  RemOp: ['left', 'right'],
  Rest: ['expression'],
  Return: ['expression'],
  SeqOp: ['left', 'right'],
  SignedRightShiftOp: ['left', 'right'],
  Slice: ['expression', 'left', 'right'],
  SoakedDynamicMemberAccessOp: ['expression', 'indexingExpr'],
  SoakedFunctionApplication: ['function', 'arguments'],
  SoakedMemberAccessOp: ['expression'],
  Spread: ['expression'],
  String: ['quasis', 'expressions'],
  SubtractOp: ['left', 'right'],
  Super: [],
  Switch: ['expression', 'cases', 'alternate'],
  SwitchCase: ['conditions', 'consequent'],
  This: [],
  Throw: ['expression'],
  Try: ['body', 'catchAssignee', 'catchBody', 'finallyBody'],
  TypeofOp: ['expression'],
  UnaryExistsOp: ['expression'],
  UnaryNegateOp: ['expression'],
  UnaryPlusOp: ['expression'],
  Undefined: [],
  UnsignedRightShiftOp: ['left', 'right'],
  While: ['condition', 'guard', 'body'],
  Yield: ['expression'],
  YieldFrom: ['expression']
};

function childPropertyNames(node) {
  var names = ORDER[node.type];

  if (!names) {
    throw new Error('cannot traverse unknown node type: ' + node.type);
  }

  return names;
}

/**
 * Handles bound functions, i.e. "fat arrows".
 */

var BoundFunctionPatcher = function (_FunctionPatcher) {
  inherits(BoundFunctionPatcher, _FunctionPatcher);

  function BoundFunctionPatcher() {
    classCallCheck(this, BoundFunctionPatcher);
    return possibleConstructorReturn(this, (BoundFunctionPatcher.__proto__ || Object.getPrototypeOf(BoundFunctionPatcher)).apply(this, arguments));
  }

  createClass(BoundFunctionPatcher, [{
    key: 'initialize',
    value: function initialize() {
      get$1(BoundFunctionPatcher.prototype.__proto__ || Object.getPrototypeOf(BoundFunctionPatcher.prototype), 'initialize', this).call(this);
      if (this.hasInlineBody()) {
        this.body.setExpression();
      }
    }

    /**
     * Use a slightly-modified version of the regular `FunctionPatcher` when
     * we can't use arrow functions.
     */

  }, {
    key: 'patchAsStatement',


    // There's no difference between statement and expression arrow functions.
    value: function patchAsStatement() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.patchAsExpression(options);
    }
  }, {
    key: 'patchFunctionStart',
    value: function patchFunctionStart() {
      var arrow = this.getArrowToken();

      if (!this.hasParamStart()) {
        this.insert(this.contentStart, '() ');
      } else if (!this.parameterListNeedsParentheses()) {
        var _parameters = slicedToArray(this.parameters, 1);

        var param = _parameters[0];

        if (param.isSurroundedByParentheses()) {
          this.remove(param.outerStart, param.contentStart);
          this.remove(param.contentEnd, param.outerEnd);
        }
      }

      if (!this.willPatchBodyInline()) {
        this.insert(arrow.end, ' {');
      }
    }
  }, {
    key: 'parameterListNeedsParentheses',
    value: function parameterListNeedsParentheses() {
      var parameters = this.parameters;

      if (parameters.length !== 1) {
        return true;
      }

      var _parameters2 = slicedToArray(parameters, 1);

      var param = _parameters2[0];

      return !(param instanceof IdentifierPatcher);
    }
  }, {
    key: 'patchFunctionBody',
    value: function patchFunctionBody() {
      if (this.body) {
        if (!this.willPatchBodyInline()) {
          this.body.patch({ leftBrace: false });
        } else {
          if (isObjectInitialiserBlock(this.body)) {
            this.body.surroundInParens();
          }
          this.body.patch();
        }
      } else {
        // No body, so BlockPatcher can't insert it for us.
        this.insert(this.innerEnd, '}');
      }
    }
  }, {
    key: 'expectedArrowType',
    value: function expectedArrowType() {
      return '=>';
    }
  }, {
    key: 'willPatchBodyInline',
    value: function willPatchBodyInline() {
      return this.body ? this.body.willPatchAsExpression() : false;
    }
  }, {
    key: 'hasInlineBody',
    value: function hasInlineBody() {
      return this.body ? this.body.inline() : false;
    }

    /**
     * Bound functions already start with a paren or a param identifier, and so
     * are safe to start a statement.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }], [{
    key: 'patcherClassOverrideForNode',
    value: function patcherClassOverrideForNode(node) {
      var referencesArguments = false;

      traverse(node, function (child) {
        if (referencesArguments) {
          // We already found a reference, so skip this.
          return false;
        } else if (child.type === 'Identifier' && child.data === 'arguments') {
          referencesArguments = true;
        } else if (child !== node && isFunction(child)) {
          // Don't descend into other functions.
          return false;
        }
      });

      if (referencesArguments) {
        return ManuallyBoundFunctionPatcher;
      } else {
        return null;
      }
    }
  }]);
  return BoundFunctionPatcher;
}(FunctionPatcher);

/**
 * Handles constructs of the form `a < b < c < … < z`.
 */
var ChainedComparisonOpPatcher = function (_NodePatcher) {
  inherits(ChainedComparisonOpPatcher, _NodePatcher);

  /**
   * `node` should have type `ChainedComparisonOp`.
   */
  function ChainedComparisonOpPatcher(node, context, editor, expression) {
    classCallCheck(this, ChainedComparisonOpPatcher);

    var _this = possibleConstructorReturn(this, (ChainedComparisonOpPatcher.__proto__ || Object.getPrototypeOf(ChainedComparisonOpPatcher)).call(this, node, context, editor));

    _this.expression = expression;
    _this.negated = false;
    return _this;
  }

  createClass(ChainedComparisonOpPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.expression.setRequiresExpression();
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _this2 = this;

      this.expression.patch();
      this.getMiddleOperands().forEach(function (middle) {
        var middleAgain = middle.makeRepeatable(true, 'middle');
        // `a < b < c` → `a < b && b < c`
        //                     ^^^^^
        _this2.insert(middle.outerEnd, ' ' + (_this2.negated ? '||' : '&&') + ' ' + middleAgain);
      });
    }

    /**
     * @private
     */

  }, {
    key: 'getMiddleOperands',
    value: function getMiddleOperands() {
      var result = [];
      var comparison = this.expression.left;
      while (comparison instanceof BinaryOpPatcher) {
        result.unshift(comparison.right);
        comparison = comparison.left;
      }
      return result;
    }
  }, {
    key: 'negate',
    value: function negate() {
      this.negated = !this.negated;
      var comparison = this.expression;
      while (comparison instanceof BinaryOpPatcher) {
        comparison.negate();
        comparison = comparison.left;
      }
    }

    /**
     * Forward the request to the underlying comparison operator.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.expression.statementNeedsParens();
    }
  }]);
  return ChainedComparisonOpPatcher;
}(NodePatcher);

var ClassBoundMethodFunctionPatcher = function (_FunctionPatcher) {
  inherits(ClassBoundMethodFunctionPatcher, _FunctionPatcher);

  function ClassBoundMethodFunctionPatcher() {
    classCallCheck(this, ClassBoundMethodFunctionPatcher);
    return possibleConstructorReturn(this, (ClassBoundMethodFunctionPatcher.__proto__ || Object.getPrototypeOf(ClassBoundMethodFunctionPatcher)).apply(this, arguments));
  }

  createClass(ClassBoundMethodFunctionPatcher, [{
    key: 'expectedArrowType',
    value: function expectedArrowType() {
      return '=>';
    }
  }]);
  return ClassBoundMethodFunctionPatcher;
}(FunctionPatcher);

var ClassAssignOpPatcher = function (_ObjectBodyMemberPatc) {
  inherits(ClassAssignOpPatcher, _ObjectBodyMemberPatc);

  function ClassAssignOpPatcher() {
    classCallCheck(this, ClassAssignOpPatcher);
    return possibleConstructorReturn(this, (ClassAssignOpPatcher.__proto__ || Object.getPrototypeOf(ClassAssignOpPatcher)).apply(this, arguments));
  }

  createClass(ClassAssignOpPatcher, [{
    key: 'statementNeedsSemicolon',


    /**
     * Don't put semicolons after methods.
     */
    value: function statementNeedsSemicolon() {
      return !this.isMethod();
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      get$1(ClassAssignOpPatcher.prototype.__proto__ || Object.getPrototypeOf(ClassAssignOpPatcher.prototype), 'patchAsExpression', this).call(this);
      if (this.isStaticMethod()) {
        // `this.a: ->` → `static a: ->`
        //  ^^^^^          ^^^^^^^
        var memberNameToken = this.key.getMemberNameSourceToken();
        this.overwrite(this.key.outerStart, memberNameToken.start, 'static ');
      }
    }

    /**
     * @protected
     */

  }, {
    key: 'patchKey',
    value: function patchKey() {}
    // Don't bother, we handle it at this level.


    /**
     * @protected
     */

  }, {
    key: 'patchAsProperty',
    value: function patchAsProperty() {
      // `name: null` → `name = null`
      //      ^^             ^^^
      var colonIndex = this.indexOfSourceTokenBetweenPatchersMatching(this.key, this.expression, function (token) {
        return token.type === coffeeLex.COLON;
      });
      if (!colonIndex) {
        throw this.error('expected a colon between the key and expression of a class property');
      }
      var colonToken = this.sourceTokenAtIndex(colonIndex);
      this.overwrite(colonToken.start, colonToken.end, ' =');
      this.patchExpression();
    }

    /**
     * Determines whether this class assignment has a computed key.
     *
     * @protected
     */

  }, {
    key: 'isMethodNameComputed',
    value: function isMethodNameComputed() {
      if (!get$1(ClassAssignOpPatcher.prototype.__proto__ || Object.getPrototypeOf(ClassAssignOpPatcher.prototype), 'isMethodNameComputed', this).call(this)) {
        return false;
      }
      return !this.isStaticMethod();
    }

    /**
     * Determines if this class assignment matches the known patterns for static
     * methods in CoffeeScript, i.e.
     *
     *   class A
     *     this.a: ->
     *     @b: ->
     *     A.c: ->
     *
     * @protected
     */

  }, {
    key: 'isStaticMethod',
    value: function isStaticMethod() {
      if (!(this.key instanceof MemberAccessOpPatcher)) {
        return false;
      }

      var memberObject = this.key.expression;
      if (memberObject instanceof ThisPatcher) {
        return true;
      }

      var className = this.parent.parent.nameAssignee;
      return className instanceof IdentifierPatcher && memberObject instanceof IdentifierPatcher && className.node.data === className.node.data;
    }
  }, {
    key: 'isBoundInstanceMethod',
    value: function isBoundInstanceMethod() {
      return !this.isStaticMethod() && (this.expression.node.type === 'BoundFunction' || this.expression.node.type === 'BoundGeneratorFunction');
    }

    /**
     * For classes, unlike in objects, manually bound methods can use regular
     * method syntax because the bind happens in the constructor.
     *
     * @protected
     */

  }, {
    key: 'isMethod',
    value: function isMethod() {
      return this.expression instanceof ManuallyBoundFunctionPatcher || get$1(ClassAssignOpPatcher.prototype.__proto__ || Object.getPrototypeOf(ClassAssignOpPatcher.prototype), 'isMethod', this).call(this);
    }
  }], [{
    key: 'patcherClassForChildNode',
    value: function patcherClassForChildNode(node, property) {
      if (property === 'expression' && node.type === 'BoundFunction') {
        return ClassBoundMethodFunctionPatcher;
      }
      return null;
    }
  }]);
  return ClassAssignOpPatcher;
}(ObjectBodyMemberPatcher);

var ConstructorPatcher = function (_ObjectBodyMemberPatc) {
  inherits(ConstructorPatcher, _ObjectBodyMemberPatc);

  function ConstructorPatcher(node, context, editor, assignee, expression) {
    classCallCheck(this, ConstructorPatcher);

    // Constructor methods do not have implicit returns.
    var _this = possibleConstructorReturn(this, (ConstructorPatcher.__proto__ || Object.getPrototypeOf(ConstructorPatcher)).call(this, node, context, editor, assignee, expression));

    expression.disableImplicitReturns();
    return _this;
  }

  createClass(ConstructorPatcher, [{
    key: 'patch',
    value: function patch() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      get$1(ConstructorPatcher.prototype.__proto__ || Object.getPrototypeOf(ConstructorPatcher.prototype), 'patch', this).call(this, options);
      var boundMethods = this.parent.boundInstanceMethods();
      if (boundMethods.length > 0) {
        var statements = this.expression.body.statements;
        var indexOfSuperStatement = -1;

        var _loop = function _loop(i) {
          var callsSuper = false;
          traverse(statements[i].node, function (child) {
            if (callsSuper) {
              // Already found it, skip this one.
              return false;
            } else if (child.type === 'Super') {
              // Found it.
              callsSuper = true;
            } else if (child.type === 'Class') {
              // Don't go into other classes.
              return false;
            }
          });
          if (callsSuper) {
            indexOfSuperStatement = i;
            return 'break';
          }
        };

        for (var i = 0; i < statements.length; i++) {
          var _ret = _loop(i);

          if (_ret === 'break') break;
        }
        var bindings = boundMethods.map(function (method) {
          var key = _this2.context.source.slice(method.key.contentStart, method.key.contentEnd);
          return 'this.' + key + ' = this.' + key + '.bind(this)';
        });
        this.expression.body.insertStatementsAtIndex(bindings, indexOfSuperStatement + 1);
      }
    }

    /**
     * Don't put semicolons after class constructors.
     */

  }, {
    key: 'statementNeedsSemicolon',
    value: function statementNeedsSemicolon() {
      return false;
    }
  }]);
  return ConstructorPatcher;
}(ObjectBodyMemberPatcher);

var ClassBlockPatcher = function (_BlockPatcher) {
  inherits(ClassBlockPatcher, _BlockPatcher);

  function ClassBlockPatcher() {
    classCallCheck(this, ClassBlockPatcher);
    return possibleConstructorReturn(this, (ClassBlockPatcher.__proto__ || Object.getPrototypeOf(ClassBlockPatcher)).apply(this, arguments));
  }

  createClass(ClassBlockPatcher, [{
    key: 'patch',
    value: function patch() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.hasConstructor()) {
        var boundMethods = this.boundInstanceMethods();
        if (boundMethods.length > 0) {
          (function () {
            var source = _this2.context.source;

            var insertionPoint = _this2.statements[0].outerStart;
            var methodIndent = adjustIndent(source, insertionPoint, 0);
            var methodBodyIndent = adjustIndent(source, insertionPoint, 1);
            var constructor = '';
            if (_this2.getClassPatcher().isSubclass()) {
              constructor += 'constructor(...args) {\n' + methodBodyIndent + 'super(...args);\n';
            } else {
              constructor += 'constructor() {\n';
            }
            boundMethods.forEach(function (method) {
              var key = source.slice(method.key.contentStart, method.key.contentEnd);
              constructor += methodBodyIndent + 'this.' + key + ' = this.' + key + '.bind(this);\n';
            });
            constructor += methodIndent + '}\n\n' + methodIndent;
            _this2.insert(insertionPoint, constructor);
          })();
        }
      }
      get$1(ClassBlockPatcher.prototype.__proto__ || Object.getPrototypeOf(ClassBlockPatcher.prototype), 'patch', this).call(this, options);
    }
  }, {
    key: 'getClassPatcher',
    value: function getClassPatcher() {
      return this.parent;
    }
  }, {
    key: 'canPatchAsExpression',
    value: function canPatchAsExpression() {
      return false;
    }
  }, {
    key: 'hasConstructor',
    value: function hasConstructor() {
      return this.statements.some(function (statement) {
        return statement instanceof ConstructorPatcher;
      });
    }
  }, {
    key: 'boundInstanceMethods',
    value: function boundInstanceMethods() {
      return this.statements.filter(function (statement) {
        if (statement instanceof ClassAssignOpPatcher) {
          return statement.isBoundInstanceMethod();
        } else {
          return false;
        }
      });
    }
  }], [{
    key: 'patcherClassForChildNode',
    value: function patcherClassForChildNode(node, property) {
      if (property === 'statements' && node.type === 'AssignOp') {
        return ClassAssignOpPatcher;
      }
    }
  }]);
  return ClassBlockPatcher;
}(BlockPatcher);

var ClassPatcher = function (_NodePatcher) {
  inherits(ClassPatcher, _NodePatcher);

  function ClassPatcher(node, context, editor, nameAssignee, parent, body) {
    classCallCheck(this, ClassPatcher);

    var _this = possibleConstructorReturn(this, (ClassPatcher.__proto__ || Object.getPrototypeOf(ClassPatcher)).call(this, node, context, editor));

    _this.nameAssignee = nameAssignee;
    _this.superclass = parent;
    _this.body = body;
    return _this;
  }

  createClass(ClassPatcher, [{
    key: 'initialize',
    value: function initialize() {
      if (this.nameAssignee) {
        this.nameAssignee.setRequiresExpression();
      }
      if (this.superclass) {
        this.superclass.setRequiresExpression();
      }
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var hasParens = this.isSurroundedByParentheses();
      var anonymous = this.isAnonymous();
      if (anonymous && !hasParens) {
        // `class` → `(class`
        //            ^
        this.insert(this.innerStart, '(');
      }

      this.patchAsExpression();

      if (anonymous && !hasParens) {
        // `(class` → `(class)`
        //                   ^
        this.insert(this.innerEnd, ')');
      }
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (this.isNamespaced()) {
        var classToken = this.getClassToken();
        // `class A.B` → `A.B`
        //  ^^^^^^
        this.remove(classToken.start, this.nameAssignee.outerStart);
        var name = this.getName();
        if (name) {
          // `A.B` → `A.B = class B`
          //             ^^^^^^^^^^
          this.insert(this.nameAssignee.outerEnd, ' = class ' + this.getName());
        } else {
          // `A[0]` → `A[0] = class`
          //               ^^^^^^^^
          this.insert(this.nameAssignee.outerEnd, ' = class');
        }
      }
      if (this.nameAssignee) {
        this.nameAssignee.patch();
      }
      if (this.superclass) {
        this.superclass.patch();
      }
      if (!this.body) {
        // `class A` → `class A {}`
        //                     ^^^
        this.insert(this.innerEnd, ' {}');
      } else {
        // `class A` → `class A {`
        //                     ^^
        this.insert(this.getBraceInsertionOffset(), ' {');
        this.body.patch({ leftBrace: false });
      }
    }
  }, {
    key: 'statementNeedsSemicolon',
    value: function statementNeedsSemicolon() {
      return this.isAnonymous() || this.isNamespaced();
    }

    /**
     * Classes, like functions, only need parens as statements when anonymous.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.isAnonymous();
    }

    /**
     * @private
     */

  }, {
    key: 'getClassToken',
    value: function getClassToken() {
      var tokens$$1 = this.context.sourceTokens;
      var classSourceToken = tokens$$1.tokenAtIndex(this.contentStartTokenIndex);
      if (classSourceToken.type !== coffeeLex.CLASS) {
        throw this.error('expected CLASS token but found ' + classSourceToken.type.name, classSourceToken.start, classSourceToken.end);
      }
      return classSourceToken;
    }

    /**
     * @private
     */

  }, {
    key: 'isAnonymous',
    value: function isAnonymous() {
      return this.nameAssignee === null;
    }

    /**
     * @private
     */

  }, {
    key: 'isNamespaced',
    value: function isNamespaced() {
      return !this.isAnonymous() && !(this.nameAssignee instanceof IdentifierPatcher);
    }

    /**
     * @private
     */

  }, {
    key: 'getName',
    value: function getName() {
      var nameAssignee = this.nameAssignee;

      if (nameAssignee instanceof IdentifierPatcher) {
        return nameAssignee.node.data;
      } else if (nameAssignee instanceof MemberAccessOpPatcher) {
        return nameAssignee.node.memberName;
      } else {
        return null;
      }
    }
  }, {
    key: 'isSubclass',
    value: function isSubclass() {
      return this.superclass !== null;
    }

    /**
     * @private
     */

  }, {
    key: 'getBraceInsertionOffset',
    value: function getBraceInsertionOffset() {
      if (this.superclass) {
        return this.superclass.outerEnd;
      }

      if (this.nameAssignee) {
        return this.nameAssignee.outerEnd;
      }

      return this.getClassToken().end;
    }
  }], [{
    key: 'patcherClassForChildNode',
    value: function patcherClassForChildNode(node, property) {
      if (property === 'body') {
        return ClassBlockPatcher;
      }
      return null;
    }
  }]);
  return ClassPatcher;
}(NodePatcher);

var CompoundAssignOpPatcher = function (_AssignOpPatcher) {
  inherits(CompoundAssignOpPatcher, _AssignOpPatcher);

  function CompoundAssignOpPatcher() {
    classCallCheck(this, CompoundAssignOpPatcher);
    return possibleConstructorReturn(this, (CompoundAssignOpPatcher.__proto__ || Object.getPrototypeOf(CompoundAssignOpPatcher)).apply(this, arguments));
  }

  createClass(CompoundAssignOpPatcher, [{
    key: 'getOperatorToken',
    value: function getOperatorToken() {
      var operatorIndex = this.indexOfSourceTokenBetweenPatchersMatching(this.assignee, this.expression, function (token) {
        return token.type === coffeeLex.OPERATOR;
      });
      if (!operatorIndex) {
        throw this.error('expected OPERATOR token between assignee and expression', this.assignee.outerEnd, this.expression.outerStart);
      }
      return this.sourceTokenAtIndex(operatorIndex);
    }

    /**
     * If `LHS` needs parens then `LHS += RHS` needs parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.assignee.statementShouldAddParens();
    }
  }]);
  return CompoundAssignOpPatcher;
}(AssignOpPatcher);

var ConditionalPatcher = function (_NodePatcher) {
  inherits(ConditionalPatcher, _NodePatcher);

  function ConditionalPatcher(node, context, editor, condition, consequent, alternate) {
    classCallCheck(this, ConditionalPatcher);

    var _this = possibleConstructorReturn(this, (ConditionalPatcher.__proto__ || Object.getPrototypeOf(ConditionalPatcher)).call(this, node, context, editor));

    _this.condition = condition;
    _this.consequent = consequent;
    _this.alternate = alternate;
    return _this;
  }

  createClass(ConditionalPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.condition.setRequiresExpression();
    }
  }, {
    key: 'prefersToPatchAsExpression',
    value: function prefersToPatchAsExpression() {
      var consequent = this.consequent;
      var alternate = this.alternate;

      if (!consequent || !alternate) {
        return false;
      }
      return consequent.prefersToPatchAsExpression() && alternate.prefersToPatchAsExpression();
    }
  }, {
    key: 'setExpression',
    value: function setExpression() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var willPatchAsExpression = get$1(ConditionalPatcher.prototype.__proto__ || Object.getPrototypeOf(ConditionalPatcher.prototype), 'setExpression', this).call(this, force);
      if (willPatchAsExpression && this.willPatchAsTernary()) {
        if (this.consequent) {
          this.consequent.setRequiresExpression();
        }
        if (this.alternate) {
          this.alternate.setRequiresExpression();
        }
      }
    }

    /**
     * @private
     */

  }, {
    key: 'willPatchAsTernary',
    value: function willPatchAsTernary() {
      return this.prefersToPatchAsExpression() || this.forcedToPatchAsExpression() && (!this.consequent || this.consequent.prefersToPatchAsExpression()) && (!this.alternate || this.alternate.prefersToPatchAsExpression());
    }

    /**
     * @private
     */

  }, {
    key: 'willPatchAsIIFE',
    value: function willPatchAsIIFE() {
      return !this.willPatchAsTernary() && this.forcedToPatchAsExpression();
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var needsParens = _ref.needsParens;

      var addParens = needsParens && !this.isSurroundedByParentheses();

      // `if a then b` → `a then b`
      //  ^^^
      this.overwrite(this.contentStart, this.condition.outerStart, addParens ? '(' : '');

      if (this.node.isUnless) {
        this.condition.negate();
      }

      this.condition.patch();

      var thenTokenIndex = this.getThenTokenIndex();
      if (thenTokenIndex) {
        var thenToken = this.sourceTokenAtIndex(thenTokenIndex);
        // `a then b` → `a ? b`
        //    ^^^^         ^
        this.overwrite(thenToken.start, thenToken.end, '?');
      } else {
        // `a b` → `a ? b`
        //           ^^
        this.insert(this.condition.outerEnd, ' ?');
      }

      var elseTokenIndex = this.getElseSourceTokenIndex();
      var elseToken = elseTokenIndex && this.sourceTokenAtIndex(elseTokenIndex);

      var consequent = this.consequent;
      var alternate = this.alternate;

      if (consequent && alternate) {
        consequent.patch();
        // `a ? b else c` → `a ? b : c`
        this.overwrite(elseToken.start, elseToken.end, ':');
        alternate.patch();
      } else if (consequent && !alternate) {
        consequent.patch();
        // `a ? b` → `a ? b : undefined`
        if (elseToken !== null) {
          this.overwrite(this.consequent.outerEnd, elseToken.end, ' : undefined');
        } else {
          this.insert(this.consequent.outerEnd, ' : undefined');
        }
      } else if (alternate) {
        this.overwrite(elseToken.start, elseToken.end, 'undefined :');
        alternate.patch();
      }

      if (addParens) {
        this.insert(this.contentEnd, ')');
      }
    }
  }, {
    key: 'patchAsForcedExpression',
    value: function patchAsForcedExpression() {
      if (this.willPatchAsTernary()) {
        // We didn't want to be an expression because we don't have an alternate,
        // which means that the alternate of a generated ternary would be
        // `undefined`, which is ugly (i.e. `if a then b` → `a ? b : undefined`).
        // TODO: Generate a `do` expression instead? (i.e. `do { if (a) { b; } }`)
        this.patchAsExpression();
      } else if (this.willPatchAsIIFE()) {
        this.patchAsIIFE();
      }
    }
  }, {
    key: 'patchAsIIFE',
    value: function patchAsIIFE() {
      // We're only patched as an expression due to a parent instructing us to,
      // and the indent level is more logically the indent level of our parent.
      var baseIndent = this.parent.getIndent(0);
      var conditionIndent = this.parent.getIndent(1);
      if (this.consequent) {
        this.consequent.setShouldPatchInline(false);
        this.consequent.setImplicitlyReturns();
      }
      if (this.alternate) {
        this.alternate.setShouldPatchInline(false);
        this.alternate.setImplicitlyReturns();
      }
      this.insert(this.innerStart, '(() => {\n' + conditionIndent);
      this.patchAsStatement();
      this.insert(this.innerEnd, '\n' + baseIndent + '})()');
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      this.patchConditionForStatement();
      this.patchConsequentForStatement();
      this.patchAlternateForStatement();
    }

    /**
     * @private
     */

  }, {
    key: 'patchConditionForStatement',
    value: function patchConditionForStatement() {
      // `unless a` → `if a`
      //  ^^^^^^        ^^
      var ifToken = this.sourceTokenAtIndex(this.getIfSourceTokenIndex());
      this.overwrite(ifToken.start, ifToken.end, 'if');

      var conditionHasParentheses = this.condition.isSurroundedByParentheses();
      if (!conditionHasParentheses) {
        // `if a` → `if (a`
        //              ^
        this.insert(this.condition.outerStart, '(');
      }
      if (this.node.isUnless) {
        this.condition.negate();
      }
      this.condition.patch({ needsParens: false });
      if (!conditionHasParentheses) {
        // `if (a` → `if (a)`
        //                  ^
        this.insert(this.condition.outerEnd, ')');
      }

      var thenTokenIndex = this.getThenTokenIndex();
      if (thenTokenIndex) {
        var thenToken = this.sourceTokenAtIndex(thenTokenIndex);
        // `if (a) then b` → `if (a) b`
        //         ^^^^^
        this.remove(thenToken.start, this.consequent.outerStart);
      }
    }

    /**
     * @private
     */

  }, {
    key: 'patchConsequentForStatement',
    value: function patchConsequentForStatement() {
      this.insert(this.condition.outerEnd, ' {');

      if (this.alternate) {
        var elseTokenIndex = this.getElseSourceTokenIndex();
        var elseToken = this.sourceTokenAtIndex(elseTokenIndex);
        var rightBracePosition = elseToken.start;
        if (this.consequent !== null) {
          this.consequent.patch({ leftBrace: false, rightBrace: false });
        }
        this.insert(rightBracePosition, '} ');
      } else {
        if (this.consequent !== null) {
          this.consequent.patch({ leftBrace: false });
        }
      }
    }

    /**
     * @private
     */

  }, {
    key: 'patchAlternateForStatement',
    value: function patchAlternateForStatement() {
      var elseTokenIndex = this.getElseSourceTokenIndex();
      if (this.alternate) {
        var ifToken = this.sourceTokenAtIndex(elseTokenIndex.next());
        var isElseIf = ifToken ? ifToken.type === coffeeLex.IF : false;
        if (isElseIf) {
          // Let the nested ConditionalPatcher handle braces.
          this.alternate.patch({ leftBrace: false, rightBrace: false });
        } else {
          var elseToken = this.sourceTokenAtIndex(elseTokenIndex);
          var leftBracePosition = elseToken.end;
          this.insert(leftBracePosition, ' {');
          this.alternate.patch({ leftBrace: false });
        }
      } else if (elseTokenIndex !== null) {
        var _elseToken = this.sourceTokenAtIndex(elseTokenIndex);
        this.insert(_elseToken.end, ' {}');
      }
    }
  }, {
    key: 'setImplicitlyReturns',
    value: function setImplicitlyReturns() {
      if (this.consequent) {
        this.consequent.setImplicitlyReturns();
      }
      if (this.alternate) {
        this.alternate.setImplicitlyReturns();
      }
    }

    /**
     * Conditionals do not need semicolons when used as statements.
     */

  }, {
    key: 'statementNeedsSemicolon',
    value: function statementNeedsSemicolon() {
      return false;
    }

    /**
     * Gets the index of the token representing the `if` at the start.
     *
     * @private
     */

  }, {
    key: 'getIfSourceTokenIndex',
    value: function getIfSourceTokenIndex() {
      var ifTokenIndex = this.indexOfSourceTokenStartingAtSourceIndex(this.contentStart);
      if (!ifTokenIndex) {
        throw this.error('expected IF token at start of conditional');
      }
      var ifToken = this.sourceTokenAtIndex(ifTokenIndex);
      if (ifToken.type !== coffeeLex.IF) {
        throw this.error('expected IF token at start of conditional, but got ' + ifToken.type.name);
      }
      return ifTokenIndex;
    }
    /**
     * Gets the index of the token representing the `else` between consequent and
     * alternate.
     *
     * @private
     */

  }, {
    key: 'getElseSourceTokenIndex',
    value: function getElseSourceTokenIndex() {
      var elseTokenIndex = this.indexOfSourceTokenBetweenSourceIndicesMatching(this.consequent !== null ? this.consequent.outerEnd : this.condition.outerEnd, this.alternate !== null ? this.alternate.outerStart : this.outerEnd, function (token) {
        return token.type === coffeeLex.ELSE;
      });
      if (this.alternate !== null && !elseTokenIndex) {
        throw this.error('expected ELSE token between consequent and alternate', this.consequent.outerEnd, this.alternate.outerStart);
      }
      return elseTokenIndex;
    }

    /**
     * Gets the index of the token representing the `then` between condition and
     * consequent.
     *
     * @private
     */

  }, {
    key: 'getThenTokenIndex',
    value: function getThenTokenIndex() {
      if (this.consequent === null) {
        return null;
      }
      return this.indexOfSourceTokenBetweenPatchersMatching(this.condition, this.consequent, function (token) {
        return token.type === coffeeLex.THEN;
      });
    }

    /**
     * Conditionals have all code paths if there is an `else` and both the
     * consequent and alternate have all their code paths.
     */

  }, {
    key: 'allCodePathsPresent',
    value: function allCodePathsPresent() {
      if (!this.consequent || !this.alternate) {
        return false;
      }

      return this.consequent.allCodePathsPresent() && this.alternate.allCodePathsPresent();
    }
  }]);
  return ConditionalPatcher;
}(NodePatcher);

var DefaultParamPatcher = function (_NodePatcher) {
  inherits(DefaultParamPatcher, _NodePatcher);

  function DefaultParamPatcher(node, context, editor, param, value) {
    classCallCheck(this, DefaultParamPatcher);

    var _this = possibleConstructorReturn(this, (DefaultParamPatcher.__proto__ || Object.getPrototypeOf(DefaultParamPatcher)).call(this, node, context, editor));

    _this.param = param;
    _this.value = value;
    return _this;
  }

  createClass(DefaultParamPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.param.setRequiresExpression();
      this.value.setRequiresExpression();
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.param.patch();
      this.value.patch();
    }
  }]);
  return DefaultParamPatcher;
}(NodePatcher);

var DoOpPatcher = function (_NodePatcher) {
  inherits(DoOpPatcher, _NodePatcher);

  function DoOpPatcher(node, context, editor, expression) {
    classCallCheck(this, DoOpPatcher);

    var _this = possibleConstructorReturn(this, (DoOpPatcher.__proto__ || Object.getPrototypeOf(DoOpPatcher)).call(this, node, context, editor));

    _this.expression = expression;
    return _this;
  }

  createClass(DoOpPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.expression.setRequiresExpression();
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _this2 = this;

      var doTokenIndex = this.getDoTokenIndex();
      var doToken = this.sourceTokenAtIndex(doTokenIndex);
      var nextToken = this.sourceTokenAtIndex(doTokenIndex.next());
      this.remove(doToken.start, nextToken.start);

      var addParens = this.expression instanceof FunctionPatcher && !this.isSurroundedByParentheses();

      if (addParens) {
        this.insert(this.outerStart, '(');
      }

      this.expression.patch();

      if (addParens) {
        this.insert(this.outerEnd, ')');
      }

      var args = [];
      if (this.expression instanceof FunctionPatcher) {
        var expression = this.expression;
        expression.parameters.forEach(function (param) {
          if (param instanceof DefaultParamPatcher) {
            var valueSource = param.value.getPatchedSource();
            _this2.remove(param.param.outerEnd, param.value.outerEnd);
            args.push(valueSource);
          } else {
            args.push(param.getPatchedSource());
          }
        });
      }
      this.insert(this.innerEnd, '(' + args.join(', ') + ')');
    }

    /**
     * @private
     */

  }, {
    key: 'getDoTokenIndex',
    value: function getDoTokenIndex() {
      var index = this.contentStartTokenIndex;
      var token = this.sourceTokenAtIndex(index);
      if (!token || token.type !== coffeeLex.DO) {
        throw this.error('expected \'do\' at start of expression');
      }
      return index;
    }
  }]);
  return DoOpPatcher;
}(NodePatcher);

var DynamicMemberAccessOpPatcher = function (_NodePatcher) {
  inherits(DynamicMemberAccessOpPatcher, _NodePatcher);

  function DynamicMemberAccessOpPatcher(node, context, editor, expression, indexingExpr) {
    classCallCheck(this, DynamicMemberAccessOpPatcher);

    var _this = possibleConstructorReturn(this, (DynamicMemberAccessOpPatcher.__proto__ || Object.getPrototypeOf(DynamicMemberAccessOpPatcher)).call(this, node, context, editor));

    _this.expression = expression;
    _this.indexingExpr = indexingExpr;
    return _this;
  }

  createClass(DynamicMemberAccessOpPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.expression.setRequiresExpression();
      this.indexingExpr.setRequiresExpression();
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.expression.patch();
      this.indexingExpr.patch();
    }

    /**
     * CoffeeScript considers dynamic member access repeatable if both parts
     * are themselves repeatable. So, for example, `a[0]` is repeatable because
     * both `a` and `0` are repeatable, but `a()[0]` and `a[b()]` are not.
     */

  }, {
    key: 'isRepeatable',
    value: function isRepeatable() {
      return this.expression.isRepeatable() && this.indexingExpr.isRepeatable();
    }

    /**
     * We can make dynamic member access repeatable by making both parts
     * repeatable if they aren't already. We do that by giving them names and
     * referring to those names in a new dynamic member access. We cannot simply
     * save the value of the member access because this could be used as the LHS
     * of an assignment.
     */

  }, {
    key: 'makeRepeatable',
    value: function makeRepeatable(parens) {
      var ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      // eslint-disable-line no-unused-vars
      var expression = this.expression.makeRepeatable(true, 'base');
      var indexingExpr = this.indexingExpr.makeRepeatable(false, 'name');
      return expression + '[' + indexingExpr + ']';
    }

    /**
     * If `BASE` needs parens, then `BASE[INDEX]` needs parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.expression.statementShouldAddParens();
    }
  }]);
  return DynamicMemberAccessOpPatcher;
}(NodePatcher);

/**
 * Handles equality and inequality comparisons.
 */

var EqualityPatcher = function (_BinaryOpPatcher) {
  inherits(EqualityPatcher, _BinaryOpPatcher);

  function EqualityPatcher() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, EqualityPatcher);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = EqualityPatcher.__proto__ || Object.getPrototypeOf(EqualityPatcher)).call.apply(_ref, [this].concat(args))), _this), _this.negated = false, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(EqualityPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.left.patch();
      var compareToken = this.getCompareToken();
      this.overwrite(compareToken.start, compareToken.end, this.getCompareOperator());
      this.right.patch();
    }
  }, {
    key: 'getCompareOperator',
    value: function getCompareOperator() {
      switch (this.node.type) {
        case 'EQOp':
          return this.negated ? '!==' : '===';

        case 'NEQOp':
          return this.negated ? '===' : '!==';

        case 'LTOp':
          return this.negated ? '>=' : '<';

        case 'GTOp':
          return this.negated ? '<=' : '>';

        case 'LTEOp':
          return this.negated ? '>' : '<=';

        case 'GTEOp':
          return this.negated ? '<' : '>=';

        default:
          throw this.error('unsupported equality/inequality type: ' + this.node.type);
      }
    }

    /**
     * @private
     */

  }, {
    key: 'getCompareToken',
    value: function getCompareToken() {
      var left = this.left;
      var right = this.right;

      var compareTokenIndex = this.indexOfSourceTokenBetweenPatchersMatching(left, right, function (token) {
        return token.type === coffeeLex.OPERATOR;
      });

      if (!compareTokenIndex) {
        throw this.error('expected OPERATOR token but none was found', left.outerEnd, right.outerStart);
      }

      return this.sourceTokenAtIndex(compareTokenIndex);
    }

    /**
     * Flips negated flag but doesn't edit anything immediately so that we can
     * use the correct operator in `patch`.
     */

  }, {
    key: 'negate',
    value: function negate() {
      this.negated = !this.negated;
    }
  }]);
  return EqualityPatcher;
}(BinaryOpPatcher);

/**
 * Handles exponentiation, i.e. `a ** b`.
 */

var ExpOpPatcher = function (_BinaryOpPatcher) {
  inherits(ExpOpPatcher, _BinaryOpPatcher);

  function ExpOpPatcher() {
    classCallCheck(this, ExpOpPatcher);
    return possibleConstructorReturn(this, (ExpOpPatcher.__proto__ || Object.getPrototypeOf(ExpOpPatcher)).apply(this, arguments));
  }

  createClass(ExpOpPatcher, [{
    key: 'patchAsExpression',

    /**
     * LEFT '**' RIGHT
     */
    value: function patchAsExpression() {
      // `a ** b` → `Math.pow(a ** b`
      //             ^^^^^^^^^
      this.insert(this.contentStart, 'Math.pow(');

      this.left.patch();

      // `Math.pow(a ** b` → `Math.pow(a, b`
      //            ^^^^                ^^
      this.overwrite(this.left.outerEnd, this.right.outerStart, ', ');

      this.right.patch();

      // `Math.pow(a, b` → `Math.pow(a, b)`
      //                                 ^
      this.insert(this.contentEnd, ')');
    }

    /**
     * We'll always start with `Math.pow` so we don't need parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return ExpOpPatcher;
}(BinaryOpPatcher);

var ExistsOpCompoundAssignOpPatcher = function (_CompoundAssignOpPatc) {
  inherits(ExistsOpCompoundAssignOpPatcher, _CompoundAssignOpPatc);

  function ExistsOpCompoundAssignOpPatcher() {
    classCallCheck(this, ExistsOpCompoundAssignOpPatcher);
    return possibleConstructorReturn(this, (ExistsOpCompoundAssignOpPatcher.__proto__ || Object.getPrototypeOf(ExistsOpCompoundAssignOpPatcher)).apply(this, arguments));
  }

  createClass(ExistsOpCompoundAssignOpPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var assigneeAgain = void 0;
      var needsTypeofCheck = this.assignee instanceof IdentifierPatcher && !this.node.scope.hasBinding(this.assignee.node.data);
      if (needsTypeofCheck) {
        // `a ?= b` → `typeof a ?= b`
        //             ^^^^^^^
        this.insert(this.assignee.outerStart, 'typeof ');
        this.assignee.patch();
        assigneeAgain = this.assignee.makeRepeatable();
        // `typeof a ? b` → `typeof a !== 'undefined' && a !== null ? a ?= b`
        //                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        this.insert(this.assignee.outerEnd, ' !== \'undefined\' && ' + assigneeAgain + ' !== null ? ' + assigneeAgain);
      } else {
        this.assignee.patch();
        assigneeAgain = this.assignee.makeRepeatable();
        // `a.b ?= b` → `a.b != null ? a.b ?= b`
        //                  ^^^^^^^^^^^^^^
        this.insert(this.assignee.outerEnd, ' != null ? ' + assigneeAgain);
      }

      var operator = this.getOperatorToken();
      // `a.b != null ? a.b ?= b` → `a.b != null ? a.b : (a.b = b`
      //                    ^^                         ^^^^^^^^
      this.overwrite(operator.start, operator.end, ': (' + assigneeAgain + ' =');
      this.expression.patch();
      // `a.b != null ? a.b : (a.b = b` → `a.b != null ? a.b : (a.b = b)`
      //                                                               ^
      this.insert(this.expression.outerEnd, ')');
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      if (this.lhsHasSoakOperation()) {
        this.patchAsExpression();
        return;
      }

      var assigneeAgain = void 0;
      if (this.assignee instanceof IdentifierPatcher) {
        // `a ?= b` → `if (typeof a ?= b`
        //             ^^^^^^^^^^^
        this.insert(this.assignee.outerStart, 'if (typeof ');
        this.assignee.patch();
        assigneeAgain = this.assignee.makeRepeatable();
        // `if (typeof a ?= b` → `if (typeof a === 'undefined' || a === null) { ?= b`
        //                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        this.insert(this.assignee.outerEnd, ' === \'undefined\' || ' + assigneeAgain + ' === null) {');
      } else {
        // `a.b ?= b` → `if (a.b ?= b`
        //               ^^^^
        this.insert(this.assignee.outerStart, 'if (');
        this.assignee.patch();
        assigneeAgain = this.assignee.makeRepeatable();
        // `if (a.b ?= b` → `if (a.b == null) { ?= b`
        //                          ^^^^^^^^^^^
        this.insert(this.assignee.outerEnd, ' == null) {');
      }

      var operator = this.getOperatorToken();
      // `if (a.b == null) { ?= b` → `if (a.b == null) { a.b = b`
      //                     ^^                          ^^^^^
      this.overwrite(operator.start, operator.end, assigneeAgain + ' =');
      this.expression.patch();
      // `if (a.b == null) { a.b = b` → `if (a.b == null) { a.b = b; }`
      //                                                           ^^^
      this.insert(this.expression.outerEnd, '; }');
    }

    /**
     * If the left-hand side of the assignment has a soak operation, then there
     * may be a __guard__ call surrounding the whole thing, so we can't patch
     * statement code, so instead run the expression code path.
     */

  }, {
    key: 'lhsHasSoakOperation',
    value: function lhsHasSoakOperation() {
      var foundSoak = false;
      traverse(this.assignee.node, function (node) {
        if (foundSoak) {
          return false;
        }
        if (node.type === 'SoakedDynamicMemberAccessOp' || node.type === 'SoakedFunctionApplication' || node.type === 'SoakedMemberAccessOp') {
          foundSoak = true;
        }
      });
      return foundSoak;
    }

    /**
     * We'll always start with an `if` so we don't need parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return ExistsOpCompoundAssignOpPatcher;
}(CompoundAssignOpPatcher);

var ExistsOpPatcher = function (_BinaryOpPatcher) {
  inherits(ExistsOpPatcher, _BinaryOpPatcher);

  function ExistsOpPatcher() {
    classCallCheck(this, ExistsOpPatcher);
    return possibleConstructorReturn(this, (ExistsOpPatcher.__proto__ || Object.getPrototypeOf(ExistsOpPatcher)).apply(this, arguments));
  }

  createClass(ExistsOpPatcher, [{
    key: 'patchAsExpression',

    /**
     * LEFT '?' RIGHT → `LEFT != null ? LEFT : RIGHT`
     */
    value: function patchAsExpression() {
      var needsTypeofCheck = this.left instanceof IdentifierPatcher && !this.node.scope.hasBinding(this.left.node.data);
      if (needsTypeofCheck) {
        // `a ? b` → `typeof a ? b`
        //            ^^^^^^^
        this.insert(this.contentStart, 'typeof ');
        var leftAgain = this.left.makeRepeatable(true, 'left');
        this.left.patch();
        // `typeof a ? b` → `typeof a !== 'undefined' && a !== null ? a : b`
        //          ^^^              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        this.overwrite(this.left.outerEnd, this.right.outerStart, ' !== \'undefined\' && ' + leftAgain + ' !== null ? ' + leftAgain + ' : ');
      } else {
        var _leftAgain = this.left.makeRepeatable(true, 'left');
        this.left.patch();
        // `a.b ? c` → `a.b != null ? a.b : c`
        //     ^^^         ^^^^^^^^^^^^^^^^^
        this.overwrite(this.left.outerEnd, this.right.outerStart, ' != null ? ' + _leftAgain + ' : ');
      }
      this.right.patch();
    }

    /**
     * LEFT '?' RIGHT → `if (LEFT == null) { RIGHT }`
     */

  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var needsTypeofCheck = this.left instanceof IdentifierPatcher && !this.node.scope.hasBinding(this.left.node.data);
      // `a ? b` → `if (a ? b`
      //            ^^^
      this.insert(this.contentStart, 'if (');
      if (needsTypeofCheck) {
        var leftAgain = this.left.makeRepeatable();
        // `if (a ? b` → `if (typeof a ? b`
        //                    ^^^^^^^
        this.insert(this.contentStart, 'typeof ');
        // `if (typeof a ? b` → `if (typeof a === 'undefined' || a === null) { b`
        //              ^^^                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        this.overwrite(this.left.outerEnd, this.right.outerStart, ' === \'undefined\' || ' + leftAgain + ' === null) { ');
      } else {
        // `if (a.b ? b.c` → `if (a.b == null) { b.c`
        //         ^^^               ^^^^^^^^^^^^
        this.overwrite(this.left.outerEnd, this.right.outerStart, ' == null) { ');
      }
      // `if (a.b == null) { b.c` → `if (a.b == null) { b.c }`
      //                                                   ^^
      this.insert(this.innerEnd, ' }');
    }

    /**
     * We'll always start with an `if` so we don't need parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return ExistsOpPatcher;
}(BinaryOpPatcher);

var EXTENDS_HELPER = '\nfunction __extends__(child, parent) {\n  Object.getOwnPropertyNames(parent).forEach(\n    name => child[name] = parent[name]\n  );\n  child.prototype = Object.create(parent.prototype);\n  child.__super__ = parent.prototype;\n  return child;\n}\n';

/**
 * Handles `extends` infix operator.
 */

var ExtendsOpPatcher = function (_BinaryOpPatcher) {
  inherits(ExtendsOpPatcher, _BinaryOpPatcher);

  function ExtendsOpPatcher() {
    classCallCheck(this, ExtendsOpPatcher);
    return possibleConstructorReturn(this, (ExtendsOpPatcher.__proto__ || Object.getPrototypeOf(ExtendsOpPatcher)).apply(this, arguments));
  }

  createClass(ExtendsOpPatcher, [{
    key: 'patchAsExpression',

    /**
     * CHILD extends PARENT
     */
    value: function patchAsExpression() {
      var helper = this.registerHelper('__extends__', EXTENDS_HELPER);
      this.insert(this.left.outerStart, helper + '(');
      this.left.patch();
      this.overwrite(this.left.outerEnd, this.right.outerStart, ', ');
      this.right.patch();
      this.insert(this.right.outerEnd, ')');
    }

    /**
     * We always prefix with `__extends__`, so no need for parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return ExtendsOpPatcher;
}(BinaryOpPatcher);

var FloorDivideOpPatcher = function (_BinaryOpPatcher) {
  inherits(FloorDivideOpPatcher, _BinaryOpPatcher);

  function FloorDivideOpPatcher() {
    classCallCheck(this, FloorDivideOpPatcher);
    return possibleConstructorReturn(this, (FloorDivideOpPatcher.__proto__ || Object.getPrototypeOf(FloorDivideOpPatcher)).apply(this, arguments));
  }

  createClass(FloorDivideOpPatcher, [{
    key: 'patchAsExpression',

    /**
     * LEFT '//' RIGHT
     */
    value: function patchAsExpression() {
      var operator = this.getOperatorToken();

      // `a // b` → `Math.floor(a // b`
      //             ^^^^^^^^^^^
      this.insert(this.contentStart, 'Math.floor(');

      this.left.patch({ needsParens: true });

      // `Math.floor(a // b)` → `Math.floor(a / b)`
      //               ^^                     ^
      this.overwrite(operator.start, operator.end, '/');

      this.right.patch({ needsParens: true });

      // `Math.floor(a // b` → `Math.floor(a // b)`
      //                                         ^
      this.insert(this.contentEnd, ')');
    }

    /**
     * We always prefix with `Math.floor`, so no need for parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return FloorDivideOpPatcher;
}(BinaryOpPatcher);

var LoopPatcher = function (_NodePatcher) {
  inherits(LoopPatcher, _NodePatcher);

  function LoopPatcher(node, context, editor, body) {
    classCallCheck(this, LoopPatcher);

    var _this = possibleConstructorReturn(this, (LoopPatcher.__proto__ || Object.getPrototypeOf(LoopPatcher)).call(this, node, context, editor));

    _this.body = body;
    return _this;
  }

  createClass(LoopPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      // We're only patched as an expression due to a parent instructing us to,
      // and the indent level is more logically the indent level of our parent.
      var baseIndent = this.parent.getIndent(0);
      var iifeBodyIndent = this.getLoopIndent();
      this.body.setShouldPatchInline(false);
      this.body.setImplicitlyReturns();
      this.body.setIndent(this.getLoopBodyIndent());
      var resultBinding = this.getResultArrayBinding();
      var prefix = !this.yielding ? '(() =>' : 'yield* (function*()';
      this.insert(this.innerStart, prefix + ' {\n' + iifeBodyIndent + resultBinding + ' = [];\n' + iifeBodyIndent);
      this.patchAsStatement();
      var suffix = !this.yielding ? '()' : this.referencesArguments() ? '.apply(this, arguments)' : '.call(this)';
      this.insert(this.innerEnd, '\n' + iifeBodyIndent + 'return ' + resultBinding + ';\n' + baseIndent + '})' + suffix);
    }

    /**
     * The first of three meaningful indentation levels for where we might want to
     * insert code.
     *
     * As an example, in this code:
     * a((() => {
     *   for (let i = 0; i < b.length; i++) {
     *     let val = b[i];
     *     if (val) {
     *       c;
     *     }
     *   )
     * })())
     *
     * - `getLoopIndent` returns the indentation of the `for`.
     * - `getOuterLoopBodyIndent` returns the indentation of the `if`.
     * - `getLoopBodyIndent` returns the indentation of `c`.
     *
     * However, these levels may change based on whether the loop has a condition,
     * and whether the loop is being formatted as an IIFE or as a regular loop
     * statement.
     *
     * We need to be especially careful about when to actually set the indentation
     * of existing code, since doing that too much can confuse magic-string. The
     * only code that actually is adjusted is the loop body (but only when it's
     * not an inline body), and this is done relatively early on in all cases.
     */

  }, {
    key: 'getLoopIndent',
    value: function getLoopIndent() {
      if (this.willPatchAsExpression()) {
        return this.parent.getIndent(1);
      } else {
        return this.getIndent();
      }
    }

    /**
     * @see getLoopIndent.
     */

  }, {
    key: 'getOuterLoopBodyIndent',
    value: function getOuterLoopBodyIndent() {
      return this.getLoopIndent() + this.getProgramIndentString();
    }

    /**
     * @see getLoopIndent.
     */

  }, {
    key: 'getLoopBodyIndent',
    value: function getLoopBodyIndent() {
      throw this.error('\'getLoopBodyIndent\' must be overridden in subclasses');
    }
  }, {
    key: 'yieldController',
    value: function yieldController() {
      this.yielding = true;
      this.yields();
    }

    /**
     * IIFE-style loop expressions should always be multi-line, even if the loop
     * body in CoffeeScript is inline. This means we need to use a different
     * patching strategy where we insert a newline in the proper place before
     * generating code around the body, then we need to directly create the
     * indentation just before patching the body.
     */

  }, {
    key: 'patchPossibleNewlineAfterLoopHeader',
    value: function patchPossibleNewlineAfterLoopHeader(loopHeaderEndIndex) {
      if (this.shouldConvertInlineBodyToNonInline()) {
        this.overwrite(loopHeaderEndIndex, this.body.contentStart, '\n');
      }
    }
  }, {
    key: 'patchBodyWithPossibleItemVariable',
    value: function patchBodyWithPossibleItemVariable() {
      if (this.shouldConvertInlineBodyToNonInline()) {
        this.body.insert(this.body.outerStart, this.getLoopBodyIndent());
      }

      if (this.willPatchAsExpression() && !this.allBodyCodePathsPresent()) {
        var itemBinding = this.getResultArrayElementBinding();
        this.body.insertStatementsAtIndex(['var ' + itemBinding], 0);
        this.body.patch({ leftBrace: false, rightBrace: false });
        this.body.insertStatementsAtIndex([this.getResultArrayBinding() + '.push(' + itemBinding + ')'], this.body.statements.length);
      } else {
        this.body.patch({ leftBrace: false, rightBrace: false });
      }
    }
  }, {
    key: 'shouldConvertInlineBodyToNonInline',
    value: function shouldConvertInlineBodyToNonInline() {
      return this.willPatchAsExpression() && this.body.node.inline;
    }

    /**
     * Most implicit returns cause program flow to break by using a `return`
     * statement, but we don't do that since we're just collecting values in
     * an array. This allows descendants who care about this to adjust their
     * behavior accordingly.
     */

  }, {
    key: 'implicitReturnWillBreak',
    value: function implicitReturnWillBreak() {
      if (this.willPatchAsExpression()) {
        return false;
      } else {
        return get$1(LoopPatcher.prototype.__proto__ || Object.getPrototypeOf(LoopPatcher.prototype), 'implicitReturnWillBreak', this).call(this);
      }
    }

    /**
     * We decide how statements in implicit return positions are patched, if
     * we're being used as an expression. This is because we don't want to return
     * them, but add them to an array.
     */

  }, {
    key: 'implicitReturnPatcher',
    value: function implicitReturnPatcher() {
      if (this.willPatchAsExpression()) {
        return this;
      } else {
        return get$1(LoopPatcher.prototype.__proto__ || Object.getPrototypeOf(LoopPatcher.prototype), 'implicitReturnPatcher', this).call(this);
      }
    }

    /**
     * If this loop is used as an expression, then we need to collect all the
     * values of the statements in implicit-return position. If all the code paths
     * in our body are present, we can just add `result.push(…)` to all
     * implicit-return position statements. If not, we want those code paths to
     * result in adding `undefined` to the resulting array. The way we do that is
     * by creating an `item` local variable that we set in each code path, and
     * when the code exits through a missing code path (i.e. `if false then b`)
     * then `item` will naturally have the value `undefined` which we then push
     * at the end of the loop body.
     */

  }, {
    key: 'patchImplicitReturnStart',
    value: function patchImplicitReturnStart(patcher) {
      // Control flow statements like break and continue should be skipped.
      if (!patcher.canPatchAsExpression()) {
        return;
      }
      patcher.setRequiresExpression();
      if (this.allBodyCodePathsPresent()) {
        // `a + b` → `result.push(a + b`
        //            ^^^^^^^^^^^^
        this.insert(patcher.outerStart, this.getResultArrayBinding() + '.push(');
      } else {
        // `a + b` → `item = a + b`
        //            ^^^^^^^
        this.insert(patcher.outerStart, this.getResultArrayElementBinding() + ' = ');
      }
    }

    /**
     * @see patchImplicitReturnStart
     */

  }, {
    key: 'patchImplicitReturnEnd',
    value: function patchImplicitReturnEnd(patcher) {
      if (!patcher.canPatchAsExpression()) {
        return;
      }
      if (this.allBodyCodePathsPresent()) {
        this.insert(patcher.outerEnd, ')');
      }
    }
  }, {
    key: 'allBodyCodePathsPresent',
    value: function allBodyCodePathsPresent() {
      if (this._allBodyCodePathsPresent === undefined) {
        this._allBodyCodePathsPresent = this.body.allCodePathsPresent();
      }
      return this._allBodyCodePathsPresent;
    }

    /**
     * @private
     */

  }, {
    key: 'getResultArrayBinding',
    value: function getResultArrayBinding() {
      if (!this._resultArrayBinding) {
        this._resultArrayBinding = this.claimFreeBinding('result');
      }
      return this._resultArrayBinding;
    }

    /**
     * @private
     */

  }, {
    key: 'getResultArrayElementBinding',
    value: function getResultArrayElementBinding() {
      if (!this._resultArrayElementBinding) {
        this._resultArrayElementBinding = this.claimFreeBinding('item');
      }
      return this._resultArrayElementBinding;
    }
  }, {
    key: 'statementNeedsSemicolon',
    value: function statementNeedsSemicolon() {
      return false;
    }

    /**
     * @private
     */

  }, {
    key: 'referencesArguments',
    value: function referencesArguments() {
      var result = false;

      traverse(this.node, function (node) {
        if (result || isFunction(node)) {
          return false;
        }

        if (node.type === 'Identifier' && node.data === 'arguments') {
          result = true;
        }
      });

      return result;
    }
  }]);
  return LoopPatcher;
}(NodePatcher);

var ForPatcher = function (_LoopPatcher) {
  inherits(ForPatcher, _LoopPatcher);

  function ForPatcher(node, context, editor, keyAssignee, valAssignee, target, filter, body) {
    classCallCheck(this, ForPatcher);

    var _this = possibleConstructorReturn(this, (ForPatcher.__proto__ || Object.getPrototypeOf(ForPatcher)).call(this, node, context, editor, body));

    _this.keyAssignee = keyAssignee;
    _this.valAssignee = valAssignee;
    _this.target = target;
    _this.filter = filter;
    return _this;
  }

  createClass(ForPatcher, [{
    key: 'initialize',
    value: function initialize() {
      if (this.keyAssignee) {
        this.keyAssignee.setRequiresExpression();
      }
      if (this.valAssignee) {
        this.valAssignee.setRequiresExpression();
      }
      this.target.setRequiresExpression();
      if (this.filter) {
        this.filter.setRequiresExpression();
      }
    }
  }, {
    key: 'getFilterCode',
    value: function getFilterCode() {
      var filter = this.filter;
      if (!filter) {
        return null;
      }
      if (!this._filterCode) {
        this._filterCode = filter.patchAndGetCode({ needsParens: false });
      }
      return this._filterCode;
    }
  }, {
    key: 'getLoopBodyIndent',
    value: function getLoopBodyIndent() {
      if (this.filter) {
        return this.getOuterLoopBodyIndent() + this.getProgramIndentString();
      } else {
        return this.getOuterLoopBodyIndent();
      }
    }
  }, {
    key: 'patchBodyAndFilter',
    value: function patchBodyAndFilter() {
      var body = this.body;
      var filter = this.filter;


      if (filter) {
        this.body.insertLineBefore('if (' + this.getFilterCode() + ') {', this.getOuterLoopBodyIndent());
        this.patchBodyWithPossibleItemVariable();
        body.insertLineAfter('}', this.getOuterLoopBodyIndent());
        body.insertLineAfter('}', this.getLoopIndent());
      } else {
        this.patchBodyWithPossibleItemVariable();
        body.insertLineAfter('}', this.getLoopIndent());
      }
    }
  }, {
    key: 'getRelationToken',
    value: function getRelationToken() {
      var tokenIndex = this.indexOfSourceTokenBetweenPatchersMatching(this.keyAssignee || this.valAssignee, this.target, function (token) {
        return token.type === coffeeLex.RELATION;
      });
      if (!tokenIndex) {
        throw this.error('cannot find relation keyword in \'for\' loop');
      }
      return this.sourceTokenAtIndex(tokenIndex);
    }

    /**
     * @protected
     */

  }, {
    key: 'getIndexBinding',
    value: function getIndexBinding() {
      if (!this._indexBinding) {
        this._indexBinding = this.computeIndexBinding();
      }
      return this._indexBinding;
    }

    /**
     * @protected
     */

  }, {
    key: 'computeIndexBinding',
    value: function computeIndexBinding() {
      var keyAssignee = this.keyAssignee;
      if (keyAssignee) {
        if (!(keyAssignee instanceof IdentifierPatcher)) {
          // CoffeeScript requires that the index be an identifier, not a pattern
          // matching expression, so this should never happen.
          throw keyAssignee.error('expected loop index to be an identifier');
        }
        return this.slice(keyAssignee.contentStart, keyAssignee.contentEnd);
      } else {
        return this.claimFreeBinding(this.indexBindingCandidates());
      }
    }

    /**
     * @protected
     */

  }, {
    key: 'indexBindingCandidates',
    value: function indexBindingCandidates() {
      return ['i', 'j', 'k'];
    }

    /**
     * @protected
     */

  }, {
    key: 'removeThenToken',
    value: function removeThenToken() {
      var index = this.indexOfSourceTokenBetweenPatchersMatching(this.target, this.body, function (token) {
        return token.type === coffeeLex.THEN;
      });
      if (index) {
        var thenToken = this.sourceTokenAtIndex(index);
        var nextToken = this.sourceTokenAtIndex(index.next());
        this.remove(thenToken.start, nextToken.start);
      }
    }
  }, {
    key: 'getTargetCode',
    value: function getTargetCode() {
      // Trigger patching the reference.
      this.getTargetReference();
      return this.slice(this.target.contentStart, this.target.contentEnd);
    }
  }, {
    key: 'getTargetReference',
    value: function getTargetReference() {
      if (!this._targetReference) {
        if (this.requiresExtractingTarget()) {
          this.target.patch();
          this._targetReference = this.claimFreeBinding(this.targetBindingCandidate());
        } else {
          this._targetReference = this.target.patchAndGetCode();
        }
      }
      return this._targetReference;
    }
  }]);
  return ForPatcher;
}(LoopPatcher);

var RANGE_HELPER = 'function __range__(left, right, inclusive) {\n  let range = [];\n  let ascending = left < right;\n  let end = !inclusive ? right : ascending ? right + 1 : right - 1;\n  for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n    range.push(i);\n  }\n  return range;\n}';

var MAXIMUM_LITERAL_RANGE_ELEMENTS = 21;

var RangePatcher = function (_BinaryOpPatcher) {
  inherits(RangePatcher, _BinaryOpPatcher);

  function RangePatcher() {
    classCallCheck(this, RangePatcher);
    return possibleConstructorReturn(this, (RangePatcher.__proto__ || Object.getPrototypeOf(RangePatcher)).apply(this, arguments));
  }

  createClass(RangePatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (this.canBecomeLiteralArray()) {
        this.patchAsLiteralArray();
      } else {
        this.patchAsIIFE();
      }
    }

    /**
     * @private
     */

  }, {
    key: 'patchAsLiteralArray',
    value: function patchAsLiteralArray() {
      var start = this.left.node.data;
      var end = this.right.node.data;
      var inclusive = this.isInclusive();
      var ascending = start < end;

      if (inclusive) {
        end += ascending ? 1 : -1;
      }

      var list = '';

      for (var i = start; ascending ? i < end : i > end; ascending ? i++ : i--) {
        var isLast = ascending ? i === end - 1 : i === end + 1;
        if (isLast) {
          list += '' + i;
        } else {
          list += i + ', ';
        }
      }

      // `[0..2]` → `[0, 1, 2]`
      //  ^^^^^^     ^^^^^^^^^
      this.overwrite(this.contentStart, this.contentEnd, '[' + list + ']');
    }

    /**
     * @private
     */

  }, {
    key: 'patchAsIIFE',
    value: function patchAsIIFE() {
      var helper = this.registerHelper('__range__', RANGE_HELPER);

      // `[a..b]` → `__range__(a..b]`
      //  ^          ^^^^^^^^^^
      this.overwrite(this.contentStart, this.left.outerStart, helper + '(');

      this.left.patch();

      // `__range__(a..b]` → `__range__(a, b]`
      //             ^^                  ^^
      this.overwrite(this.left.outerEnd, this.right.outerStart, ', ');

      this.right.patch();

      // `__range__(a, b]` → `__range__(a, b, true)`
      //                ^                   ^^^^^^
      this.overwrite(this.right.outerEnd, this.contentEnd, ', ' + this.isInclusive() + ')');
    }

    /**
     * @private
     */

  }, {
    key: 'canBecomeLiteralArray',
    value: function canBecomeLiteralArray() {
      var range = this.getLiteralRange();

      if (!range) {
        return false;
      }

      var _range = slicedToArray(range, 2);

      var first = _range[0];
      var last = _range[1];

      return Math.abs(last - first) <= MAXIMUM_LITERAL_RANGE_ELEMENTS;
    }

    /**
     * @private
     */

  }, {
    key: 'getLiteralRange',
    value: function getLiteralRange() {
      var left = this.left.node;
      var right = this.right.node;

      if (left.type !== 'Int' || right.type !== 'Int') {
        return false;
      }

      var first = left.data;
      var last = right.data;
      if (first < last) {
        return [first, last + (this.isInclusive() ? 1 : 0)];
      } else {
        return [first, last - (this.isInclusive() ? 1 : 0)];
      }
    }

    /**
     * @private
     */

  }, {
    key: 'isInclusive',
    value: function isInclusive() {
      return this.node.isInclusive;
    }
  }]);
  return RangePatcher;
}(BinaryOpPatcher);

var UP = 'UP';
var DOWN = 'DOWN';
var UNKNOWN = 'UNKNOWN';

var ForInPatcher = function (_ForPatcher) {
  inherits(ForInPatcher, _ForPatcher);

  function ForInPatcher(node, context, editor, keyAssignee, valAssignee, target, step, filter, body) {
    classCallCheck(this, ForInPatcher);

    var _this = possibleConstructorReturn(this, (ForInPatcher.__proto__ || Object.getPrototypeOf(ForInPatcher)).call(this, node, context, editor, keyAssignee, valAssignee, target, filter, body));

    _this.step = step;
    return _this;
  }

  createClass(ForInPatcher, [{
    key: 'initialize',
    value: function initialize() {
      get$1(ForInPatcher.prototype.__proto__ || Object.getPrototypeOf(ForInPatcher.prototype), 'initialize', this).call(this);
      if (this.step) {
        this.step.setRequiresExpression();
      }
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      // When possible, we want to transform the loop into a use of `map`, but
      // there are some cases when we can't. Use the more general approach of a
      // statement loop within an IIFE if that's the case.
      if (!this.canPatchAsMapExpression()) {
        return get$1(ForInPatcher.prototype.__proto__ || Object.getPrototypeOf(ForInPatcher.prototype), 'patchAsExpression', this).call(this);
      }
      this.removeThenToken();

      var assigneeCode = this.getValueBinding();
      if (this.keyAssignee) {
        assigneeCode += ', ' + this.getIndexBinding();
      }

      // for a in b when c d  ->  b when c d
      // ("then" was removed above).
      this.remove(this.contentStart, this.target.outerStart);
      this.target.patch();
      if (this.filter !== null) {
        // b when c d  ->  b.filter((a) => c d
        this.overwrite(this.target.outerEnd, this.filter.outerStart, '.filter((' + assigneeCode + ') => ');
        this.filter.patch();
        // b.filter((a) => c d  ->  b.filter((a) => c).map((a) => d
        this.insert(this.filter.outerEnd, ').map((' + assigneeCode + ') =>');
      } else {
        // b d  ->  b.map((a) => d
        this.insert(this.target.outerEnd, '.map((' + assigneeCode + ') =>');
      }
      this.patchBodyForExpressionLoop();
      // b.filter((a) => c).map((a) => d  ->  b.filter((a) => c).map((a) => d)
      this.insert(this.body.outerEnd, ')');
    }
  }, {
    key: 'patchBodyForExpressionLoop',
    value: function patchBodyForExpressionLoop() {
      this.body.setRequiresExpression();
      var bodyNeedsParens = isObjectInitialiserBlock(this.body) && !this.body.isSurroundedByParentheses();
      if (bodyNeedsParens) {
        var insertPoint = this.filter ? this.filter.outerEnd : this.target.outerEnd;
        // Handle both inline and multiline cases by either skipping the existing
        // space or adding one.
        if (this.slice(insertPoint, insertPoint + 1) === ' ') {
          this.body.insert(insertPoint + 1, '(');
        } else {
          this.body.insert(insertPoint, ' (');
        }
      }
      this.body.patch();
      if (bodyNeedsParens) {
        this.body.insert(this.body.outerEnd, ')');
      }
    }
  }, {
    key: 'canPatchAsMapExpression',
    value: function canPatchAsMapExpression() {
      if (this.step !== null) {
        return false;
      }
      if (!this.body.canPatchAsExpression()) {
        return false;
      }
      // The high-level approach of a.filter(...).map((x, i) => ...) doesn't work,
      // since the filter will change the indexes, so we specifically exclude that
      // case.
      if (this.filter !== null && this.keyAssignee !== null) {
        return false;
      }
      return true;
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      if (!this.body.inline()) {
        this.body.setIndent(this.getLoopBodyIndent());
      }

      if (this.shouldPatchAsForOf()) {
        this.getFilterCode();
        this.patchForOfLoop();
      } else {
        // Run for the side-effect of patching and slicing the value.
        this.getValueBinding();
        this.getFilterCode();

        this.patchForLoopHeader();
        this.patchForLoopBody();
      }
    }

    /**
     * As long as we aren't using the loop index or a step, we prefer to use JS
     * for-of loops.
     */

  }, {
    key: 'shouldPatchAsForOf',
    value: function shouldPatchAsForOf() {
      return !this.shouldPatchAsInitTestUpdateLoop() && this.step === null && this.keyAssignee === null;
    }
  }, {
    key: 'getValueBinding',
    value: function getValueBinding() {
      if (!this._valueBinding) {
        if (this.valAssignee) {
          this._valueBinding = this.valAssignee.patchAndGetCode();
        } else if (this.shouldPatchAsInitTestUpdateLoop()) {
          this._valueBinding = this.claimFreeBinding(this.indexBindingCandidates());
        } else {
          this._valueBinding = this.claimFreeBinding('value');
        }
      }
      return this._valueBinding;
    }

    /**
     * @protected
     */

  }, {
    key: 'computeIndexBinding',
    value: function computeIndexBinding() {
      if (this.shouldPatchAsInitTestUpdateLoop()) {
        return this.getValueBinding();
      } else {
        return get$1(ForInPatcher.prototype.__proto__ || Object.getPrototypeOf(ForInPatcher.prototype), 'computeIndexBinding', this).call(this);
      }
    }
  }, {
    key: 'patchForLoopHeader',
    value: function patchForLoopHeader() {
      if (this.requiresExtractingTarget()) {
        this.insert(this.innerStart, this.getTargetReference() + ' = ' + this.getTargetCode() + '\n' + this.getLoopIndent());
      }
      var firstHeaderPatcher = this.valAssignee || this.target;
      var lastHeaderPatcher = this.getLastHeaderPatcher();
      this.overwrite(firstHeaderPatcher.outerStart, lastHeaderPatcher.outerEnd, '(' + this.getInitCode() + '; ' + this.getTestCode() + '; ' + this.getUpdateCode() + ') {');
    }
  }, {
    key: 'getLastHeaderPatcher',
    value: function getLastHeaderPatcher() {
      return [this.step, this.filter, this.target].filter(function (patcher) {
        return patcher;
      }).reduce(function (last, patcher) {
        return patcher.contentEnd > last.contentEnd ? patcher : last;
      });
    }
  }, {
    key: 'patchForLoopBody',
    value: function patchForLoopBody() {
      this.removeThenToken();
      this.patchPossibleNewlineAfterLoopHeader(this.getLastHeaderPatcher().outerEnd);

      if (!this.shouldPatchAsInitTestUpdateLoop() && this.valAssignee) {
        var valueAssignment = this.getValueBinding() + ' = ' + this.getTargetReference() + '[' + this.getIndexBinding() + ']';
        if (this.valAssignee.statementNeedsParens()) {
          valueAssignment = '(' + valueAssignment + ')';
        }
        this.body.insertLineBefore(valueAssignment, this.getOuterLoopBodyIndent());
      }
      this.patchBodyAndFilter();
    }

    /**
     * Special case for patching for-of case for when the loop is simple enough
     * that for-of works. Note that for-of has slightly different semantics
     * because it uses the iterator protocol rather than CoffeeScript's notion of
     * an array-like object, so this transform sacrifices 100% correctness in
     * favor of cleaner code.
     */

  }, {
    key: 'patchForOfLoop',
    value: function patchForOfLoop() {
      // Save the filter code and remove if it it's there.
      this.getFilterCode();
      if (this.filter) {
        this.remove(this.target.outerEnd, this.filter.outerEnd);
      }

      if (this.valAssignee) {
        var relationToken = this.getRelationToken();
        this.valAssignee.patch();
        this.insert(this.valAssignee.outerStart, '(');
        this.overwrite(relationToken.start, relationToken.end, 'of');
      } else {
        // Handle loops like `for [0..2]`
        var valueBinding = this.getValueBinding();
        this.insert(this.target.outerStart, '(let ' + valueBinding + ' of ');
      }

      this.target.patch();
      this.insert(this.target.outerEnd, ') {');
      this.removeThenToken();
      this.patchBodyAndFilter();
    }
  }, {
    key: 'requiresExtractingTarget',
    value: function requiresExtractingTarget() {
      return !this.shouldPatchAsInitTestUpdateLoop() && !this.target.isRepeatable() && !this.shouldPatchAsForOf();
    }
  }, {
    key: 'targetBindingCandidate',
    value: function targetBindingCandidate() {
      return 'iterable';
    }
  }, {
    key: 'getInitCode',
    value: function getInitCode() {
      var step = this.getStep();
      if (this.shouldPatchAsInitTestUpdateLoop()) {
        return this.getIndexBinding() + ' = ' + this.target.left.patchAndGetCode();
      } else if (step.negated) {
        return this.getIndexBinding() + ' = ' + this.getTargetReference() + '.length - 1';
      } else {
        var result = this.getIndexBinding() + ' = 0';
        if (!step.isLiteral) {
          result += ', ' + step.update + ' = ' + step.init;
        }
        return result;
      }
    }
  }, {
    key: 'getTestCode',
    value: function getTestCode() {
      var step = this.getStep();
      if (this.shouldPatchAsInitTestUpdateLoop()) {
        var direction = this.getIndexDirection();
        var inclusive = this.target.isInclusive();
        var operator = void 0;

        if (direction === DOWN) {
          operator = inclusive ? '>=' : '>';
        } else {
          operator = inclusive ? '<=' : '<';
        }

        return this.getIndexBinding() + ' ' + operator + ' ' + this.target.right.patchAndGetCode();
      } else if (step.negated) {
        return this.getIndexBinding() + ' >= 0';
      } else {
        return this.getIndexBinding() + ' < ' + this.getTargetReference() + '.length';
      }
    }
  }, {
    key: 'getUpdateCode',
    value: function getUpdateCode() {
      var indexBinding = this.getIndexBinding();
      var step = this.getStep();
      var direction = this.getIndexDirection();
      if (step.number === 1) {
        return '' + indexBinding + (direction === DOWN ? '--' : '++');
      } else if (direction === DOWN) {
        return indexBinding + ' -= ' + step.update;
      } else {
        return indexBinding + ' += ' + step.update;
      }
    }
  }, {
    key: 'getStep',
    value: function getStep() {
      if (this._step === undefined) {
        this._step = new Step(this.step);
      }
      return this._step;
    }

    /**
     * Can we patch using `for (;;)` style?
     *
     * Currently, that requires either a fixed range:
     *
     *   a() for [0..1]
     *
     * Or a dynamic range with a fixed step:
     *
     *   a() for [n..m] by 1
     *
     * Eventually, we could also support any dynamic range:
     *
     *   a() for [from..to]
     *   a() for [lower()..upper()]
     *
     * By capturing the bounds as needed and comparing:
     *
     *   for (let asc = from <= to, i = from; asc ? i <= to : i >= to; asc ? i++ : i--) {
     *     a();
     *   }
     *   for (let start = lower(), end = upper(), asc = start <= end, i = start; asc ? i <= end : i >= end; asc ? i++ : i--) {
     *     a();
     *   }
     */

  }, {
    key: 'shouldPatchAsInitTestUpdateLoop',
    value: function shouldPatchAsInitTestUpdateLoop() {
      return this.hasFixedRange() || this.hasDynamicRange() && this.hasExplicitStep();
    }

    /**
     * Determines whether this `for…in` loop has an explicit `by` step.
     */

  }, {
    key: 'hasExplicitStep',
    value: function hasExplicitStep() {
      return !this.getStep().isVirtual;
    }

    /**
     * Determines the direction of index iteration, either UP, DOWN, or UNKNOWN.
     * UNKNOWN means that we cannot statically determine the direction.
     */

  }, {
    key: 'getIndexDirection',
    value: function getIndexDirection() {
      var step = this.getStep();
      if (step.isVirtual && this.hasFixedRange()) {
        var left = this.target.left.node.data;
        var right = this.target.right.node.data;
        return left > right ? DOWN : UP;
      } else if (this.hasDynamicRange()) {
        return UNKNOWN;
      } else {
        return step.negated ? DOWN : UP;
      }
    }

    /**
     * Are we looping over a range with dynamic start/end?
     *
     * @example
     *
     *   for [a..b]
     *   for [0..b]
     */

  }, {
    key: 'hasDynamicRange',
    value: function hasDynamicRange() {
      return this.target instanceof RangePatcher && !this.hasFixedRange();
    }

    /**
     * Are we looping over a range with fixed (static) start/end?
     *
     * @example
     *
     *   for [0..3]
     *   for [7.0..10.0]
     */

  }, {
    key: 'hasFixedRange',
    value: function hasFixedRange() {
      return this.target instanceof RangePatcher && (this.target.left.node.type === 'Int' || this.target.left.node.type === 'Float') && (this.target.right.node.type === 'Int' || this.target.right.node.type === 'Float');
    }
  }]);
  return ForInPatcher;
}(ForPatcher);

var Step = function Step(patcher) {
  classCallCheck(this, Step);

  var negated = false;
  var root = patcher;
  var apply = function apply(patcher) {
    if (patcher.node.type === 'UnaryNegateOp') {
      negated = !negated;
      apply(patcher.expression);
    } else {
      root = patcher;
    }
  };
  if (patcher) {
    apply(patcher);
    patcher.patch();
    this.isLiteral = root.node.type === 'Int' || root.node.type === 'Float';
    this.init = patcher.slice(patcher.contentStart, patcher.contentEnd);
    if (this.isLiteral) {
      this.update = root.slice(root.contentStart, root.contentEnd);
      this.number = root.node.data;
    } else {
      this.update = root.claimFreeBinding('step');
      this.number = null;
    }
  } else {
    this.isLiteral = true;
    this.init = '1';
    this.update = '1';
    this.number = 1;
  }
  this.negated = negated;
  this.isVirtual = !patcher;
};

var ForOfPatcher = function (_ForPatcher) {
  inherits(ForOfPatcher, _ForPatcher);

  function ForOfPatcher() {
    classCallCheck(this, ForOfPatcher);
    return possibleConstructorReturn(this, (ForOfPatcher.__proto__ || Object.getPrototypeOf(ForOfPatcher)).apply(this, arguments));
  }

  createClass(ForOfPatcher, [{
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      if (!this.body.inline()) {
        this.body.setIndent(this.getLoopBodyIndent());
      }

      var keyAssignee = this.keyAssignee;

      // Save the filter code and remove if it it's there.

      this.getFilterCode();
      if (this.filter) {
        this.remove(this.target.outerEnd, this.filter.outerEnd);
      }

      this.removeOwnTokenIfExists();

      var shouldExtractTarget = this.requiresExtractingTarget();
      if (shouldExtractTarget) {
        this.insert(this.innerStart, this.getTargetReference() + ' = ' + this.getTargetCode() + '\n' + this.getLoopIndent());
      }

      var keyBinding = this.getIndexBinding();
      this.insert(keyAssignee.outerStart, '(');

      // Patch the target. Also get a reference in case we need it.
      var targetReference = this.getTargetReference();
      if (shouldExtractTarget) {
        this.overwrite(this.target.outerStart, this.target.outerEnd, targetReference);
      }

      var valAssignee = this.valAssignee;


      var valueAssignment = null;
      if (valAssignee) {
        valAssignee.patch();
        var valAssigneeString = this.slice(valAssignee.contentStart, valAssignee.contentEnd);
        // `for (k, v of o` → `for (k of o`
        //        ^^^
        this.remove(keyAssignee.outerEnd, valAssignee.outerEnd);

        valueAssignment = valAssigneeString + ' = ' + this.getTargetReference() + '[' + keyBinding + ']';

        if (valAssignee.statementNeedsParens()) {
          valueAssignment = '(' + valueAssignment + ')';
        }
      }

      var relationToken = this.getRelationToken();
      if (this.node.isOwn) {
        // `for (k of o` → `for (k of Object.keys(o`
        //                            ^^^^^^^^^^^^
        this.insert(this.target.outerStart, 'Object.keys(');

        // `for (k of o` → `for (k of Object.keys(o)) {`
        //                                         ^^^^
        this.insert(this.target.outerEnd, ')) {');
      } else {
        // `for (k of o` → `for (k in o`
        //         ^^              ^^
        this.overwrite(relationToken.start, relationToken.end, 'in');

        // `for (k in o` → `for (k in o) {`
        //                             ^^^
        this.insert(this.target.outerEnd, ') {');
      }

      this.removeThenToken();
      this.patchPossibleNewlineAfterLoopHeader(this.target.outerEnd);
      if (valueAssignment !== null) {
        this.body.insertLineBefore(valueAssignment, this.getOuterLoopBodyIndent());
      }
      this.patchBodyAndFilter();
    }
  }, {
    key: 'removeOwnTokenIfExists',
    value: function removeOwnTokenIfExists() {
      if (this.node.isOwn) {
        var ownIndex = this.indexOfSourceTokenAfterSourceTokenIndex(this.contentStartTokenIndex, coffeeLex.OWN);
        var ownToken = this.sourceTokenAtIndex(ownIndex);
        this.remove(ownToken.start, this.keyAssignee.outerStart);
      }
    }
  }, {
    key: 'requiresExtractingTarget',
    value: function requiresExtractingTarget() {
      return !this.target.isRepeatable() && this.valAssignee;
    }
  }, {
    key: 'targetBindingCandidate',
    value: function targetBindingCandidate() {
      return 'object';
    }
  }, {
    key: 'indexBindingCandidates',
    value: function indexBindingCandidates() {
      return ['key'];
    }
  }]);
  return ForOfPatcher;
}(ForPatcher);

var CLOSE_TOKEN_BASE_LENGTH = 3;

var HeregexPatcher = function (_InterpolatedPatcher) {
  inherits(HeregexPatcher, _InterpolatedPatcher);

  function HeregexPatcher() {
    classCallCheck(this, HeregexPatcher);
    return possibleConstructorReturn(this, (HeregexPatcher.__proto__ || Object.getPrototypeOf(HeregexPatcher)).apply(this, arguments));
  }

  createClass(HeregexPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var openToken = this.firstToken();
      var closeToken = this.lastToken();

      this.overwrite(openToken.start, openToken.end, 'new RegExp(`');
      if (closeToken.end - closeToken.start > CLOSE_TOKEN_BASE_LENGTH) {
        // If the close token has flags, e.g. ///gi, keep the flags as a string literal.
        this.overwrite(closeToken.start, closeToken.start + CLOSE_TOKEN_BASE_LENGTH, '`, \'');
        this.insert(closeToken.end, '\')');
      } else {
        // Otherwise, don't specify flags.
        this.overwrite(closeToken.start, closeToken.end, '`)');
      }

      this.patchInterpolations();
      this.removePadding();
      this.escapeQuasis(/^\\\s/, ['`', '${', '\\']);
    }
  }]);
  return HeregexPatcher;
}(InterpolatedPatcher);

/**
 * Handles `in` operators, e.g. `a in b` and `a not in b`.
 */

var InOpPatcher = function (_BinaryOpPatcher) {
  inherits(InOpPatcher, _BinaryOpPatcher);

  /**
   * `node` is of type `InOp`.
   */
  function InOpPatcher(node, context, editor, left, right) {
    classCallCheck(this, InOpPatcher);

    var _this = possibleConstructorReturn(this, (InOpPatcher.__proto__ || Object.getPrototypeOf(InOpPatcher)).call(this, node, context, editor, left, right));

    _this.negated = node.isNot;
    return _this;
  }

  createClass(InOpPatcher, [{
    key: 'negate',
    value: function negate() {
      this.negated = !this.negated;
    }
  }, {
    key: 'operatorTokenPredicate',
    value: function operatorTokenPredicate() {
      return function (token) {
        return token.type === coffeeLex.RELATION;
      };
    }

    /**
     * LEFT 'in' RIGHT
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      // In typical cases, when converting `a in b` to `b.includes(a)`, parens
      // won't be necessary around the `b`, but to be safe, only skip the parens
      // in a specific set of known-good cases.
      var arrayNeedsParens = !this.right.isSurroundedByParentheses() && !(this.right instanceof IdentifierPatcher) && !(this.right instanceof MemberAccessOpPatcher) && !(this.right instanceof DynamicMemberAccessOpPatcher) && !(this.right instanceof FunctionApplicationPatcher) && !(this.right instanceof ArrayInitialiserPatcher) && !(this.right instanceof StringPatcher);

      this.left.patch();
      var leftCode = this.slice(this.left.contentStart, this.left.contentEnd);

      // `a in b` → `b`
      //  ^^^^^
      this.remove(this.left.outerStart, this.right.outerStart);

      if (this.negated) {
        // `b` → `!b`
        //        ^
        this.insert(this.right.outerStart, '!');
      }
      if (arrayNeedsParens) {
        // `!b` → `!(b`
        //          ^
        this.insert(this.right.outerStart, '(');
      }

      this.right.patch();

      if (arrayNeedsParens) {
        // `!(b` → `!(b)`
        //             ^
        this.insert(this.right.outerEnd, ')');
      }

      // `!(b` → `!(b).includes(a)`
      //              ^^^^^^^^^^^^
      this.insert(this.right.outerEnd, '.includes(' + leftCode + ')');
    }

    /**
     * Method invocations don't need parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return InOpPatcher;
}(BinaryOpPatcher);

/**
 * Handles `instanceof` operator, e.g. `a instanceof b`.
 */
var NegatableBinaryOpPatcher = function (_BinaryOpPatcher) {
  inherits(NegatableBinaryOpPatcher, _BinaryOpPatcher);

  function NegatableBinaryOpPatcher(node, context, editor, left, right) {
    classCallCheck(this, NegatableBinaryOpPatcher);

    var _this = possibleConstructorReturn(this, (NegatableBinaryOpPatcher.__proto__ || Object.getPrototypeOf(NegatableBinaryOpPatcher)).call(this, node, context, editor, left, right));

    _this.negated = node.isNot;
    return _this;
  }

  createClass(NegatableBinaryOpPatcher, [{
    key: 'negate',
    value: function negate() {
      this.negated = !this.negated;
    }
  }, {
    key: 'javaScriptOperator',
    value: function javaScriptOperator() {
      throw new Error('\'javaScriptOperator\' should be implemented in subclass');
    }

    /**
     * LEFT 'not'? OP RIGHT
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var negated = this.negated;

      if (negated) {
        // `a not instanceof b` → `!(a not instanceof b`
        //                         ^^
        this.insert(this.innerStart, '!(');
      }

      // Patch LEFT and RIGHT.
      get$1(NegatableBinaryOpPatcher.prototype.__proto__ || Object.getPrototypeOf(NegatableBinaryOpPatcher.prototype), 'patchAsExpression', this).call(this);

      if (negated) {
        // `!(a not instanceof b` → `!(a not instanceof b)`
        //                                               ^
        this.insert(this.innerEnd, ')');
      }

      // `!(a not instanceof b)` → `!(a instanceof b)`
      //      ^^^^^^^^^^^^^^            ^^^^^^^^^^
      var token = this.getOperatorToken();
      this.overwrite(token.start, token.end, this.javaScriptOperator());
    }

    /**
     * It may be wrapped due to negation, so don't double-wrap.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      if (this.negated) {
        return false;
      } else {
        return get$1(NegatableBinaryOpPatcher.prototype.__proto__ || Object.getPrototypeOf(NegatableBinaryOpPatcher.prototype), 'statementNeedsParens', this).call(this);
      }
    }
  }]);
  return NegatableBinaryOpPatcher;
}(BinaryOpPatcher);

/**
 * Handles `instanceof` operator, e.g. `a instanceof b`.
 */

var InstanceofOpPatcher = function (_NegatableBinaryOpPat) {
  inherits(InstanceofOpPatcher, _NegatableBinaryOpPat);

  function InstanceofOpPatcher() {
    classCallCheck(this, InstanceofOpPatcher);
    return possibleConstructorReturn(this, (InstanceofOpPatcher.__proto__ || Object.getPrototypeOf(InstanceofOpPatcher)).apply(this, arguments));
  }

  createClass(InstanceofOpPatcher, [{
    key: 'javaScriptOperator',
    value: function javaScriptOperator() {
      return 'instanceof';
    }
  }]);
  return InstanceofOpPatcher;
}(NegatableBinaryOpPatcher);

/**
 * Handles embedded JavaScript.
 */

var JavaScriptPatcher = function (_NodePatcher) {
  inherits(JavaScriptPatcher, _NodePatcher);

  function JavaScriptPatcher() {
    classCallCheck(this, JavaScriptPatcher);
    return possibleConstructorReturn(this, (JavaScriptPatcher.__proto__ || Object.getPrototypeOf(JavaScriptPatcher)).apply(this, arguments));
  }

  createClass(JavaScriptPatcher, [{
    key: 'patchAsExpression',

    /**
     * All we have to do is strip off the backticks.
     */
    value: function patchAsExpression() {
      // '`void 0`' → 'void 0`'
      //  ^
      this.remove(this.contentStart, this.contentStart + '`'.length);
      // 'void 0`' → 'void 0'
      //        ^
      this.remove(this.contentEnd - '`'.length, this.contentEnd);
    }
  }]);
  return JavaScriptPatcher;
}(NodePatcher);

var UnaryOpPatcher = function (_NodePatcher) {
  inherits(UnaryOpPatcher, _NodePatcher);

  function UnaryOpPatcher(node, context, editor, expression) {
    classCallCheck(this, UnaryOpPatcher);

    var _this = possibleConstructorReturn(this, (UnaryOpPatcher.__proto__ || Object.getPrototypeOf(UnaryOpPatcher)).call(this, node, context, editor));

    _this.expression = expression;
    return _this;
  }

  createClass(UnaryOpPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.expression.setRequiresExpression();
    }

    /**
     * OP EXPRESSION
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _ref$needsParens = _ref.needsParens;
      var needsParens = _ref$needsParens === undefined ? true : _ref$needsParens;

      this.expression.patch({ needsParens: needsParens });
    }

    /**
     * If `EXPRESSION` needs parens then `EXPRESSION OP` needs parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.expression.statementShouldAddParens();
    }
  }]);
  return UnaryOpPatcher;
}(NodePatcher);

var LogicalNotOpPatcher = function (_UnaryOpPatcher) {
  inherits(LogicalNotOpPatcher, _UnaryOpPatcher);

  function LogicalNotOpPatcher() {
    classCallCheck(this, LogicalNotOpPatcher);
    return possibleConstructorReturn(this, (LogicalNotOpPatcher.__proto__ || Object.getPrototypeOf(LogicalNotOpPatcher)).apply(this, arguments));
  }

  createClass(LogicalNotOpPatcher, [{
    key: 'isRepeatable',

    /**
     * Though it's possible that `!` could trigger a `valueOf` call to arbitrary
     * code, CoffeeScript ignores that possibility and so do we.
     */
    value: function isRepeatable() {
      return this.expression.isRepeatable();
    }

    /**
     * ( `!` | `not` ) EXPRESSION
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.expression.canHandleNegationInternally()) {
        this.expression.negate();
        this.remove(this.contentStart, this.expression.outerStart);
      } else {
        this.overwrite(this.contentStart, this.expression.outerStart, '!');
      }
      get$1(LogicalNotOpPatcher.prototype.__proto__ || Object.getPrototypeOf(LogicalNotOpPatcher.prototype), 'patchAsExpression', this).call(this, options);
    }
  }]);
  return LogicalNotOpPatcher;
}(UnaryOpPatcher);

var LogicalOpCompoundAssignOpPatcher = function (_CompoundAssignOpPatc) {
  inherits(LogicalOpCompoundAssignOpPatcher, _CompoundAssignOpPatc);

  function LogicalOpCompoundAssignOpPatcher() {
    classCallCheck(this, LogicalOpCompoundAssignOpPatcher);
    return possibleConstructorReturn(this, (LogicalOpCompoundAssignOpPatcher.__proto__ || Object.getPrototypeOf(LogicalOpCompoundAssignOpPatcher)).apply(this, arguments));
  }

  createClass(LogicalOpCompoundAssignOpPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var operator = this.getOperatorToken();

      // `a &&= b` → `a && b`
      //    ^^^         ^^
      this.overwrite(operator.start, operator.end, this.isOrOp() ? '||' : '&&');

      var assigneeAgain = this.assignee.makeRepeatable(false);
      this.assignee.patch();

      // `a && b` → `a && (a = b`
      //                  ^^^^^
      this.insert(this.expression.outerStart, '(' + assigneeAgain + ' = ');

      this.expression.patch();

      // `a && (a = b` → `a && (a = b)`
      //                             ^
      this.insert(this.expression.outerEnd, ')');
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      // `a &&= b` → `if (a &&= b`
      //              ^^^^
      this.insert(this.contentStart, 'if (');

      if (this.isOrOp()) {
        this.assignee.negate();
      }

      var assigneeAgain = this.assignee.makeRepeatable(false);
      this.assignee.patch();

      // `if (a &&= b` → `if (a) { a = b`
      //       ^^^^^           ^^^^^^^^
      this.overwrite(this.assignee.outerEnd, this.expression.outerStart, ') { ' + assigneeAgain + ' = ');

      this.expression.patch();

      // `if (a) { a = b` → `if (a) { a = b }`
      //                                   ^^
      this.insert(this.expression.outerEnd, ' }');
    }

    /**
     * @private
     */

  }, {
    key: 'isOrOp',
    value: function isOrOp() {
      var operator = this.getOperatorToken();
      var op = this.sourceOfToken(operator);
      // There could be a space in the middle of the operator, like `or =` or
      // `|| =`, and "op" will just be the first token in that case. So just check
      // the start of the operator.
      return op.substr(0, 2) === '||' || op.substr(0, 2) === 'or';
    }

    /**
     * We always start with an `if` statement, so no parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return LogicalOpCompoundAssignOpPatcher;
}(CompoundAssignOpPatcher);

/**
 * Handles logical AND and logical OR.
 *
 * This class is primarily responsible for rewriting `and` to `&&` and `or` to
 * `||`. It also applies De Morgan's laws [1] in the event of negation, such as
 * when used as the condition of an `unless` expression:
 *
 *   a unless b && c  # equivalent to `a if !b || !c`
 *
 * [1]: https://en.wikipedia.org/wiki/De_Morgan%27s_laws
 */
var LogicalOpPatcher = function (_BinaryOpPatcher) {
  inherits(LogicalOpPatcher, _BinaryOpPatcher);

  /**
   * `node` is expected to be either `LogicalAndOp` or `LogicalOrOp`.
   */
  function LogicalOpPatcher(node, context, editor, left, right) {
    classCallCheck(this, LogicalOpPatcher);

    var _this = possibleConstructorReturn(this, (LogicalOpPatcher.__proto__ || Object.getPrototypeOf(LogicalOpPatcher)).call(this, node, context, editor));

    _this.negated = false;

    _this.left = left;
    _this.right = right;
    return _this;
  }

  createClass(LogicalOpPatcher, [{
    key: 'patchOperator',
    value: function patchOperator() {
      var operatorToken = this.getOperatorToken();
      this.overwrite(operatorToken.start, operatorToken.end, this.getOperator());
    }

    /**
     * Apply De Morgan's law.
     *
     * @private
     */

  }, {
    key: 'getOperator',
    value: function getOperator() {
      var operatorToken = this.getOperatorToken();
      var operator = this.context.source.slice(operatorToken.start, operatorToken.end);
      if (operator === 'and') {
        operator = '&&';
      } else if (operator === 'or') {
        operator = '||';
      }
      if (this.negated) {
        return operator === '&&' ? '||' : '&&';
      } else {
        return operator;
      }
    }
  }, {
    key: 'negate',
    value: function negate() {
      this.negated = !this.negated;
      this.left.negate();
      this.right.negate();
    }
  }]);
  return LogicalOpPatcher;
}(BinaryOpPatcher);

var MOD_HELPER = 'function __mod__(a, b) {\n  a = +a;\n  b = +b;\n  return (a % b + b) % b;\n}';

/**
 * Handles modulo operator, e.g. `a %% b`.
 */

var ModuloOpPatcher = function (_BinaryOpPatcher) {
  inherits(ModuloOpPatcher, _BinaryOpPatcher);

  /**
   * `node` is of type `ModuloOp`.
   */
  function ModuloOpPatcher(node, context, editor, left, right) {
    classCallCheck(this, ModuloOpPatcher);
    return possibleConstructorReturn(this, (ModuloOpPatcher.__proto__ || Object.getPrototypeOf(ModuloOpPatcher)).call(this, node, context, editor, left, right));
  }

  createClass(ModuloOpPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var helper = this.registerHelper('__mod__', MOD_HELPER);

      // `a %% b` → `__mod__(a %% b`
      //             ^^^^^^^^
      this.insert(this.left.outerStart, helper + '(');

      this.left.patch();

      // `__mod__(a %% b` → `__mod__(a, b`
      //           ^^^^               ^^
      this.overwrite(this.left.outerEnd, this.right.outerStart, ', ');

      this.right.patch();

      // `__mod__(a, b` → `__mod__(a, b)`
      //                               ^
      this.insert(this.right.outerEnd, ')');
    }

    /**
     * We always prefix with `__mod__` so no parens needed.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return ModuloOpPatcher;
}(BinaryOpPatcher);

/**
 * Handles construction of objects with `new`.
 */

var NewOpPatcher = function (_FunctionApplicationP) {
  inherits(NewOpPatcher, _FunctionApplicationP);

  function NewOpPatcher() {
    classCallCheck(this, NewOpPatcher);
    return possibleConstructorReturn(this, (NewOpPatcher.__proto__ || Object.getPrototypeOf(NewOpPatcher)).apply(this, arguments));
  }

  return NewOpPatcher;
}(FunctionApplicationPatcher);

/**
 * Handles `of` operators, e.g. `a of b` and `a not of b`.
 */

var OfOpPatcher = function (_NegatableBinaryOpPat) {
  inherits(OfOpPatcher, _NegatableBinaryOpPat);

  function OfOpPatcher() {
    classCallCheck(this, OfOpPatcher);
    return possibleConstructorReturn(this, (OfOpPatcher.__proto__ || Object.getPrototypeOf(OfOpPatcher)).apply(this, arguments));
  }

  createClass(OfOpPatcher, [{
    key: 'operatorTokenPredicate',
    value: function operatorTokenPredicate() {
      return function (token) {
        return token.type === coffeeLex.RELATION;
      };
    }
  }, {
    key: 'javaScriptOperator',
    value: function javaScriptOperator() {
      return 'in';
    }
  }]);
  return OfOpPatcher;
}(NegatableBinaryOpPatcher);

/**
 * Generates a blank object with no prototype.
 */
function blank() {
  return Object.create(null);
}

var BLOCK_COMMENT_DELIMITER = '###';

var ProgramPatcher = function (_NodePatcher) {
  inherits(ProgramPatcher, _NodePatcher);

  function ProgramPatcher(node, context, editor, body) {
    classCallCheck(this, ProgramPatcher);

    var _this = possibleConstructorReturn(this, (ProgramPatcher.__proto__ || Object.getPrototypeOf(ProgramPatcher)).call(this, node, context, editor));

    _this.body = body;

    _this.helpers = blank();
    _this._indentString = null;
    return _this;
  }

  createClass(ProgramPatcher, [{
    key: 'shouldTrimContentRange',
    value: function shouldTrimContentRange() {
      return true;
    }
  }, {
    key: 'canPatchAsExpression',
    value: function canPatchAsExpression() {
      return false;
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      if (this.body) {
        this.body.patch({ leftBrace: false, rightBrace: false });
      }
      this.patchContinuations();
      this.patchComments();

      for (var helper in this.helpers) {
        this.editor.append('\n' + this.helpers[helper]);
      }
    }

    /**
     * Removes continuation tokens (i.e. '\' at the end of a line).
     *
     * @private
     */

  }, {
    key: 'patchContinuations',
    value: function patchContinuations() {
      var _this2 = this;

      this.getProgramSourceTokens().forEach(function (token) {
        if (token.type === coffeeLex.CONTINUATION) {
          _this2.remove(token.start, token.end);
        }
      });
    }

    /**
     * Replaces CoffeeScript style comments with JavaScript style comments.
     *
     * @private
     */

  }, {
    key: 'patchComments',
    value: function patchComments() {
      var _this3 = this;

      var source = this.context.source;

      this.getProgramSourceTokens().forEach(function (token) {
        if (token.type === coffeeLex.COMMENT) {
          if (token.start === 0 && source[1] === '!') {
            _this3.patchShebangComment(token);
          } else {
            _this3.patchLineComment(token);
          }
        } else if (token.type === coffeeLex.HERECOMMENT) {
          _this3.patchBlockComment(token);
        }
      });
    }

    /**
     * Patches a block comment.
     *
     * @private
     */

  }, {
    key: 'patchBlockComment',
    value: function patchBlockComment(comment) {
      var _this4 = this;

      var start = comment.start;
      var end = comment.end;

      this.overwrite(start, start + BLOCK_COMMENT_DELIMITER.length, '/*');

      var atStartOfLine = false;
      var lastStartOfLine = null;
      var lineUpAsterisks = true;
      var isMultiline = false;
      var source = this.context.source;

      var expectedIndent = getIndent$1(source, start);
      var leadingHashIndexes = [];

      for (var index = start + BLOCK_COMMENT_DELIMITER.length; index < end - BLOCK_COMMENT_DELIMITER.length; index++) {
        switch (source[index]) {
          case '\n':
            isMultiline = true;
            atStartOfLine = true;
            lastStartOfLine = index + '\n'.length;
            break;

          case ' ':
          case '\t':
            break;

          case '#':
            if (atStartOfLine) {
              leadingHashIndexes.push(index);
              atStartOfLine = false;
              if (source.slice(lastStartOfLine, index) !== expectedIndent) {
                lineUpAsterisks = false;
              }
            }
            break;

          default:
            if (atStartOfLine) {
              atStartOfLine = false;
              lineUpAsterisks = false;
            }
            break;
        }
      }

      leadingHashIndexes.forEach(function (index) {
        _this4.overwrite(index, index + '#'.length, lineUpAsterisks ? ' *' : '*');
      });

      this.overwrite(end - BLOCK_COMMENT_DELIMITER.length, end, isMultiline && lineUpAsterisks ? ' */' : '*/');
    }

    /**
     * Patches a single-line comment.
     *
     * @private
     */

  }, {
    key: 'patchLineComment',
    value: function patchLineComment(comment) {
      var start = comment.start;

      this.overwrite(start, start + '#'.length, '//');
    }

    /**
     * Patches a shebang comment.
     *
     * @private
     */

  }, {
    key: 'patchShebangComment',
    value: function patchShebangComment(comment) {
      var start = comment.start;
      var end = comment.end;

      var commentBody = this.slice(start, end);
      var coffeeIndex = commentBody.indexOf('coffee');

      if (coffeeIndex >= 0) {
        this.overwrite(start + coffeeIndex, start + coffeeIndex + 'coffee'.length, 'node');
      }
    }

    /**
     * Register a helper to be reused in several places.
     *
     * FIXME: Pick a different name than what is in scope.
     */

  }, {
    key: 'registerHelper',
    value: function registerHelper(name, code) {
      code = code.trim();
      if (name in this.helpers) {
        if (this.helpers[name] !== code) {
          throw new Error('BUG: cannot override helper \'' + name + '\'');
        }
      } else {
        this.helpers[name] = code;
      }
      return name;
    }

    /**
     * Gets the indent string used for each indent in this program.
     */

  }, {
    key: 'getProgramIndentString',
    value: function getProgramIndentString() {
      if (!this._indentString) {
        this._indentString = determineIndent(this.context.source);
      }
      return this._indentString;
    }

    /**
     * Serve as the implicit return patcher for anyone not included in a function.
     */

  }, {
    key: 'implicitReturnPatcher',
    value: function implicitReturnPatcher() {
      return this;
    }

    /**
     * Serve as the default for anyone not included in a function.
     */

  }, {
    key: 'implicitReturnWillBreak',
    value: function implicitReturnWillBreak() {
      return true;
    }
  }]);
  return ProgramPatcher;
}(NodePatcher);

var ProtoMemberAccessOpPatcher = function (_MemberAccessOpPatche) {
  inherits(ProtoMemberAccessOpPatcher, _MemberAccessOpPatche);

  function ProtoMemberAccessOpPatcher() {
    classCallCheck(this, ProtoMemberAccessOpPatcher);
    return possibleConstructorReturn(this, (ProtoMemberAccessOpPatcher.__proto__ || Object.getPrototypeOf(ProtoMemberAccessOpPatcher)).apply(this, arguments));
  }

  createClass(ProtoMemberAccessOpPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.expression.patch();
      // `a::b` → `a.prototype.b`
      //   ^^        ^^^^^^^^^^
      var memberNameToken = this.getMemberNameSourceToken();
      this.overwrite(this.expression.outerEnd, memberNameToken.start, '.prototype.');
    }
  }, {
    key: 'hasImplicitOperator',
    value: function hasImplicitOperator() {
      return false;
    }
  }, {
    key: 'getFullMemberName',
    value: function getFullMemberName() {
      return 'prototype.' + this.getMemberName();
    }
  }]);
  return ProtoMemberAccessOpPatcher;
}(MemberAccessOpPatcher);

/**
 * Handles regexes and heregexes (e.g. `/\.js$/` and `///a/b/c///`).
 */

var RegExpPatcher = function (_NodePatcher) {
  inherits(RegExpPatcher, _NodePatcher);

  function RegExpPatcher() {
    classCallCheck(this, RegExpPatcher);
    return possibleConstructorReturn(this, (RegExpPatcher.__proto__ || Object.getPrototypeOf(RegExpPatcher)).apply(this, arguments));
  }

  createClass(RegExpPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.overwrite(this.contentStart, this.contentEnd, this.node.data);
    }
  }]);
  return RegExpPatcher;
}(NodePatcher);

/**
 * Handles spread operations, e.g. `a(b...)` or `[a...]`.
 */
var SpreadPatcher = function (_NodePatcher) {
  inherits(SpreadPatcher, _NodePatcher);

  function SpreadPatcher(node, context, editor, expression) {
    classCallCheck(this, SpreadPatcher);

    var _this = possibleConstructorReturn(this, (SpreadPatcher.__proto__ || Object.getPrototypeOf(SpreadPatcher)).call(this, node, context, editor));

    _this.expression = expression;
    return _this;
  }

  createClass(SpreadPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.expression.setRequiresExpression();
    }

    /**
     * All we have to do is move the `...` from the right to the left.
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (this.node.virtual) {
        // i.e. the virtual spread in a bare `super` call.
        return;
      }

      // `a...` → `...a...`
      //           ^^^
      this.insert(this.expression.outerStart, '...');
      this.expression.patch();
      // `...a...` → `...a`
      //      ^^^
      this.remove(this.expression.outerEnd, this.contentEnd);
    }
  }]);
  return SpreadPatcher;
}(NodePatcher);

var RestPatcher = function (_SpreadPatcher) {
  inherits(RestPatcher, _SpreadPatcher);

  function RestPatcher() {
    classCallCheck(this, RestPatcher);
    return possibleConstructorReturn(this, (RestPatcher.__proto__ || Object.getPrototypeOf(RestPatcher)).apply(this, arguments));
  }

  return RestPatcher;
}(SpreadPatcher);

/**
 * Handles sequence expressions, e.g `a; b`.
 */
var SeqOpPatcher = function (_BinaryOpPatcher) {
  inherits(SeqOpPatcher, _BinaryOpPatcher);

  function SeqOpPatcher() {
    classCallCheck(this, SeqOpPatcher);
    return possibleConstructorReturn(this, (SeqOpPatcher.__proto__ || Object.getPrototypeOf(SeqOpPatcher)).apply(this, arguments));
  }

  createClass(SeqOpPatcher, [{
    key: 'patchAsExpression',

    /**
     * LEFT ';' RIGHT
     */
    value: function patchAsExpression() {
      this.left.patch();

      var token = this.getOperatorToken();

      if (token.type === coffeeLex.SEMICOLON) {
        // `a; b` → `a, b`
        //   ^        ^
        this.overwrite(token.start, token.end, ',');
      } else if (token.type === coffeeLex.NEWLINE) {
        this.insert(this.left.outerEnd, ',');
      }

      this.right.patch();
    }
  }, {
    key: 'operatorTokenPredicate',
    value: function operatorTokenPredicate() {
      return function (token) {
        return token.type === coffeeLex.SEMICOLON || token.type === coffeeLex.NEWLINE;
      };
    }
  }]);
  return SeqOpPatcher;
}(BinaryOpPatcher);

/**
 * Handles array or string slicing, e.g. `names[i..]`.
 */

var SlicePatcher = function (_NodePatcher) {
  inherits(SlicePatcher, _NodePatcher);

  /**
   * `node` is of type `Slice`.
   */
  function SlicePatcher(node, context, editor, expression, left, right) {
    classCallCheck(this, SlicePatcher);

    var _this = possibleConstructorReturn(this, (SlicePatcher.__proto__ || Object.getPrototypeOf(SlicePatcher)).call(this, node, context, editor));

    _this.expression = expression;
    _this.left = left;
    _this.right = right;
    return _this;
  }

  createClass(SlicePatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.expression.setRequiresExpression();
      if (this.left) {
        this.left.setRequiresExpression();
      }
      if (this.right) {
        this.right.setRequiresExpression();
      }
    }

    /**
     * EXPRESSION '[' LEFT? ( .. | ... ) RIGHT? ']'
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.expression.patch();
      var indexStart = this.getIndexStartSourceToken();
      // `a[0..1]` → `a.slice(0..1]`
      //   ^           ^^^^^^^
      this.overwrite(indexStart.start, indexStart.end, '.slice(');
      if (this.left) {
        this.left.patch();
      } else if (this.right) {
        // `a.slice(..1]` → `a.slice(0..1]`
        //                           ^
        this.insert(indexStart.end, '0');
      }
      var slice = this.getSliceSourceToken();
      var inclusive = slice.end - slice.start === '..'.length;
      var right = this.right;
      if (right) {
        if (inclusive) {
          if (right.node.raw === '-1') {
            this.remove(slice.start, right.outerEnd);
          } else if (right.node.type === 'Int') {
            this.overwrite(slice.start, right.outerEnd, ', ' + (right.node.data + 1));
          } else {
            // `a.slice(0..1]` → `a.slice(0, 1]`
            //           ^^                ^^
            this.overwrite(slice.start, slice.end, ', ');
            right.patch();
            this.insert(right.outerEnd, ' + 1 || undefined');
          }
        } else {
          // `a.slice(0..1]` → `a.slice(0, 1]`
          //           ^^                ^^
          this.overwrite(slice.start, slice.end, ', ');
          right.patch();
        }
      } else {
        // `a.slice(0..]` → `a.slice(0]`
        //           ^^
        this.overwrite(slice.start, slice.end, '');
      }
      var indexEnd = this.getIndexEndSourceToken();
      // `a.slice(0, 1]` → `a.slice(0, 1)`
      //              ^                 ^
      this.overwrite(indexEnd.start, indexEnd.end, ')');
    }

    /**
     * @private
     */

  }, {
    key: 'getIndexStartSourceToken',
    value: function getIndexStartSourceToken() {
      var tokens$$1 = this.context.sourceTokens;
      var index = tokens$$1.indexOfTokenMatchingPredicate(function (token) {
        return token.type === coffeeLex.LBRACKET;
      }, this.expression.outerEndTokenIndex);
      if (!index || index.isAfter(this.contentEndTokenIndex)) {
        throw this.error('could not find INDEX_START after slice expression');
      }
      return tokens$$1.tokenAtIndex(index);
    }

    /**
     * @private
     */

  }, {
    key: 'getSliceSourceToken',
    value: function getSliceSourceToken() {
      var tokens$$1 = this.context.sourceTokens;
      var source = this.context.source;

      var index = tokens$$1.indexOfTokenMatchingPredicate(function (token) {
        if (token.type !== coffeeLex.RANGE) {
          return false;
        }
        var operator = source.slice(token.start, token.end);
        return operator === '...' || operator === '..';
      }, this.left ? this.left.outerEndTokenIndex : this.expression.outerEndTokenIndex);
      if (!index || index.isAfter(this.contentEndTokenIndex)) {
        throw this.error('could not find \'..\' or \'...\' in slice');
      }
      return tokens$$1.tokenAtIndex(index);
    }

    /**
     * @private
     */

  }, {
    key: 'getIndexEndSourceToken',
    value: function getIndexEndSourceToken() {
      var tokens$$1 = this.context.sourceTokens;
      var index = tokens$$1.lastIndexOfTokenMatchingPredicate(function (token) {
        return token.type === coffeeLex.RBRACKET;
      }, this.outerEndTokenIndex);
      if (!index || index.isBefore(this.contentStartTokenIndex)) {
        throw this.error('could not find \']\' ending slice');
      }
      return tokens$$1.tokenAtIndex(index);
    }

    /**
     * If `BASE` needs parens then `BASE[0..1]` needs parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return this.expression.statementShouldAddParens();
    }
  }]);
  return SlicePatcher;
}(NodePatcher);

var GUARD_HELPER$1 = 'function __guard__(value, transform) {\n  return (typeof value !== \'undefined\' && value !== null) ? transform(value) : undefined;\n}';

var SoakedMemberAccessOpPatcher = function (_MemberAccessOpPatche) {
  inherits(SoakedMemberAccessOpPatcher, _MemberAccessOpPatche);

  function SoakedMemberAccessOpPatcher(node, context, editor, expression) {
    classCallCheck(this, SoakedMemberAccessOpPatcher);

    var _this = possibleConstructorReturn(this, (SoakedMemberAccessOpPatcher.__proto__ || Object.getPrototypeOf(SoakedMemberAccessOpPatcher)).call(this, node, context, editor, expression));

    _this._shouldSkipSoakPatch = false;
    return _this;
  }

  createClass(SoakedMemberAccessOpPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (!this._shouldSkipSoakPatch) {
        this.registerHelper('__guard__', GUARD_HELPER$1);
        var memberNameToken = this.getMemberNameSourceToken();
        var soakContainer = findSoakContainer(this);
        var varName = soakContainer.claimFreeBinding('x');
        this.overwrite(this.expression.outerEnd, memberNameToken.start, ', ' + varName + ' => ' + varName + '.');
        soakContainer.insert(soakContainer.contentStart, '__guard__(');
        soakContainer.insert(soakContainer.contentEnd, ')');
      }
      this.expression.patch();
    }
  }, {
    key: 'setShouldSkipSoakPatch',
    value: function setShouldSkipSoakPatch() {
      this._shouldSkipSoakPatch = true;
    }

    /**
     * There isn't an implicit-dot syntax like @a for soaked access.
     */

  }, {
    key: 'hasImplicitOperator',
    value: function hasImplicitOperator() {
      return false;
    }
  }]);
  return SoakedMemberAccessOpPatcher;
}(MemberAccessOpPatcher);

var GUARD_FUNC_HELPER = 'function __guardFunc__(func, transform) {\n  return typeof func === \'function\' ? transform(func) : undefined;\n}';

/**
 * Special guard function so that the calling code can properly specify the
 * proper `this` value in the call.
 *
 * Note that this method is slightly incorrect in that it's more defensive than
 * `a.b?()`; it does a null check on `a`, when CoffeeScript code would crash on
 * null/undefined `a`. This may be possible to correct in the future, but there
 * are a few reasons it's useful in the current implementation:
 * - The implementation of soak chaining requires that soak operations do
 *   nothing if their leftmost value is undefined, e.g. that `a?.b?.c` can be
 *   correctly rewritten as `(a?.b)?.c`. Soaked method-style function
 *   application is a counterexample, though: `a?.b.c?()` cannot be rewritten as
 *   `(a?.b).c?()`, since the second one crashes if `a` is null. So, instead, we
 *   effectively treat it as `(a?.b)?.c?()`, which again isn't 100% correct, but
 *   will properly guard on `a` being null/undefined.
 * - We'd need a function like this anyway to transform code like `a?.b?()`, so
 *   this avoids the need to have two slightly different functions to handle
 *   this case which is already fairly obscure.
 */
var GUARD_METHOD_HELPER = 'function __guardMethod__(obj, methodName, transform) {\n  if (typeof obj !== \'undefined\' && obj !== null && typeof obj[methodName] === \'function\') {\n    return transform(obj, methodName);\n  } else {\n    return undefined;\n  }\n}';

var SoakedFunctionApplicationPatcher = function (_FunctionApplicationP) {
  inherits(SoakedFunctionApplicationPatcher, _FunctionApplicationP);

  function SoakedFunctionApplicationPatcher() {
    classCallCheck(this, SoakedFunctionApplicationPatcher);
    return possibleConstructorReturn(this, (SoakedFunctionApplicationPatcher.__proto__ || Object.getPrototypeOf(SoakedFunctionApplicationPatcher)).apply(this, arguments));
  }

  createClass(SoakedFunctionApplicationPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (this.fn instanceof MemberAccessOpPatcher) {
        this.patchMethodCall(this.fn);
      } else if (this.fn instanceof DynamicMemberAccessOpPatcher) {
        this.patchDynamicMethodCall(this.fn);
      } else {
        this.patchNonMethodCall();
      }
      get$1(SoakedFunctionApplicationPatcher.prototype.__proto__ || Object.getPrototypeOf(SoakedFunctionApplicationPatcher.prototype), 'patchAsExpression', this).call(this);
    }

    /**
     * Change a.b?() to __guardMethod__(a, 'b', o => o.b())
     */

  }, {
    key: 'patchMethodCall',
    value: function patchMethodCall(fn) {
      var memberName = fn.getMemberName();
      if (fn.hasImplicitOperator()) {
        fn.setSkipImplicitDotCreation();
      }

      this.registerHelper('__guardMethod__', GUARD_METHOD_HELPER);
      if (fn instanceof SoakedMemberAccessOpPatcher) {
        fn.setShouldSkipSoakPatch();
      }

      var callStartToken = this.getCallStartToken();
      var soakContainer = findSoakContainer(this);
      var varName = soakContainer.claimFreeBinding('o');
      // Since memberName is always a valid identifier, we can put it in a string
      // literal without worrying about escaping.
      this.overwrite(fn.expression.outerEnd, callStartToken.end, ', \'' + memberName + '\', ' + varName + ' => ' + varName + '.' + memberName + '(');
      soakContainer.insert(soakContainer.contentStart, '__guardMethod__(');
      soakContainer.insert(soakContainer.contentEnd, ')');
    }

    /**
     * Change a[b]?() to __guardMethod__(a, b, (o, m) => o[m]())
     */

  }, {
    key: 'patchDynamicMethodCall',
    value: function patchDynamicMethodCall(fn) {
      var expression = fn.expression;
      var indexingExpr = fn.indexingExpr;


      this.registerHelper('__guardMethod__', GUARD_METHOD_HELPER);
      if (fn instanceof SoakedDynamicMemberAccessOpPatcher) {
        fn.setShouldSkipSoakPatch();
      }

      var callStartToken = this.getCallStartToken();
      var soakContainer = findSoakContainer(this);
      var objVarName = soakContainer.claimFreeBinding('o');
      var methodVarName = soakContainer.claimFreeBinding('m');
      this.overwrite(expression.outerEnd, indexingExpr.outerStart, ', ');
      this.overwrite(indexingExpr.outerEnd, callStartToken.end, ', (' + objVarName + ', ' + methodVarName + ') => ' + objVarName + '[' + methodVarName + '](');
      soakContainer.insert(soakContainer.contentStart, '__guardMethod__(');
      soakContainer.insert(soakContainer.contentEnd, ')');
    }
  }, {
    key: 'patchNonMethodCall',
    value: function patchNonMethodCall() {
      this.registerHelper('__guardFunc__', GUARD_FUNC_HELPER);
      var callStartToken = this.getCallStartToken();
      var soakContainer = findSoakContainer(this);
      var varName = soakContainer.claimFreeBinding('f');
      this.overwrite(this.fn.outerEnd, callStartToken.end, ', ' + varName + ' => ' + varName + '(');
      soakContainer.insert(soakContainer.contentStart, '__guardFunc__(');
      soakContainer.insert(soakContainer.contentEnd, ')');
    }
  }, {
    key: 'getCallStartToken',
    value: function getCallStartToken() {
      var tokens$$1 = this.context.sourceTokens;
      var index = tokens$$1.indexOfTokenMatchingPredicate(function (token) {
        return token.type === coffeeLex.CALL_START;
      }, this.fn.outerEndTokenIndex);
      if (!index || index.isAfter(this.contentEndTokenIndex)) {
        throw this.error('unable to find open-paren for function call');
      }
      return tokens$$1.tokenAtIndex(index);
    }
  }]);
  return SoakedFunctionApplicationPatcher;
}(FunctionApplicationPatcher);

/**
 * Find the enclosing node defining the "soak range" for a given soak operation.
 * For example, in the expression `a(b?.c.d())`, returns the `b?.c.d()` node,
 * since that's the chain of operations that will be skipped if `b` is null or
 * undefined.
 */
function findSoakContainer(patcher) {
  var result = patcher;
  while (canParentHandleSoak(result)) {
    result = result.parent;
  }
  return result;
}

/**
 * Determine if this "soak range" can be expanded outward.
 *
 * In determining the soak range, we also stop when we see other soak
 * operations. For example, in `a?.b?.c`, `a?.b` is used as the soak container
 * for the first soak, which works because the second soak operation will
 * "take over"; if `a` is null or undefined, then `a?.b` will be undefined, so
 * the entire thing will evaluate to undefined. This requires all soak
 * operations to do a null check on their leftmost value, which is why we need
 * to make __guardMethod__ do a null check on the object arg.
 */
function canParentHandleSoak(patcher) {
  if (patcher.parent === null) {
    return false;
  }
  if (patcher.isSurroundedByParentheses()) {
    return false;
  }
  // If we are currently the `a?.b` in an expression like `a?.b.c?()`, we don't
  // want to expand any further, since method-style soaked function application
  // is a special case and the `.c?(` will be patched. In this case, the `a?.b`
  // is what we should set as our soak container, since the method-style soak
  // implementation will "take over" from that point.
  if ((patcher.parent instanceof MemberAccessOpPatcher || patcher.parent instanceof DynamicMemberAccessOpPatcher) && patcher.parent.parent !== null && patcher.parent.parent instanceof SoakedFunctionApplicationPatcher && patcher.parent.parent.fn === patcher.parent) {
    return false;
  }
  if (patcher.parent instanceof MemberAccessOpPatcher && !(patcher.parent instanceof SoakedMemberAccessOpPatcher)) {
    return true;
  }
  if (patcher.parent instanceof DynamicMemberAccessOpPatcher && !(patcher.parent instanceof SoakedDynamicMemberAccessOpPatcher) && patcher.parent.expression === patcher) {
    return true;
  }
  if (patcher.parent instanceof FunctionApplicationPatcher && !(patcher.parent instanceof SoakedFunctionApplicationPatcher) && patcher.parent.fn === patcher) {
    return true;
  }
  if (patcher.parent instanceof AssignOpPatcher && patcher.parent.assignee === patcher) {
    return true;
  }
  if (['PostIncrementOp', 'PostDecrementOp'].indexOf(patcher.parent.node.type) >= 0) {
    return true;
  }
  if (['PreIncrementOp', 'PreDecrementOp', 'DeleteOp'].indexOf(patcher.parent.node.type) >= 0) {
    throw patcher.parent.error('Expressions like `++a?.b`, `--a?.b`, and `delete a?.b` are not supported yet.');
  }
  return false;
}

var GUARD_HELPER = 'function __guard__(value, transform) {\n  return (typeof value !== \'undefined\' && value !== null) ? transform(value) : undefined;\n}';

var SoakedDynamicMemberAccessOpPatcher = function (_DynamicMemberAccessO) {
  inherits(SoakedDynamicMemberAccessOpPatcher, _DynamicMemberAccessO);

  function SoakedDynamicMemberAccessOpPatcher(node, context, editor, expression, indexingExpr) {
    classCallCheck(this, SoakedDynamicMemberAccessOpPatcher);

    var _this = possibleConstructorReturn(this, (SoakedDynamicMemberAccessOpPatcher.__proto__ || Object.getPrototypeOf(SoakedDynamicMemberAccessOpPatcher)).call(this, node, context, editor, expression, indexingExpr));

    _this._shouldSkipSoakPatch = false;
    return _this;
  }

  createClass(SoakedDynamicMemberAccessOpPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (!this._shouldSkipSoakPatch) {
        this.registerHelper('__guard__', GUARD_HELPER);
        var soakContainer = findSoakContainer(this);
        var varName = soakContainer.claimFreeBinding('x');
        this.overwrite(this.expression.outerEnd, this.indexingExpr.outerStart, ', ' + varName + ' => ' + varName + '[');
        soakContainer.insert(soakContainer.contentStart, '__guard__(');
        soakContainer.insert(soakContainer.contentEnd, ')');
      }

      this.expression.patch();
      this.indexingExpr.patch();
    }
  }, {
    key: 'setShouldSkipSoakPatch',
    value: function setShouldSkipSoakPatch() {
      this._shouldSkipSoakPatch = true;
    }
  }]);
  return SoakedDynamicMemberAccessOpPatcher;
}(DynamicMemberAccessOpPatcher);

var SuperPatcher = function (_NodePatcher) {
  inherits(SuperPatcher, _NodePatcher);

  function SuperPatcher() {
    classCallCheck(this, SuperPatcher);
    return possibleConstructorReturn(this, (SuperPatcher.__proto__ || Object.getPrototypeOf(SuperPatcher)).apply(this, arguments));
  }

  createClass(SuperPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var name = this.getContainingMethodName();
      if (name) {
        this.insert(this.contentEnd, '.' + name);
      }
    }

    /**
     * @private
     */

  }, {
    key: 'getContainingMethodName',
    value: function getContainingMethodName() {
      var parent = this.parent;

      while (parent) {
        if (parent instanceof ConstructorPatcher) {
          return null;
        } else if (parent instanceof ClassAssignOpPatcher) {
          if (parent.isStaticMethod()) {
            return parent.key.node.memberName;
          } else {
            return parent.key.node.data;
          }
        }
        parent = parent.parent;
      }
      throw this.error('no containing method found for \'super\'');
    }
  }]);
  return SuperPatcher;
}(NodePatcher);

var SwitchCasePatcher = function (_NodePatcher) {
  inherits(SwitchCasePatcher, _NodePatcher);

  function SwitchCasePatcher(node, context, editor, conditions, consequent) {
    classCallCheck(this, SwitchCasePatcher);

    var _this = possibleConstructorReturn(this, (SwitchCasePatcher.__proto__ || Object.getPrototypeOf(SwitchCasePatcher)).call(this, node, context, editor));

    _this.conditions = conditions;
    _this.consequent = consequent;
    _this.negated = false;
    return _this;
  }

  createClass(SwitchCasePatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.conditions.forEach(function (condition) {
        return condition.setRequiresExpression();
      });
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var _this2 = this;

      // `when a, b, c then d` → `a, b, c then d`
      //  ^^^^^
      var whenToken = this.getWhenToken();
      this.remove(whenToken.start, this.conditions[0].contentStart);

      // `a, b, c then d` → `a b c then d`
      //   ^  ^
      this.getCommaTokens().forEach(function (comma) {
        _this2.remove(comma.start, comma.end);
      });

      this.conditions.forEach(function (condition) {
        // `a b c then d` → `case a: case b: case c: then d`
        //                   ^^^^^ ^^^^^^^ ^^^^^^^ ^
        _this2.insert(condition.outerStart, 'case ');
        if (_this2.negated) {
          condition.negate();
        }
        condition.patch({ leftBrace: false, rightBrace: false });
        _this2.insert(condition.outerEnd, ':');
      });

      // `case a: case b: case c: then d → `case a: case b: case c: d`
      //                          ^^^^^
      var thenToken = this.getThenToken();
      if (thenToken) {
        if (this.consequent !== null) {
          this.remove(thenToken.start, this.consequent.contentStart);
        } else {
          this.remove(thenToken.start, thenToken.end);
        }
      }

      if (this.consequent !== null) {
        this.consequent.patch({ leftBrace: false, rightBrace: false });
      }

      var hasBreak = this.getBreakToken() !== null;
      var implicitReturnWillBreak = this.implicitlyReturns() && this.implicitReturnWillBreak() && (!this.consequent || this.consequent.allCodePathsPresent());
      var shouldAddBreak = !hasBreak && !implicitReturnWillBreak;
      if (shouldAddBreak) {
        if (thenToken) {
          // `case a: case b: case c: then d → `case a: case b: case c: d break`
          //                                                             ^^^^^^
          if (this.consequent !== null) {
            this.insert(this.consequent.contentEnd, ' break');
          } else {
            this.insert(thenToken.end, ' break');
          }
        } else {
          this.appendLineAfter('break', 1);
        }
      }
    }
  }, {
    key: 'setImplicitlyReturns',
    value: function setImplicitlyReturns() {
      get$1(SwitchCasePatcher.prototype.__proto__ || Object.getPrototypeOf(SwitchCasePatcher.prototype), 'setImplicitlyReturns', this).call(this);
      if (this.consequent !== null) {
        this.consequent.setImplicitlyReturns();
      }
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.patchAsStatement();
    }

    /**
     * Don't actually negate the conditions until just before patching, since
     * otherwise we might accidentally overwrite a ! character that gets inserted.
     */

  }, {
    key: 'negate',
    value: function negate() {
      this.negated = !this.negated;
    }

    /**
     * @private
     */

  }, {
    key: 'getWhenToken',
    value: function getWhenToken() {
      var whenToken = this.sourceTokenAtIndex(this.contentStartTokenIndex);
      if (!whenToken) {
        throw this.error('bad token index for start of \'when\'');
      }
      if (whenToken.type !== coffeeLex.WHEN) {
        throw this.error('unexpected ' + whenToken.type.name + ' at start of \'switch\' case');
      }
      return whenToken;
    }

    /**
     * @private
     */

  }, {
    key: 'getCommaTokens',
    value: function getCommaTokens() {
      var result = [];
      for (var i = 1; i < this.conditions.length; i++) {
        var left = this.conditions[i - 1];
        var right = this.conditions[i];
        var commaIndex = this.indexOfSourceTokenBetweenPatchersMatching(left, right, function (token) {
          return token.type === coffeeLex.COMMA;
        });
        if (!commaIndex) {
          throw this.error('unable to find comma between \'when\' conditions', left.contentEnd, right.contentStart);
        }
        result.push(this.sourceTokenAtIndex(commaIndex));
      }
      return result;
    }

    /**
     * @private
     */

  }, {
    key: 'getBreakToken',
    value: function getBreakToken() {
      var lastToken = this.sourceTokenAtIndex(this.contentEndTokenIndex);
      if (lastToken && lastToken.type === coffeeLex.BREAK) {
        return lastToken;
      } else {
        return null;
      }
    }

    /**
     * Gets the token representing the `then` between condition and consequent.
     *
     * @private
     */

  }, {
    key: 'getThenToken',
    value: function getThenToken() {
      var thenTokenIndex = this.indexOfSourceTokenBetweenSourceIndicesMatching(this.conditions[0].outerEnd, this.consequent !== null ? this.consequent.outerStart : this.contentEnd, function (token) {
        return token.type === coffeeLex.THEN;
      });
      return thenTokenIndex ? this.sourceTokenAtIndex(thenTokenIndex) : null;
    }
  }]);
  return SwitchCasePatcher;
}(NodePatcher);

var SwitchPatcher = function (_NodePatcher) {
  inherits(SwitchPatcher, _NodePatcher);

  function SwitchPatcher(node, context, editor, expression, cases, alternate) {
    classCallCheck(this, SwitchPatcher);

    var _this = possibleConstructorReturn(this, (SwitchPatcher.__proto__ || Object.getPrototypeOf(SwitchPatcher)).call(this, node, context, editor));

    _this.expression = expression;
    _this.cases = cases;
    _this.alternate = alternate;
    return _this;
  }

  createClass(SwitchPatcher, [{
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      if (this.expression) {
        // `switch a` → `switch (a`
        //                      ^
        if (!this.expression.isSurroundedByParentheses()) {
          this.insert(this.expression.contentStart, '(');
        }

        this.expression.patch();

        // `switch (a` → `switch (a)`
        //                         ^
        if (!this.expression.isSurroundedByParentheses()) {
          this.insert(this.expression.contentEnd, ')');
        }

        // `switch (a)` → `switch (a) {`
        //                            ^
        this.insert(this.expression.outerEnd, ' {');
      } else {
        this.cases.forEach(function (casePatcher) {
          return casePatcher.negate();
        });

        // `switch` → `switch (false) {`
        //                   ^^^^^^^^^^
        var switchToken = this.getSwitchToken();
        this.insert(switchToken.end, ' (false) {');
      }

      this.cases.forEach(function (casePatcher) {
        return casePatcher.patch();
      });

      this.overwriteElse();
      if (this.alternate) {
        this.alternate.patch({ leftBrace: false, rightBrace: false });
      }

      this.appendLineAfter('}');
    }
  }, {
    key: 'setImplicitlyReturns',
    value: function setImplicitlyReturns() {
      this.cases.forEach(function (casePatcher) {
        return casePatcher.setImplicitlyReturns();
      });
      if (this.alternate) {
        this.alternate.setImplicitlyReturns();
      }
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.setImplicitlyReturns();

      // `` → `(() => { `
      //       ^^^^^^^^^
      this.insert(this.contentStart, '(() => { ');
      this.patchAsStatement();

      // `` → ` })()`
      //       ^^^^^
      this.appendToEndOfLine(' })()');
    }

    /**
     * @private
     */

  }, {
    key: 'overwriteElse',
    value: function overwriteElse() {
      // `else` → `default:`
      //           ^^^^^^^^
      var elseToken = this.getElseToken();
      if (elseToken) {
        this.overwrite(elseToken.start, elseToken.end, 'default:');
      }
    }

    /**
     * @private
     */

  }, {
    key: 'getElseToken',
    value: function getElseToken() {
      if (!this.alternate) {
        return null;
      }

      var tokens$$1 = this.context.sourceTokens;
      var elseTokenIndex = tokens$$1.lastIndexOfTokenMatchingPredicate(function (token) {
        return token.type === coffeeLex.ELSE;
      }, this.alternate.contentStartTokenIndex);
      if (!elseTokenIndex || elseTokenIndex.isBefore(this.contentStartTokenIndex)) {
        throw this.alternate.error('no ELSE token found before \'switch\' alternate');
      }
      return this.sourceTokenAtIndex(elseTokenIndex);
    }

    /**
     * @private
     */

  }, {
    key: 'getSwitchToken',
    value: function getSwitchToken() {
      var switchToken = this.sourceTokenAtIndex(this.contentStartTokenIndex);
      if (!switchToken) {
        throw this.error('bad token index for start of \'switch\'');
      }
      if (switchToken.type !== coffeeLex.SWITCH) {
        throw this.error('unexpected ' + switchToken.type.name + ' token at start of \'switch\'');
      }
      return switchToken;
    }

    /**
     * Switch statements with all code paths present have a `default` case and
     * each case has all of its code paths covered.
     */

  }, {
    key: 'allCodePathsPresent',
    value: function allCodePathsPresent() {
      if (!this.alternate) {
        return false;
      }

      return this.cases.every(function (switchCase) {
        return switchCase.allCodePathsPresent();
      }) && this.alternate.allCodePathsPresent();
    }
  }]);
  return SwitchPatcher;
}(NodePatcher);

var ThrowPatcher = function (_NodePatcher) {
  inherits(ThrowPatcher, _NodePatcher);

  function ThrowPatcher(node, context, editor, expression) {
    classCallCheck(this, ThrowPatcher);

    var _this = possibleConstructorReturn(this, (ThrowPatcher.__proto__ || Object.getPrototypeOf(ThrowPatcher)).call(this, node, context, editor));

    _this.expression = expression;
    return _this;
  }

  /**
   * Throw in JavaScript is a statement only, so we'd prefer it stay that way.
   */


  createClass(ThrowPatcher, [{
    key: 'prefersToPatchAsExpression',
    value: function prefersToPatchAsExpression() {
      return false;
    }

    /**
     * Throw statements that are in the implicit return position should simply
     * be left alone as they're pure statements in JS and don't have a value.
     */

  }, {
    key: 'setImplicitlyReturns',
    value: function setImplicitlyReturns() {}
    // throw can't be an implicit return


    /**
     * `throw` statements cannot normally be used as expressions, so we wrap them
     * in an arrow function IIFE.
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var hasParens = this.isSurroundedByParentheses();
      if (!hasParens) {
        // `throw err` → `(throw err`
        //                ^
        this.insert(this.outerStart, '(');
      }
      // `(throw err` → `(() => { throw err`
      //                  ^^^^^^^^
      this.insert(this.innerStart, '() => { ');
      this.patchAsStatement();
      // `(() => { throw err` → `(() => { throw err }`
      //                                           ^^
      this.insert(this.innerEnd, ' }');
      if (!hasParens) {
        // `(() => { throw err }` → `(() => { throw err })`
        //                                               ^
        this.insert(this.outerEnd, ')');
      }
      // `(() => { throw err })` → `(() => { throw err })()`
      //                                                 ^^
      this.insert(this.outerEnd, '()');
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var throwToken = this.sourceTokenAtIndex(this.contentStartTokenIndex);
      if (throwToken.type !== coffeeLex.THROW) {
        this.error('Expected to find throw token at the start of throw statement.');
      }
      var spacing = this.slice(throwToken.end, this.expression.outerStart);
      if (spacing.indexOf('\n') !== -1) {
        this.overwrite(throwToken.end, this.expression.outerStart, ' ');
      }
      this.expression.patch();
    }

    /**
     * This is here so that we can add the `()` outside any existing parens.
     */

  }, {
    key: 'allowPatchingOuterBounds',
    value: function allowPatchingOuterBounds() {
      return true;
    }
  }]);
  return ThrowPatcher;
}(NodePatcher);

function nativeFind(array, iterator, context) {
  return array.find(iterator, context);
}

function find(array, iterator, context) {
  for (var _i = 0; _i < array.length; _i++) {
    var _element = array[_i];
    if (iterator.call(context, _element, _i, array)) {
      return _element;
    }
  }
  return undefined;
}

var find$1 = Array.prototype.find ? nativeFind : find;

/**
 * Maps a list to another list by combining lists.
 */
function flatMap(list, map) {
  return list.reduce(function (memo, item) {
    return memo.concat(map(item));
  }, []);
}

/**
 * Gets the identifiers for the given LHS value.
 *
 * @example
 *
 *   Given `a`, returns [`a`].
 *   Given `[a, b]`, returns [`a`, `b`].
 *   Given `{a, b: c}`, returns [`a`, `c`].
 *   Given `[a, {b, c: d}]`, returns [`a`, `b`, `d`].
 */
function leftHandIdentifiers(node) {
  if (node.type === 'Identifier') {
    return [node];
  } else if (node.type === 'ArrayInitialiser') {
    return flatMap(node.members, leftHandIdentifiers);
  } else if (node.type === 'ObjectInitialiser') {
    return flatMap(node.members, function (member) {
      return leftHandIdentifiers(member.expression);
    });
  } else {
    return [];
  }
}

/**
 * Represents a CoffeeScript scope and its bindings.
 */
var Scope = function () {
  function Scope() {
    var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    classCallCheck(this, Scope);

    this.parent = parent;
    this.bindings = Object.create(parent ? parent.bindings : null);
  }

  createClass(Scope, [{
    key: 'getBinding',
    value: function getBinding(name) {
      return this.bindings[this.key(name)] || null;
    }
  }, {
    key: 'hasBinding',
    value: function hasBinding(name) {
      return this.getBinding(name) !== null;
    }
  }, {
    key: 'getOwnNames',
    value: function getOwnNames() {
      var _this = this;

      return Object.getOwnPropertyNames(this.bindings).map(function (key) {
        return _this.unkey(key);
      });
    }
  }, {
    key: 'declares',
    value: function declares(name, node) {
      var key = this.key(name);
      this.bindings[key] = node;
    }
  }, {
    key: 'assigns',
    value: function assigns(name, node) {
      if (!this.bindings[this.key(name)]) {
        // Not defined in this or any parent scope.
        this.declares(name, node);
      }
    }
  }, {
    key: 'claimFreeBinding',
    value: function claimFreeBinding(node) {
      var _this2 = this;

      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (!name) {
        name = 'ref';
      }
      var names = Array.isArray(name) ? name : [name];
      var binding = find$1(names, function (name) {
        return !_this2.getBinding(name);
      });

      if (!binding) {
        (function () {
          var counter = 0;
          while (!binding) {
            counter += 1;
            binding = find$1(names, function (name) {
              return !_this2.getBinding('' + name + counter);
            });
          }
          binding = '' + binding + counter;
        })();
      }

      this.declares(binding, node);
      return binding;
    }

    /**
     * @private
     */

  }, {
    key: 'key',
    value: function key(name) {
      return '$' + name;
    }

    /**
     * @private
     */

  }, {
    key: 'unkey',
    value: function unkey(key) {
      return key.slice(1);
    }

    /**
     * Handles declarations or assigns for any bindings for a given node.
     */

  }, {
    key: 'processNode',
    value: function processNode(node) {
      var _this3 = this;

      switch (node.type) {
        case 'AssignOp':
          leftHandIdentifiers(node.assignee).forEach(function (identifier) {
            return _this3.assigns(identifier.data, identifier);
          });
          break;

        case 'Function':
        case 'BoundFunction':
        case 'GeneratorFunction':
          getBindingsForNode(node).forEach(function (identifier) {
            return _this3.declares(identifier.data, identifier);
          });
          break;

        case 'ForIn':
        case 'ForOf':
          [node.keyAssignee, node.valAssignee].forEach(function (assignee) {
            if (assignee) {
              leftHandIdentifiers(assignee).forEach(function (identifier) {
                return _this3.assigns(identifier.data, identifier);
              });
            }
          });
          break;
      }
    }
  }, {
    key: 'toString',
    value: function toString() {
      var parts = this.getOwnNames();
      if (this.parent) {
        parts.push('parent = ' + this.parent.toString());
      }
      return this.constructor.name + ' {' + (parts.length > 0 ? ' ' + parts.join(', ') + ' ' : '') + '}';
    }
  }, {
    key: 'inspect',
    value: function inspect() {
      return this.toString();
    }
  }]);
  return Scope;
}();

function getBindingsForNode(node) {
  switch (node.type) {
    case 'Function':
    case 'GeneratorFunction':
    case 'BoundFunction':
      return flatMap(node.parameters, getBindingsForNode);

    case 'Identifier':
    case 'ArrayInitialiser':
    case 'ObjectInitialiser':
      return leftHandIdentifiers(node);

    case 'DefaultParam':
      return getBindingsForNode(node.param);

    case 'Rest':
      return getBindingsForNode(node.expression);

    case 'Expansion':
    case 'MemberAccessOp':
      return [];

    default:
      throw new Error('unexpected parameter type: ' + node.type);
  }
}

/**
 * Parses a CoffeeScript program and attaches scope information to the nodes.
 */
function parse$2(source) {
  var ast = decaffeinateParser.parse(source);
  traverse(ast, attachScope);
  return ast;
}

function attachScope(node) {
  switch (node.type) {
    case 'Program':
      node.scope = new Scope();
      break;

    case 'Function':
    case 'BoundFunction':
    case 'GeneratorFunction':
      node.scope = new Scope(node.parentNode.scope);
      break;

    default:
      node.scope = node.parentNode.scope;
      break;
  }

  node.scope.processNode(node);
}

var TransformCoffeeScriptStage = function () {
  createClass(TransformCoffeeScriptStage, null, [{
    key: 'run',
    value: function run(content, filename) {
      var log = logger(this.name);
      log(content);

      var ast = parse$2(content);
      var editor = new MagicString(content);
      var stage = new this(ast, ast.context, editor);
      var patcher = stage.build();
      patcher.patch();
      return {
        code: editor.toString(),
        map: editor.generateMap({
          source: filename,
          file: path.basename(filename, this.inputExtension) + '-' + this.name + this.outputExtension,
          includeContent: true
        })
      };
    }
  }, {
    key: 'inputExtension',
    get: function get() {
      return '.coffee';
    }
  }, {
    key: 'outputExtension',
    get: function get() {
      return '.js';
    }
  }]);

  function TransformCoffeeScriptStage(ast, context, editor) {
    classCallCheck(this, TransformCoffeeScriptStage);

    this.ast = ast;
    this.context = context;
    this.editor = editor;
    this.root = null;
    this.patchers = [];
  }

  /**
   * This should be overridden in subclasses.
   */


  createClass(TransformCoffeeScriptStage, [{
    key: 'patcherConstructorForNode',
    value: function patcherConstructorForNode(node) {
      // eslint-disable-line no-unused-vars
      return null;
    }
  }, {
    key: 'build',
    value: function build() {
      this.root = this.patcherForNode(this.ast);
      this.patchers.forEach(function (patcher) {
        return patcher.initialize();
      });
      return this.root;
    }
  }, {
    key: 'patcherForNode',
    value: function patcherForNode(node) {
      var _this = this;

      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var property = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var constructor = this._patcherConstructorForNode(node);

      if (parent) {
        var override = parent.patcherClassForChildNode(node, property);
        if (override) {
          constructor = override;
        }
      }

      var children = childPropertyNames(node).map(function (name) {
        var child = node[name];
        if (!child) {
          return null;
        } else if (Array.isArray(child)) {
          return child.map(function (item) {
            return _this.patcherForNode(item, constructor, name);
          });
        } else {
          return _this.patcherForNode(child, constructor, name);
        }
      });

      var patcher = new (Function.prototype.bind.apply(constructor, [null].concat([node, this.context, this.editor], toConsumableArray(children))))();
      this.patchers.push(patcher);
      this.associateParent(patcher, children);

      return patcher;
    }
  }, {
    key: 'associateParent',
    value: function associateParent(parent, child) {
      var _this2 = this;

      if (Array.isArray(child)) {
        child.forEach(function (item) {
          return _this2.associateParent(parent, item);
        });
      } else if (child) {
        child.parent = parent;
      }
    }
  }, {
    key: '_patcherConstructorForNode',
    value: function _patcherConstructorForNode(node) {
      var constructor = this.patcherConstructorForNode(node);

      if (constructor === null) {
        var props = childPropertyNames(node);
        throw new (Function.prototype.bind.apply(PatchError, [null].concat(['no patcher available for node type: ' + node.type + ('' + (props.length ? ' (props: ' + props.join(', ') + ')' : '')), this.context.source], toConsumableArray(node.range))))();
      }

      return constructor.patcherClassOverrideForNode(node) || constructor;
    }
  }]);
  return TransformCoffeeScriptStage;
}();

/**
 * Handles `try` statements, e.g. `try a catch e then console.log(e)`.
 */

var TryPatcher = function (_NodePatcher) {
  inherits(TryPatcher, _NodePatcher);

  function TryPatcher(node, context, editor, body, catchAssignee, catchBody, finallyBody) {
    classCallCheck(this, TryPatcher);

    var _this = possibleConstructorReturn(this, (TryPatcher.__proto__ || Object.getPrototypeOf(TryPatcher)).call(this, node, context, editor));

    _this.body = body;
    _this.catchAssignee = catchAssignee;
    _this.catchBody = catchBody;
    _this.finallyBody = finallyBody;
    return _this;
  }

  createClass(TryPatcher, [{
    key: 'initialize',
    value: function initialize() {
      if (this.catchAssignee) {
        this.catchAssignee.setRequiresExpression();
      }
    }

    /**
     * 'try' BODY ( 'catch' ASSIGNEE? CATCH-BODY? )? ( 'finally' FINALLY-BODY )?
     */

  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var tryToken = this.getTryToken();
      var catchToken = this.getCatchToken();
      var thenTokenIndex = this.getThenTokenIndex();
      var finallyToken = this.getFinallyToken();

      // `try a` → `try { a`
      //               ^^
      this.insert(tryToken.end, ' {');
      if (this.body.inline()) {
        this.body.patch({ leftBrace: false });
      } else {
        if (catchToken || finallyToken) {
          this.body.patch({ leftBrace: false, rightBrace: false });
          // `try { a; catch err` → `try { a; } catch err`
          //                                  ^^
          this.insert((catchToken || finallyToken).start, '} ');
        } else {
          this.body.patch({ leftBrace: false });
        }
      }

      if (thenTokenIndex) {
        var thenToken = this.sourceTokenAtIndex(thenTokenIndex);
        var nextToken = this.sourceTokenAtIndex(thenTokenIndex.next());
        // `try { a; } catch err then b` → `try { a; } catch err b`
        //                       ^^^^^
        this.remove(thenToken.start, nextToken.start);
      }

      if (catchToken) {
        var afterCatchHeader = this.catchAssignee ? this.catchAssignee.outerEnd : catchToken.end;

        if (this.catchAssignee) {
          var addErrorParens = !this.catchAssignee.isSurroundedByParentheses();
          if (addErrorParens) {
            // `try { a; } catch err` → `try { a; } catch (err`
            //                                            ^
            this.insert(this.catchAssignee.outerStart, '(');
          }
          this.catchAssignee.patch();
          if (addErrorParens) {
            // `try { a; } catch (err` → `try { a; } catch (err)`
            //                                                 ^
            this.insert(this.catchAssignee.outerEnd, ')');
          }
        } else {
          // `try { a; } catch` → `try { a; } catch (error)`
          //                                       ^^^^^^^^
          this.insert(afterCatchHeader, ' (' + this.getErrorBinding() + ')');
        }

        if (this.catchBody) {
          // `try { a; } catch (error)` → `try { a; } catch (error) {`
          //                                                       ^^
          this.insert(afterCatchHeader, ' {');
          this.catchBody.patch({ leftBrace: false });
        } else {
          this.insert(afterCatchHeader, ' {}');
        }
      } else if (!finallyToken) {
        // `try { a; }` → `try { a; } catch (error) {}`
        //                           ^^^^^^^^^^^^^^^^^
        this.insert(this.body.innerEnd, ' catch (' + this.getErrorBinding() + ') {}');
      }

      if (finallyToken) {
        if (!this.finallyBody) {
          this.insert(finallyToken.end, ' {}');
        } else if (this.finallyBody.inline()) {
          this.finallyBody.patch();
        } else {
          // `try { a; } finally b` → `try { a; } finally { b`
          //                                             ^^
          this.insert(finallyToken.end, ' {');
          this.finallyBody.patch({ leftBrace: false });
        }
      }
    }
  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      // Make our children return since we're wrapping in a function.
      this.setImplicitlyReturns();

      var needsParens = !this.isSurroundedByParentheses();
      if (needsParens) {
        // `a = try b()` → `a = (try b()`
        //                      ^
        this.insert(this.outerStart, '(');
      }
      // `a = (try b()` → `a = (() => { try b()`
      //                        ^^^^^^^^
      this.insert(this.outerStart, '() => { ');
      this.patchAsStatement();
      // `a = (() => { try { b(); } catch (error) {}` → `a = (() => { try { b(); } catch (error) {} }`
      //                                                                                           ^^
      this.insert(this.outerEnd, ' }');
      if (needsParens) {
        // `a = (() => { try { b(); } catch (error) {} }` → `a = (() => { try { b(); } catch (error) {} })`
        //                                                                                               ^
        this.insert(this.outerEnd, ')');
      }
      // `a = (() => { try { b(); } catch (error) {} })` → `a = (() => { try { b(); } catch (error) {} })()`
      //                                                                                                 ^^
      this.insert(this.outerEnd, '()');
    }
  }, {
    key: 'setImplicitlyReturns',
    value: function setImplicitlyReturns() {
      this.body.setImplicitlyReturns();
      if (this.catchBody) {
        this.catchBody.setImplicitlyReturns();
      }
    }
  }, {
    key: 'statementNeedsSemicolon',
    value: function statementNeedsSemicolon() {
      return false;
    }

    /**
     * @private
     */

  }, {
    key: 'getTryToken',
    value: function getTryToken() {
      var tryTokenIndex = this.contentStartTokenIndex;
      var tryToken = this.sourceTokenAtIndex(tryTokenIndex);
      if (!tryToken || tryToken.type !== coffeeLex.TRY) {
        throw this.error('expected \'try\' keyword at start of \'try\' statement');
      }
      return tryToken;
    }

    /**
     * @private
     */

  }, {
    key: 'getCatchToken',
    value: function getCatchToken() {
      var searchEnd = void 0;
      if (this.catchAssignee) {
        searchEnd = this.catchAssignee.outerStart;
      } else if (this.catchBody) {
        searchEnd = this.catchBody.outerStart;
      } else if (this.finallyBody) {
        searchEnd = this.finallyBody.outerStart;
      } else {
        searchEnd = this.contentEnd;
      }

      var catchTokenIndex = this.indexOfSourceTokenBetweenSourceIndicesMatching(this.body.outerEnd, searchEnd, function (token) {
        return token.type === coffeeLex.CATCH;
      });
      if (!catchTokenIndex) {
        return null;
      }
      return this.sourceTokenAtIndex(catchTokenIndex);
    }

    /**
     * @private
     */

  }, {
    key: 'getThenTokenIndex',
    value: function getThenTokenIndex() {
      if (!this.catchAssignee && !this.catchBody) {
        return null;
      }
      return this.indexOfSourceTokenBetweenPatchersMatching(this.catchAssignee || this.body, this.catchBody, function (token) {
        return token.type === coffeeLex.THEN;
      });
    }

    /**
     * @private
     */

  }, {
    key: 'getFinallyToken',
    value: function getFinallyToken() {
      var searchStart = void 0;
      if (this.catchBody) {
        searchStart = this.catchBody.outerEnd;
      } else if (this.catchAssignee) {
        searchStart = this.catchAssignee.outerEnd;
      } else {
        searchStart = this.body.outerEnd;
      }

      var searchEnd = void 0;
      if (this.finallyBody) {
        searchEnd = this.finallyBody.outerStart;
      } else {
        searchEnd = this.contentEnd;
      }

      var finallyTokenIndex = this.indexOfSourceTokenBetweenSourceIndicesMatching(searchStart, searchEnd, function (token) {
        return token.type === coffeeLex.FINALLY;
      });
      if (!finallyTokenIndex) {
        return null;
      }
      return this.sourceTokenAtIndex(finallyTokenIndex);
    }

    /**
     * @private
     */

  }, {
    key: 'getErrorBinding',
    value: function getErrorBinding() {
      if (!this._errorBinding) {
        this._errorBinding = this.claimFreeBinding('error');
      }
      return this._errorBinding;
    }
  }]);
  return TryPatcher;
}(NodePatcher);

/**
 * Handles unary exists, e.g. `a?`.
 */

var UnaryExistsOpPatcher = function (_UnaryOpPatcher) {
  inherits(UnaryExistsOpPatcher, _UnaryOpPatcher);

  function UnaryExistsOpPatcher() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, UnaryExistsOpPatcher);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = UnaryExistsOpPatcher.__proto__ || Object.getPrototypeOf(UnaryExistsOpPatcher)).call.apply(_ref, [this].concat(args))), _this), _this.negated = false, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(UnaryExistsOpPatcher, [{
    key: 'patchAsExpression',


    /**
     * The expression version of this sometimes needs parentheses, but we don't
     * yet have a good mechanism for determining when that is, so we just make
     * sure they're always there. For example, this doesn't need parentheses:
     *
     *   set = a?
     *
     * Because it becomes this:
     *
     *   var set = typeof a !== 'undefined' && a !== null;
     *
     * But this does:
     *
     *   'set? ' + a?
     *
     * Because this:
     *
     *   'set? ' + a != null;
     *
     * Is equivalent to this:
     *
     *   ('set? + a) != null;
     *
     * Which has a different meaning than this:
     *
     *   'set? ' + (a != null);
     */
    value: function patchAsExpression() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _ref2$needsParens = _ref2.needsParens;
      var needsParens = _ref2$needsParens === undefined ? true : _ref2$needsParens;

      var addParens = needsParens && !this.isSurroundedByParentheses();
      if (addParens) {
        // `a?` → `(a?`
        //         ^
        this.insert(this.contentStart, '(');
      }
      this.patchAsStatement();
      if (addParens) {
        // `(a?` → `(a?)`
        //             ^
        this.insert(this.contentEnd, ')');
      }
    }

    /**
     * EXPRESSION '?'
     */

  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      var expression = this.node.expression;
      var negated = this.negated;

      var needsTypeofCheck = this.needsTypeofCheck();

      this.expression.patch();
      if (needsTypeofCheck) {
        if (negated) {
          // `a?` → `typeof a === 'undefined' && a === null`
          //  ^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          this.overwrite(this.contentStart, this.contentEnd, 'typeof ' + expression.raw + ' === \'undefined\' || ' + expression.raw + ' === null');
        } else {
          // `a?` → `typeof a !== 'undefined' && a !== null`
          //  ^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          this.overwrite(this.contentStart, this.contentEnd, 'typeof ' + expression.raw + ' !== \'undefined\' && ' + expression.raw + ' !== null');
        }
      } else {
        if (negated) {
          // `a.b?` → `a.b == null`
          //     ^        ^^^^^^^^
          this.overwrite(this.expression.outerEnd, this.contentEnd, ' == null');
        } else {
          // `a.b?` → `a.b != null`
          //     ^        ^^^^^^^^
          this.overwrite(this.expression.outerEnd, this.contentEnd, ' != null');
        }
      }
    }

    /**
     * Since we turn into an equality check, we can simply invert the operator
     * to handle negation internally rather than by prefixing with `!`.
     */

  }, {
    key: 'canHandleNegationInternally',
    value: function canHandleNegationInternally() {
      return true;
    }

    /**
     * Flips negated flag but doesn't edit anything immediately so that we can
     * use the correct operator in `patch`.
     */

  }, {
    key: 'negate',
    value: function negate() {
      this.negated = !this.negated;
    }

    /**
     * @private
     */

  }, {
    key: 'needsTypeofCheck',
    value: function needsTypeofCheck() {
      var node = this.node;
      var expression = node.expression;

      return expression && expression.type === 'Identifier' && !node.scope.hasBinding(expression.data);
    }

    /**
     * When we prefix with a `typeof` check we don't need parens, otherwise
     * delegate.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      if (this.needsTypeofCheck()) {
        return false;
      } else {
        return this.expression.statementShouldAddParens();
      }
    }
  }]);
  return UnaryExistsOpPatcher;
}(UnaryOpPatcher);

/**
 * Handles unary math operators, e.g. `+a`, `-a`, `~a`.
 */

var UnaryMathOpPatcher = function (_UnaryOpPatcher) {
  inherits(UnaryMathOpPatcher, _UnaryOpPatcher);

  function UnaryMathOpPatcher() {
    classCallCheck(this, UnaryMathOpPatcher);
    return possibleConstructorReturn(this, (UnaryMathOpPatcher.__proto__ || Object.getPrototypeOf(UnaryMathOpPatcher)).apply(this, arguments));
  }

  createClass(UnaryMathOpPatcher, [{
    key: 'isRepeatable',

    /**
     * Math does not (usually) have side effects, as far as CoffeeScript is
     * concerned. It could trigger a `valueOf` call that could trigger arbitrary
     * code, but we ignore that possibility.
     */
    value: function isRepeatable() {
      return this.expression.isRepeatable();
    }
  }]);
  return UnaryMathOpPatcher;
}(UnaryOpPatcher);

/**
 * Handles `typeof`, e.g. `typeof name`.
 */

var UnaryTypeofOpPatcher = function (_UnaryOpPatcher) {
  inherits(UnaryTypeofOpPatcher, _UnaryOpPatcher);

  function UnaryTypeofOpPatcher() {
    classCallCheck(this, UnaryTypeofOpPatcher);
    return possibleConstructorReturn(this, (UnaryTypeofOpPatcher.__proto__ || Object.getPrototypeOf(UnaryTypeofOpPatcher)).apply(this, arguments));
  }

  createClass(UnaryTypeofOpPatcher, [{
    key: 'isRepeatable',

    /**
     * `typeof` does not have side-effects.
     */
    value: function isRepeatable() {
      return this.expression.isRepeatable();
    }

    /**
     * This always starts with `typeof` and doesn't need parens.
     */

  }, {
    key: 'statementNeedsParens',
    value: function statementNeedsParens() {
      return false;
    }
  }]);
  return UnaryTypeofOpPatcher;
}(UnaryOpPatcher);

/**
 * Handles `while` loops, e.g.
 *
 *   while a
 *     b
 */

var WhilePatcher = function (_LoopPatcher) {
  inherits(WhilePatcher, _LoopPatcher);

  function WhilePatcher(node, context, editor, condition, guard, body) {
    classCallCheck(this, WhilePatcher);

    var _this = possibleConstructorReturn(this, (WhilePatcher.__proto__ || Object.getPrototypeOf(WhilePatcher)).call(this, node, context, editor, body));

    _this.condition = condition;
    _this.guard = guard;
    return _this;
  }

  /**
   * ( 'while' | 'until' ) CONDITION ('when' GUARD)? 'then' BODY
   * ( 'while' | 'until' ) CONDITION ('when' GUARD)? NEWLINE INDENT BODY
   * 'loop' 'then' BODY
   * 'loop' NEWLINE INDENT BODY
   */


  createClass(WhilePatcher, [{
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      if (!this.body.inline()) {
        this.body.setIndent(this.getLoopBodyIndent());
      }

      // `until a` → `while a`
      //  ^^^^^       ^^^^^
      var whileToken = this.sourceTokenAtIndex(this.getWhileTokenIndex());
      var isLoop = whileToken.type === coffeeLex.LOOP;

      if (isLoop) {
        this.overwrite(whileToken.start, whileToken.end, 'while (true) {');
      } else {
        this.overwrite(whileToken.start, whileToken.end, 'while');

        var conditionNeedsParens = !this.condition.isSurroundedByParentheses();
        if (conditionNeedsParens) {
          // `while a` → `while (a`
          //                    ^
          this.insert(this.condition.outerStart, '(');
        }

        if (this.node.isUntil) {
          this.condition.negate();
        }
        this.condition.patch();

        if (this.guard) {
          var guardNeedsParens = !this.guard.isSurroundedByParentheses();
          if (this.body.inline()) {
            // `while (a when b` → `while (a) { if (b`
            //          ^^^^^^              ^^^^^^^^
            this.overwrite(this.condition.outerEnd, this.guard.outerStart, (conditionNeedsParens ? ')' : '') + ' { if ' + (guardNeedsParens ? '(' : ''));
          } else {
            // `while (a when b` → `while (a) {\n  if (b`
            //          ^^^^^^              ^^^^^^^^^^^
            this.overwrite(this.condition.outerEnd, this.guard.outerStart, (conditionNeedsParens ? ')' : '') + ' {\n' + this.getOuterLoopBodyIndent() + 'if ' + (guardNeedsParens ? '(' : ''));
          }
          this.guard.patch();

          // `while (a) {\n  if (b` → `while (a) {\n  if (b) {`
          //                                               ^^^
          this.insert(this.guard.outerEnd, (guardNeedsParens ? ')' : '') + ' {');
        } else {
          // `while (a` → `while (a) {`
          //                       ^^^
          this.insert(this.condition.outerEnd, (conditionNeedsParens ? ')' : '') + ' {');
        }
      }

      var thenIndex = this.getThenTokenIndex();
      if (thenIndex) {
        var thenToken = this.sourceTokenAtIndex(thenIndex);
        var nextToken = this.sourceTokenAtIndex(thenIndex.next());
        this.remove(thenToken.start, nextToken.start);
      }

      this.patchPossibleNewlineAfterLoopHeader(this.guard ? this.guard.outerEnd : this.condition.outerEnd);
      this.patchBodyWithPossibleItemVariable();

      if (this.guard) {
        // Close the guard's `if` consequent block.
        this.body.insertLineAfter('}', this.getOuterLoopBodyIndent());
      }

      // Close the `while` body block.
      this.body.insertLineAfter('}', this.getLoopIndent());
    }

    /**
     * @private
     */

  }, {
    key: 'getWhileTokenIndex',
    value: function getWhileTokenIndex() {
      var whileTokenIndex = this.contentStartTokenIndex;
      var whileToken = this.sourceTokenAtIndex(whileTokenIndex);
      if (!whileToken) {
        throw this.error('could not get first token of \'while\' loop');
      }
      switch (whileToken.type) {
        case coffeeLex.LOOP:
        case coffeeLex.WHILE:
          return whileTokenIndex;

        default:
          throw this.error('expected \'while\' token to be type WHILE or LOOP, got ' + whileToken.type.name);
      }
    }

    /**
     * @private
     */

  }, {
    key: 'getThenTokenIndex',
    value: function getThenTokenIndex() {
      var whileTokenIndex = this.getWhileTokenIndex();
      if (!whileTokenIndex) {
        throw this.error('could not get first token of \'while\' loop');
      }

      var whileToken = this.sourceTokenAtIndex(whileTokenIndex);
      if (whileToken.type === coffeeLex.LOOP) {
        // `loop then …`
        var nextTokenIndex = whileTokenIndex.next();
        var nextToken = this.sourceTokenAtIndex(nextTokenIndex);
        if (!nextToken) {
          throw this.error('expected another token after \'loop\' but none was found');
        }
        return nextToken.type === coffeeLex.THEN ? nextTokenIndex : null;
      } else {
        // `while a then …`
        return this.indexOfSourceTokenBetweenPatchersMatching(this.guard || this.condition, this.body, function (token) {
          return token.type === coffeeLex.THEN;
        });
      }
    }
  }, {
    key: 'getLoopBodyIndent',
    value: function getLoopBodyIndent() {
      if (this.guard) {
        return this.getOuterLoopBodyIndent() + this.getProgramIndentString();
      } else {
        return this.getOuterLoopBodyIndent();
      }
    }
  }]);
  return WhilePatcher;
}(LoopPatcher);

var YieldPatcher = function (_NodePatcher) {
  inherits(YieldPatcher, _NodePatcher);

  function YieldPatcher(node, context, editor, expression) {
    classCallCheck(this, YieldPatcher);

    var _this = possibleConstructorReturn(this, (YieldPatcher.__proto__ || Object.getPrototypeOf(YieldPatcher)).call(this, node, context, editor));

    _this.expression = expression;
    return _this;
  }

  createClass(YieldPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.yields();
      this.expression.setRequiresExpression();
    }

    /**
     * 'yield' EXPRESSION
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _ref$needsParens = _ref.needsParens;
      var needsParens = _ref$needsParens === undefined ? true : _ref$needsParens;

      this.expression.patch({ needsParens: needsParens });
    }
  }]);
  return YieldPatcher;
}(NodePatcher);

var YieldFromPatcher = function (_NodePatcher) {
  inherits(YieldFromPatcher, _NodePatcher);

  function YieldFromPatcher(node, context, editor, expression) {
    classCallCheck(this, YieldFromPatcher);

    var _this = possibleConstructorReturn(this, (YieldFromPatcher.__proto__ || Object.getPrototypeOf(YieldFromPatcher)).call(this, node, context, editor));

    _this.expression = expression;
    return _this;
  }

  createClass(YieldFromPatcher, [{
    key: 'initialize',
    value: function initialize() {
      this.yields();
      this.expression.setRequiresExpression();
    }

    /**
     * 'yield' 'from' EXPRESSION
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _ref$needsParens = _ref.needsParens;
      var needsParens = _ref$needsParens === undefined ? true : _ref$needsParens;

      var src = this.sourceTokenAtIndex(this.contentStartTokenIndex);
      this.overwrite(src.start, src.end, 'yield*');

      this.expression.patch({ needsParens: needsParens });
    }
  }]);
  return YieldFromPatcher;
}(NodePatcher);

var MainStage = function (_TransformCoffeeScrip) {
  inherits(MainStage, _TransformCoffeeScrip);

  function MainStage() {
    classCallCheck(this, MainStage);
    return possibleConstructorReturn(this, (MainStage.__proto__ || Object.getPrototypeOf(MainStage)).apply(this, arguments));
  }

  createClass(MainStage, [{
    key: 'patcherConstructorForNode',
    value: function patcherConstructorForNode(node) {
      switch (node.type) {
        case 'Identifier':
          return IdentifierPatcher;

        case 'String':
          return StringPatcher;
        case 'Int':
        case 'Float':
        case 'Null':
        case 'Undefined':
        case 'PostIncrementOp':
        case 'PostDecrementOp':
        case 'PreIncrementOp':
        case 'PreDecrementOp':
        case 'Quasi':
          return PassthroughPatcher;

        case 'FunctionApplication':
          return FunctionApplicationPatcher;

        case 'SoakedFunctionApplication':
          return SoakedFunctionApplicationPatcher;

        case 'MemberAccessOp':
          return MemberAccessOpPatcher;

        case 'DynamicMemberAccessOp':
          return DynamicMemberAccessOpPatcher;

        case 'EQOp':
        case 'NEQOp':
        case 'LTOp':
        case 'GTOp':
        case 'LTEOp':
        case 'GTEOp':
          return EqualityPatcher;

        case 'ObjectInitialiserMember':
          return ObjectInitialiserMemberPatcher;

        case 'ObjectInitialiser':
          return ObjectInitialiserPatcher;

        case 'This':
          return ThisPatcher;

        case 'Yield':
          return YieldPatcher;

        case 'YieldFrom':
          return YieldFromPatcher;

        case 'GeneratorFunction':
          return GeneratorFunctionPatcher;

        case 'Function':
          return FunctionPatcher;

        case 'BoundFunction':
          return BoundFunctionPatcher;

        case 'BoundGeneratorFunction':
          return BoundGeneratorFunctionPatcher;

        case 'Bool':
          return BoolPatcher;

        case 'Conditional':
          return ConditionalPatcher;

        case 'ArrayInitialiser':
          return ArrayInitialiserPatcher;

        case 'Block':
          return BlockPatcher;

        case 'AssignOp':
          return AssignOpPatcher;

        case 'DefaultParam':
          return DefaultParamPatcher;

        case 'CompoundAssignOp':
          switch (node.op) {
            case 'LogicalAndOp':
            case 'LogicalOrOp':
              return LogicalOpCompoundAssignOpPatcher;

            case 'ExistsOp':
              return ExistsOpCompoundAssignOpPatcher;

            default:
              return CompoundAssignOpPatcher;
          }

        case 'Return':
          return ReturnPatcher;

        case 'PlusOp':
        case 'SubtractOp':
        case 'DivideOp':
        case 'MultiplyOp':
        case 'RemOp':
        case 'BitAndOp':
        case 'BitOrOp':
        case 'BitXorOp':
        case 'LeftShiftOp':
        case 'SignedRightShiftOp':
        case 'UnsignedRightShiftOp':
          return BinaryOpPatcher;

        case 'ModuloOp':
          return ModuloOpPatcher;

        case 'RegExp':
          return RegExpPatcher;

        case 'Heregex':
          return HeregexPatcher;

        case 'ExistsOp':
          return ExistsOpPatcher;

        case 'LogicalAndOp':
        case 'LogicalOrOp':
          return LogicalOpPatcher;

        case 'LogicalNotOp':
          return LogicalNotOpPatcher;

        case 'SoakedMemberAccessOp':
          return SoakedMemberAccessOpPatcher;

        case 'SoakedDynamicMemberAccessOp':
          return SoakedDynamicMemberAccessOpPatcher;

        case 'ForIn':
          return ForInPatcher;

        case 'ForOf':
          return ForOfPatcher;

        case 'While':
          return WhilePatcher;

        case 'NewOp':
          return NewOpPatcher;

        case 'InOp':
          return InOpPatcher;

        case 'Slice':
          return SlicePatcher;

        case 'Expansion':
          return ExpansionPatcher;

        case 'Rest':
          return RestPatcher;

        case 'Spread':
          return SpreadPatcher;

        case 'Range':
          return RangePatcher;

        case 'Throw':
          return ThrowPatcher;

        case 'UnaryPlusOp':
        case 'UnaryNegateOp':
        case 'BitNotOp':
          return UnaryMathOpPatcher;

        case 'TypeofOp':
          return UnaryTypeofOpPatcher;

        case 'DeleteOp':
          return UnaryOpPatcher;

        case 'UnaryExistsOp':
          return UnaryExistsOpPatcher;

        case 'ClassProtoAssignOp':
          return ClassAssignOpPatcher;

        case 'Super':
          return SuperPatcher;

        case 'Class':
          return ClassPatcher;

        case 'Constructor':
          return ConstructorPatcher;

        case 'Try':
          return TryPatcher;

        case 'Switch':
          return SwitchPatcher;

        case 'SwitchCase':
          return SwitchCasePatcher;

        case 'DoOp':
          return DoOpPatcher;

        case 'ProtoMemberAccessOp':
          return ProtoMemberAccessOpPatcher;

        case 'Program':
          return ProgramPatcher;

        case 'InstanceofOp':
          return InstanceofOpPatcher;

        case 'OfOp':
          return OfOpPatcher;

        case 'ChainedComparisonOp':
          return ChainedComparisonOpPatcher;

        case 'SeqOp':
          return SeqOpPatcher;

        case 'JavaScript':
          return JavaScriptPatcher;

        case 'FloorDivideOp':
          return FloorDivideOpPatcher;

        case 'ExpOp':
          return ExpOpPatcher;

        case 'ExtendsOp':
          return ExtendsOpPatcher;

        default:
          return null;
      }
    }
  }]);
  return MainStage;
}(TransformCoffeeScriptStage);

var ArrayInitialiserPatcher$2 = function (_NodePatcher) {
  inherits(ArrayInitialiserPatcher, _NodePatcher);

  function ArrayInitialiserPatcher(node, context, editor, members) {
    classCallCheck(this, ArrayInitialiserPatcher);

    var _this = possibleConstructorReturn(this, (ArrayInitialiserPatcher.__proto__ || Object.getPrototypeOf(ArrayInitialiserPatcher)).call(this, node, context, editor));

    _this.members = members;
    return _this;
  }

  createClass(ArrayInitialiserPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.members[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var member = _step.value;

          // If the last token of the arg is a comma, then the actual delimiter must
          // be a newline and the comma is unnecessary and can cause a syntax error
          // when combined with other normalize stage transformations. So just
          // remove the redundant comma.
          var lastToken = member.lastToken();
          if (lastToken.type === coffeeLex.COMMA) {
            this.remove(lastToken.start, lastToken.end);
          }
          member.patch();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return ArrayInitialiserPatcher;
}(NodePatcher);

var BlockPatcher$2 = function (_NodePatcher) {
  inherits(BlockPatcher, _NodePatcher);

  function BlockPatcher(node, context, editor, statements) {
    classCallCheck(this, BlockPatcher);

    var _this = possibleConstructorReturn(this, (BlockPatcher.__proto__ || Object.getPrototypeOf(BlockPatcher)).call(this, node, context, editor));

    _this.statements = statements;
    return _this;
  }

  createClass(BlockPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.patchAsStatement();
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      if (this.node.inline) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.statements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var statement = _step.value;

            statement.patch();
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return;
      }

      // Having inconsistent indentation within a block is allowed in some cases
      // when there are implicit function calls, but when function call parens are
      // added, the inconsistent indentation can make the CoffeeScript invalid. So
      // we need to correct any inconsistent indentation in the normalize step so
      // that the result CoffeeScript will always be valid.
      var blockIndentLength = null;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.statements[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _statement = _step2.value;

          var indentLength = this.getIndentLength(_statement);
          if (indentLength !== null) {
            if (blockIndentLength === null) {
              blockIndentLength = indentLength;
            } else {
              var charsToRemove = indentLength - blockIndentLength;
              if (charsToRemove < 0) {
                throw this.error('Unexpected statement at an earlier indentation level than an ' + 'earlier statement in the block.');
              }
              if (charsToRemove > 0) {
                this.remove(_statement.outerStart - charsToRemove, _statement.outerStart);
              }
            }
          }
          _statement.patch();
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    /**
     * If this statement starts immediately after its line's initial indentation,
     * return the length of that indentation. Otherwise, return null.
     */

  }, {
    key: 'getIndentLength',
    value: function getIndentLength(statement) {
      var startOfLine = getStartOfLine(this.context.source, statement.outerStart);
      var indentText = this.context.source.slice(startOfLine, statement.outerStart);
      if (/^[ \t]*$/.test(indentText)) {
        return indentText.length;
      } else {
        return null;
      }
    }
  }]);
  return BlockPatcher;
}(NodePatcher);

var AssignOpPatcher$2 = function (_PassthroughPatcher) {
  inherits(AssignOpPatcher, _PassthroughPatcher);

  function AssignOpPatcher(node, context, editor, key, expression) {
    classCallCheck(this, AssignOpPatcher);

    var _this = possibleConstructorReturn(this, (AssignOpPatcher.__proto__ || Object.getPrototypeOf(AssignOpPatcher)).call(this, node, context, editor, key, expression));

    _this.key = key;
    _this.expression = expression;
    return _this;
  }

  return AssignOpPatcher;
}(PassthroughPatcher);

var ClassPatcher$2 = function (_NodePatcher) {
  inherits(ClassPatcher, _NodePatcher);

  function ClassPatcher(node, context, editor, nameAssignee, parent, body) {
    classCallCheck(this, ClassPatcher);

    var _this = possibleConstructorReturn(this, (ClassPatcher.__proto__ || Object.getPrototypeOf(ClassPatcher)).call(this, node, context, editor));

    _this.nameAssignee = nameAssignee;
    _this.superclass = parent;
    _this.body = body;
    return _this;
  }

  /**
   * Handle code within class bodies by restructuring the class to use a static
   * method instead.
   *
   * Current limitations:
   * - Doesn't handle anonymous classes.
   * - Doesn't handle classes used in an expression context.
   * - Doesn't deconflict the "initClass" name of the static method.
   * - Doesn't deconflict the variable assignments that are moved outside the
   *   class body.
   * - Technically this changes the execution order of the class body, although
   *   it does so in a way that is unlikely to cause problems in reasonable
   *   code.
   */


  createClass(ClassPatcher, [{
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      if (this.nameAssignee) {
        this.nameAssignee.patch();
      }
      if (this.superclass) {
        this.superclass.patch();
      }
      if (this.body) {
        this.body.patch();
      }

      if (!this.body) {
        return;
      }

      if (this.body.statements.length === 0) {
        return;
      }

      var insertPoint = this.getInitClassInsertPoint();
      var nonMethodPatchers = this.getNonMethodPatchers(insertPoint);

      if (nonMethodPatchers.length > 0) {
        var assignmentNames = this.generateInitClassMethod(nonMethodPatchers, insertPoint);
        var indent = this.getIndent();
        this.insert(this.outerEnd, '\n' + indent + this.nameAssignee.node.data + '.initClass()');
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = assignmentNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var assignmentName = _step.value;

            this.insert(this.outerStart, assignmentName + ' = undefined\n' + indent);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }

    /**
     * For now, code in class bodies is only supported for statement classes.
     */

  }, {
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.body.patch();
    }
  }, {
    key: 'getInitClassInsertPoint',
    value: function getInitClassInsertPoint() {
      if (this.superclass) {
        return this.superclass.outerEnd;
      }
      if (this.nameAssignee) {
        return this.nameAssignee.outerEnd;
      }
      if (this.body) {
        return this.body.outerStart;
      }
      return this.outerStart;
    }

    /**
     * Find the statements in the class body that can't be converted to JS
     * methods. These will later be moved to the top of the class in a static
     * method.
     */

  }, {
    key: 'getNonMethodPatchers',
    value: function getNonMethodPatchers(initialDeleteStart) {
      var nonMethodPatchers = [];
      var deleteStart = initialDeleteStart;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.body.statements[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var patcher = _step2.value;

          if (!this.isClassMethod(patcher)) {
            nonMethodPatchers.push({
              patcher: patcher,
              deleteStart: deleteStart
            });
          }
          deleteStart = patcher.outerEnd;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return nonMethodPatchers;
    }
  }, {
    key: 'isClassMethod',
    value: function isClassMethod(patcher) {
      if (patcher.node.type === 'Constructor') {
        return true;
      }
      if (this.isClassAssignment(patcher.node)) {
        if (patcher.node.expression.type === 'Function' || patcher.node.expression.type === 'BoundFunction' || patcher.node.expression.type === 'GeneratorFunction' || patcher.node.expression.type === 'BoundGeneratorFunction') {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'isClassAssignment',
    value: function isClassAssignment(node) {
      if (node.type === 'ClassProtoAssignOp') {
        return true;
      }
      if (node.type === 'AssignOp') {
        var assignee = node.assignee;

        if (assignee.type === 'MemberAccessOp') {
          if (assignee.expression.type === 'This') {
            return true;
          }
          if (this.nameAssignee) {
            var className = this.nameAssignee.node.data;
            if (assignee.expression.type === 'Identifier' && assignee.expression.data === className) {
              return true;
            }
          }
        }
      }
      return false;
    }

    /**
     * Create the initClass static method by moving nodes from the class body into
     * the static method and indenting them one level.
     *
     * Also return an array of variables that were assigned so that later code can
     * declare them outside the class body to make them accessible within the
     * class.
     */

  }, {
    key: 'generateInitClassMethod',
    value: function generateInitClassMethod(nonMethodPatchers, insertPoint) {
      var bodyIndent = this.body.getIndent();
      var indentString = this.getProgramIndentString();
      this.insert(insertPoint, '\n' + bodyIndent + '@initClass: ->');
      var assignmentNames = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = nonMethodPatchers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _step3$value = _step3.value;
          var patcher = _step3$value.patcher;
          var deleteStart = _step3$value.deleteStart;

          var assignmentName = this.getAssignmentName(patcher);
          if (assignmentName) {
            assignmentNames.push(assignmentName);
          }
          var statementCode = this.getNonMethodStatementCode(patcher, deleteStart);
          statementCode = statementCode.replace(/\n/g, '\n' + indentString);
          this.insert(insertPoint, statementCode);
          this.remove(deleteStart, patcher.outerEnd);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this.insert(insertPoint, '\n' + bodyIndent + indentString + 'return');
      return assignmentNames;
    }

    /**
     * Determine the variable assigned in the given statement, if any, since any
     * assigned variables need to be declared externally so they are available
     * within the class body. Note that this is incomplete at the moment and only
     * covers the common case of a single variable being defined.
     */

  }, {
    key: 'getAssignmentName',
    value: function getAssignmentName(statementPatcher) {
      if (statementPatcher.node.type === 'AssignOp' && statementPatcher.node.assignee.type === 'Identifier') {
        return statementPatcher.node.assignee.data;
      }
      if (statementPatcher instanceof ClassPatcher) {
        return statementPatcher.nameAssignee.node.data;
      }
      return null;
    }
  }, {
    key: 'getNonMethodStatementCode',
    value: function getNonMethodStatementCode(statementPatcher, deleteStart) {
      if (statementPatcher instanceof AssignOpPatcher$2 && this.isClassAssignment(statementPatcher.node)) {
        var key = statementPatcher.key;
        var expression = statementPatcher.expression;

        var prefixCode = this.slice(deleteStart, key.outerStart);
        var keyCode = this.slice(key.outerStart, key.outerEnd);
        var suffixCode = this.slice(key.outerEnd, expression.outerEnd);

        var equalIndex = suffixCode.indexOf('=');
        var colonIndex = suffixCode.indexOf(':');
        if (equalIndex === -1 || colonIndex < equalIndex) {
          suffixCode = suffixCode.replace(/:/, ' =');
        }

        if (statementPatcher.node.type === 'ClassProtoAssignOp') {
          // a: b -> @prototype.a = b
          return prefixCode + '@prototype.' + keyCode + suffixCode;
        } else {
          // @a: b -> @a = b
          return '' + prefixCode + keyCode + suffixCode;
        }
      } else if (statementPatcher instanceof ClassPatcher && statementPatcher.nameAssignee) {
        // Nested classes need a special case: they need to be converted to an
        // assignment statement so that the name can be declared outside the outer
        // class body and the initialized within initClass.
        var className = statementPatcher.nameAssignee.node.data;
        var prefix = this.slice(deleteStart, statementPatcher.outerStart);
        var suffix = this.slice(statementPatcher.outerStart, statementPatcher.outerEnd);
        return '' + prefix + className + ' = ' + suffix;
      } else {
        return this.slice(deleteStart, statementPatcher.outerEnd);
      }
    }
  }]);
  return ClassPatcher;
}(NodePatcher);

/**
 * Normalizes conditionals by rewriting post-`if` into standard `if`, e.g.
 *
 *   return [] unless list?
 *
 * becomes
 *
 *   unless list? then return []
 */

var ConditionalPatcher$2 = function (_NodePatcher) {
  inherits(ConditionalPatcher, _NodePatcher);

  function ConditionalPatcher(node, context, editor, condition, consequent, alternate) {
    classCallCheck(this, ConditionalPatcher);

    var _this = possibleConstructorReturn(this, (ConditionalPatcher.__proto__ || Object.getPrototypeOf(ConditionalPatcher)).call(this, node, context, editor));

    _this.condition = condition;
    _this.consequent = consequent;
    _this.alternate = alternate;
    return _this;
  }

  createClass(ConditionalPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (this.isPostIf()) {
        this.patchPostIf();
      } else {
        this.condition.patch();
        if (this.consequent !== null) {
          this.consequent.patch();
        }
        if (this.alternate !== null) {
          this.alternate.patch();
        }
      }
    }

    /**
     * `CONSEQUENT 'if' CONDITION` → `if CONDITION then CONSEQUENT`
     * `CONSEQUENT 'unless' CONDITION` → `unless CONDITION then CONSEQUENT`
     */

  }, {
    key: 'patchPostIf',
    value: function patchPostIf() {
      this.condition.patch();
      this.consequent.patch();

      var ifTokenIndex = this.getIfTokenIndex();
      var ifToken = this.sourceTokenAtIndex(ifTokenIndex);

      if (ifToken) {
        var consequentCode = this.slice(this.consequent.outerStart, this.consequent.outerEnd);
        this.remove(this.consequent.outerStart, ifToken.start);
        this.insert(this.condition.outerEnd, ' then ' + consequentCode);
      }
    }
  }, {
    key: 'isPostIf',
    value: function isPostIf() {
      return this.consequent !== null && this.condition.contentStart > this.consequent.contentStart;
    }
  }, {
    key: 'getIfTokenIndex',
    value: function getIfTokenIndex() {
      var start = this.contentStartTokenIndex;
      var index = this.condition.outerStartTokenIndex;

      while (index !== start) {
        var token = this.sourceTokenAtIndex(index);
        if (token && token.type === coffeeLex.IF) {
          break;
        }
        index = index.previous();
      }

      if (!index) {
        throw this.error('unable to find `if` token in conditional');
      }

      return index;
    }
  }]);
  return ConditionalPatcher;
}(NodePatcher);

var ForPatcher$2 = function (_NodePatcher) {
  inherits(ForPatcher, _NodePatcher);

  function ForPatcher(node, context, editor, keyAssignee, valAssignee, target, filter, body) {
    classCallCheck(this, ForPatcher);

    var _this = possibleConstructorReturn(this, (ForPatcher.__proto__ || Object.getPrototypeOf(ForPatcher)).call(this, node, context, editor));

    _this.keyAssignee = keyAssignee;
    _this.valAssignee = valAssignee;
    _this.target = target;
    _this.filter = filter;
    _this.body = body;
    return _this;
  }

  createClass(ForPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      if (this.keyAssignee) {
        this.keyAssignee.patch();
      }
      if (this.valAssignee) {
        this.valAssignee.patch();
      }
      this.target.patch();
      if (this.filter) {
        this.filter.patch();
      }
      this.body.patch();

      if (this.isPostFor()) {
        this.normalize();
      }
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      this.patchAsExpression();
    }

    /**
     * @private
     */

  }, {
    key: 'isPostFor',
    value: function isPostFor() {
      return this.body.contentStart < this.target.contentStart;
    }

    /**
     * @private
     */

  }, {
    key: 'normalize',
    value: function normalize() {
      var forToken = this.getForToken();
      var forThroughEnd = this.slice(forToken.start, this.contentEnd);
      var startUntilFor = this.slice(this.contentStart, this.body.outerEnd);
      this.overwrite(this.contentStart, this.contentEnd, forThroughEnd + ' then ' + startUntilFor);
    }

    /**
     * @private
     */

  }, {
    key: 'getForToken',
    value: function getForToken() {
      if (this.isPostFor()) {
        var afterForToken = this.getFirstHeaderPatcher();
        var index = this.indexOfSourceTokenBetweenPatchersMatching(this.body, afterForToken, function (token) {
          return token.type === coffeeLex.FOR;
        });

        if (!index) {
          throw this.error('cannot find \'for\' token in loop');
        }

        return this.sourceTokenAtIndex(index);
      } else {
        var token = this.sourceTokenAtIndex(this.contentStartTokenIndex);

        if (!token || token.type !== coffeeLex.FOR) {
          throw this.error('expected \'for\' at start of loop');
        }

        return token;
      }
    }

    /**
     * @private
     */

  }, {
    key: 'getFirstHeaderPatcher',
    value: function getFirstHeaderPatcher() {
      var candidates = [this.keyAssignee, this.valAssignee, this.target];
      var result = null;
      candidates.forEach(function (candidate) {
        if (!candidate) {
          return;
        }
        if (result === null || candidate.contentStart < result.contentStart) {
          result = candidate;
        }
      });
      if (result === null) {
        throw this.error('cannot get first patcher of \'for\' loop header');
      }
      return result;
    }
  }]);
  return ForPatcher;
}(NodePatcher);

var ForInPatcher$2 = function (_ForPatcher) {
  inherits(ForInPatcher, _ForPatcher);

  function ForInPatcher(node, context, editor, keyAssignee, valAssignee, target, step, filter, body) {
    classCallCheck(this, ForInPatcher);

    var _this = possibleConstructorReturn(this, (ForInPatcher.__proto__ || Object.getPrototypeOf(ForInPatcher)).call(this, node, context, editor, keyAssignee, valAssignee, target, filter, body));

    _this.step = step;
    return _this;
  }

  createClass(ForInPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      get$1(ForInPatcher.prototype.__proto__ || Object.getPrototypeOf(ForInPatcher.prototype), 'patchAsExpression', this).call(this);
      if (this.step) {
        this.step.patch();
      }
    }
  }]);
  return ForInPatcher;
}(ForPatcher$2);

var ForOfPatcher$2 = function (_ForPatcher) {
  inherits(ForOfPatcher, _ForPatcher);

  function ForOfPatcher() {
    classCallCheck(this, ForOfPatcher);
    return possibleConstructorReturn(this, (ForOfPatcher.__proto__ || Object.getPrototypeOf(ForOfPatcher)).apply(this, arguments));
  }

  return ForOfPatcher;
}(ForPatcher$2);

var FunctionApplicationPatcher$2 = function (_NodePatcher) {
  inherits(FunctionApplicationPatcher, _NodePatcher);

  function FunctionApplicationPatcher(node, context, editor, fn, args) {
    classCallCheck(this, FunctionApplicationPatcher);

    var _this = possibleConstructorReturn(this, (FunctionApplicationPatcher.__proto__ || Object.getPrototypeOf(FunctionApplicationPatcher)).call(this, node, context, editor));

    _this.fn = fn;
    _this.args = args;
    return _this;
  }

  createClass(FunctionApplicationPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var implicitCall = this.isImplicitCall();
      var args = this.args;


      this.fn.patch();

      if (this.isImplicitSuper()) {
        this.insert(this.fn.contentEnd, '(arguments...)');
        return;
      }

      if (implicitCall) {
        var firstArg = args[0];
        var hasOneArg = args.length === 1;
        var firstArgIsOnNextLine = !firstArg ? false : /\n/.test(this.context.source.slice(this.fn.outerEnd, firstArg.outerStart));
        var funcEnd = this.getFuncEnd();
        if (hasOneArg && firstArg.node.virtual || firstArgIsOnNextLine) {
          this.insert(funcEnd, '(');
        } else {
          this.overwrite(funcEnd, firstArg.outerStart, '(');
        }
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var arg = _step.value;

          // If the last token of the arg is a comma, then the actual delimiter must
          // be a newline and the comma is unnecessary and can cause a syntax error
          // when combined with other normalize stage transformations. So just
          // remove the redundant comma.
          var lastToken = arg.lastToken();
          if (lastToken.type === coffeeLex.COMMA) {
            this.remove(lastToken.start, lastToken.end);
          }
          arg.patch();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (implicitCall) {
        this.insertImplicitCloseParen();
      }
    }

    /**
     * We need to be careful when inserting the close-paren after a function call,
     * since an incorrectly-placed close-paren can cause a parsing error in the
     * MainStage due to subtle indentation rules in the CoffeeScript parser.
     *
     * In particular, we prefer to place the close paren after an existing } or ],
     * or before an existing ), if we can, since that is least likely to confuse
     * any indentation parsing. But in some cases it's best to instead insert the
     * close-paren properly-indented on its own line.
     */

  }, {
    key: 'insertImplicitCloseParen',
    value: function insertImplicitCloseParen() {
      var argListCode = this.slice(this.args[0].contentStart, this.args[this.args.length - 1].contentEnd);
      var isArgListMultiline = argListCode.indexOf('\n') !== -1;
      var lastTokenType = this.lastToken().type;
      if (!isArgListMultiline || lastTokenType === coffeeLex.RBRACE || lastTokenType === coffeeLex.RBRACKET) {
        this.insert(this.contentEnd, ')');
        return;
      }

      var followingCloseParen = this.getFollowingCloseParenIfExists();
      if (followingCloseParen) {
        this.insert(followingCloseParen.start, ')');
        return;
      }

      var args = this.args;

      var lastArg = args[args.length - 1];
      if (lastArg.isMultiline()) {
        this.insert(this.contentEnd, '\n' + this.getIndent() + ')');
        return;
      }

      this.insert(this.contentEnd, ')');
    }
  }, {
    key: 'getFollowingCloseParenIfExists',
    value: function getFollowingCloseParenIfExists() {
      var tokenIndex = this.contentEndTokenIndex;
      var token = void 0;
      do {
        tokenIndex = tokenIndex.next();
        if (tokenIndex === null) {
          return null;
        }
        token = this.sourceTokenAtIndex(tokenIndex);
        if (token === null) {
          return null;
        }
      } while (token.type === coffeeLex.NEWLINE);

      if (token.type === coffeeLex.CALL_END || token.type === coffeeLex.RPAREN) {
        return token;
      }
      return null;
    }

    /**
     * Determine if parens need to be inserted. Needs to handle implicit soaked
     * function calls (where there's a question mark between the function and the
     * args).
     *
     * Note that we do not add parentheses for constructor invocations with no
     * arguments and no parentheses; that usage is correct in JavaScript, so we
     * leave it as-is.
     */

  }, {
    key: 'isImplicitCall',
    value: function isImplicitCall() {
      if (this.args.length === 0) {
        return false;
      }
      var searchStart = this.fn.outerEnd;
      var searchEnd = this.args[0].outerStart;
      return this.indexOfSourceTokenBetweenSourceIndicesMatching(searchStart, searchEnd, function (token) {
        return token.type === coffeeLex.CALL_START;
      }) === null;
    }

    /**
     * Get the source index after the function and the question mark, if any.
     * This is the start of the region to insert an open-paren if necessary
     */

  }, {
    key: 'getFuncEnd',
    value: function getFuncEnd() {
      if (this.node.type === 'SoakedFunctionApplication') {
        var questionMarkTokenIndex = this.indexOfSourceTokenAfterSourceTokenIndex(this.fn.outerEndTokenIndex, coffeeLex.EXISTENCE);
        var questionMarkToken = this.sourceTokenAtIndex(questionMarkTokenIndex);
        return questionMarkToken.end;
      } else {
        return this.fn.outerEnd;
      }
    }
  }, {
    key: 'isImplicitSuper',
    value: function isImplicitSuper() {
      if (this.fn.node.type !== 'Super') {
        return false;
      }

      if (this.args.length !== 1) {
        return false;
      }

      var arg = this.args[0].node;

      return arg.virtual && arg.type === 'Spread' && arg.expression.type === 'Identifier' && arg.expression.data === 'arguments';
    }
  }]);
  return FunctionApplicationPatcher;
}(NodePatcher);

/**
 * Handles object literals.
 */

var ObjectInitialiserPatcher$2 = function (_NodePatcher) {
  inherits(ObjectInitialiserPatcher, _NodePatcher);

  function ObjectInitialiserPatcher(node, context, editor, members) {
    classCallCheck(this, ObjectInitialiserPatcher);

    var _this = possibleConstructorReturn(this, (ObjectInitialiserPatcher.__proto__ || Object.getPrototypeOf(ObjectInitialiserPatcher)).call(this, node, context, editor));

    _this.members = members;
    return _this;
  }

  createClass(ObjectInitialiserPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.members[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var member = _step.value;

          // If the last token of the arg is a comma, then the actual delimiter must
          // be a newline and the comma is unnecessary and can cause a syntax error
          // when combined with other normalize stage transformations. So just
          // remove the redundant comma.
          var lastToken = member.lastToken();
          if (lastToken.type === coffeeLex.COMMA) {
            this.remove(lastToken.start, lastToken.end);
          }
          member.patch();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return ObjectInitialiserPatcher;
}(NodePatcher);

var ObjectInitialiserMemberPatcher$2 = function (_PassthroughPatcher) {
  inherits(ObjectInitialiserMemberPatcher, _PassthroughPatcher);

  function ObjectInitialiserMemberPatcher(node, context, editor, key, expression) {
    classCallCheck(this, ObjectInitialiserMemberPatcher);

    var _this = possibleConstructorReturn(this, (ObjectInitialiserMemberPatcher.__proto__ || Object.getPrototypeOf(ObjectInitialiserMemberPatcher)).call(this, node, context, editor, key, expression));

    _this.key = key;
    _this.expression = expression;
    return _this;
  }

  return ObjectInitialiserMemberPatcher;
}(PassthroughPatcher);

var ProgramPatcher$2 = function (_PassthroughPatcher) {
  inherits(ProgramPatcher, _PassthroughPatcher);

  function ProgramPatcher() {
    classCallCheck(this, ProgramPatcher);
    return possibleConstructorReturn(this, (ProgramPatcher.__proto__ || Object.getPrototypeOf(ProgramPatcher)).apply(this, arguments));
  }

  createClass(ProgramPatcher, [{
    key: 'shouldTrimContentRange',
    value: function shouldTrimContentRange() {
      return true;
    }

    /**
     * Gets the indent string used for each indent in this program.
     */

  }, {
    key: 'getProgramIndentString',
    value: function getProgramIndentString() {
      if (!this._indentString) {
        this._indentString = determineIndent(this.context.source);
      }
      return this._indentString;
    }
  }]);
  return ProgramPatcher;
}(PassthroughPatcher);

/**
 * Normalizes `while` loops by rewriting post-`while` into standard `while`, e.g.
 *
 *   a() while b()
 *
 * becomes
 *
 *   while b() then a()
 */
var WhilePatcher$2 = function (_NodePatcher) {
  inherits(WhilePatcher, _NodePatcher);

  function WhilePatcher(node, context, editor, condition, guard, body) {
    classCallCheck(this, WhilePatcher);

    var _this = possibleConstructorReturn(this, (WhilePatcher.__proto__ || Object.getPrototypeOf(WhilePatcher)).call(this, node, context, editor));

    _this.condition = condition;
    _this.guard = guard;
    _this.body = body;
    return _this;
  }

  createClass(WhilePatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      this.condition.patch();
      if (this.guard) {
        this.guard.patch();
      }
      if (this.body) {
        this.body.patch();
      }

      if (this.isPostWhile()) {
        this.normalize();
      }
    }
  }, {
    key: 'patchAsStatement',
    value: function patchAsStatement() {
      this.patchAsExpression();
    }

    /**
     * `BODY 'while' CONDITION ('when' GUARD)?` → `while CONDITION [when GUARD] then BODY`
     * `BODY 'until' CONDITION ('when' GUARD)?` → `until CONDITION [when GUARD] then BODY`
     *
     * @private
     */

  }, {
    key: 'normalize',
    value: function normalize() {
      var patchedCondition = this.slice(this.condition.outerStart, this.condition.outerEnd);
      var patchedBody = this.slice(this.body.outerStart, this.body.outerEnd);
      var patchedGuard = this.guard ? this.slice(this.guard.outerStart, this.guard.outerEnd) : null;
      var whileToken = this.node.isUntil ? 'until' : 'while';
      this.overwrite(this.contentStart, this.contentEnd, whileToken + ' ' + patchedCondition + ' ' + (patchedGuard ? 'when ' + patchedGuard + ' ' : '') + 'then ' + patchedBody);
    }

    /**
     * @private
     */

  }, {
    key: 'isPostWhile',
    value: function isPostWhile() {
      return this.condition.contentStart > this.body.contentStart;
    }
  }]);
  return WhilePatcher;
}(NodePatcher);

var DefaultParamPatcher$2 = function (_PassthroughPatcher) {
  inherits(DefaultParamPatcher, _PassthroughPatcher);

  function DefaultParamPatcher(node, context, editor, param, value) {
    classCallCheck(this, DefaultParamPatcher);

    var _this = possibleConstructorReturn(this, (DefaultParamPatcher.__proto__ || Object.getPrototypeOf(DefaultParamPatcher)).call(this, node, context, editor, param, value));

    _this.param = param;
    _this.value = value;
    return _this;
  }

  return DefaultParamPatcher;
}(PassthroughPatcher);

var MemberAccessOpPatcher$2 = function (_PassthroughPatcher) {
  inherits(MemberAccessOpPatcher, _PassthroughPatcher);

  function MemberAccessOpPatcher() {
    classCallCheck(this, MemberAccessOpPatcher);
    return possibleConstructorReturn(this, (MemberAccessOpPatcher.__proto__ || Object.getPrototypeOf(MemberAccessOpPatcher)).apply(this, arguments));
  }

  createClass(MemberAccessOpPatcher, [{
    key: 'shouldTrimContentRange',
    value: function shouldTrimContentRange() {
      return true;
    }
  }, {
    key: 'patch',
    value: function patch() {
      get$1(MemberAccessOpPatcher.prototype.__proto__ || Object.getPrototypeOf(MemberAccessOpPatcher.prototype), 'patch', this).call(this);
      var callback = this.findAddStatementCallback();
      if (callback) {
        var content = this.slice(this.contentStart, this.contentEnd);
        this.overwrite(this.contentStart, this.contentEnd, callback(this.node.memberName, content));
      }
    }
  }, {
    key: 'findAddStatementCallback',
    value: function findAddStatementCallback() {
      var patcher = this;

      while (patcher) {
        if (patcher.addStatementAtScopeHeader) {
          return patcher.addStatementAtScopeHeader;
        }
        // Don't consider this node if we're on the right side of a default param
        // (e.g. `(foo = @bar) ->`) or if we're on the left side of an object
        // destructure (e.g. the logical `a` key in `({@a}) ->`).
        if (patcher.parent instanceof DefaultParamPatcher$2 && patcher.parent.value === patcher) {
          break;
        }
        if (patcher.parent instanceof ObjectInitialiserMemberPatcher$2 && patcher.parent.key === patcher) {
          break;
        }
        patcher = patcher.parent;
      }
      return null;
    }
  }]);
  return MemberAccessOpPatcher;
}(PassthroughPatcher);

var FunctionPatcher$2 = function (_NodePatcher) {
  inherits(FunctionPatcher, _NodePatcher);

  function FunctionPatcher(node, context, editor, parameters, body) {
    classCallCheck(this, FunctionPatcher);

    var _this = possibleConstructorReturn(this, (FunctionPatcher.__proto__ || Object.getPrototypeOf(FunctionPatcher)).call(this, node, context, editor));

    _this.parameters = parameters;
    _this.body = body;
    return _this;
  }

  createClass(FunctionPatcher, [{
    key: 'patchAsExpression',
    value: function patchAsExpression() {
      var _this2 = this;

      // To avoid knowledge of all the details how assignments can be nested in nodes,
      // we add a callback to the function node before patching the parameters and remove it afterwards.
      // This is detected and used by the MemberAccessOpPatcher to claim a free binding for this parameter
      // (from the functions scope, not the body's scope)

      var assignments = [];
      this.addStatementAtScopeHeader = function (memberName) {
        var varName = _this2.claimFreeBinding(memberName);
        assignments.push('@' + memberName + ' = ' + varName);
        _this2.log('Replacing parameter @' + memberName + ' with ' + varName);
        return varName;
      };

      this.parameters.forEach(function (parameter) {
        return parameter.patch();
      });

      delete this.addStatementAtScopeHeader;

      // If there were assignments from parameters insert them
      if (this.body) {
        // before the actual body
        if (assignments.length) {
          var text = void 0;
          if (this.body.node.inline) {
            text = assignments.join('; ') + '; ';
          } else {
            var indent = this.body.getIndent(0);
            text = assignments.join('\n' + indent) + '\n' + indent;
          }
          this.insert(this.body.contentStart, '' + text);
        }
        this.body.patch();
      } else if (assignments.length) {
        // as the body if there is no body
        // Add a return statement for non-constructor methods without body to avoid bad implicit return
        if (this.node.parentNode.type !== 'Constructor') {
          assignments.push('return');
        }
        var _indent = this.getIndent(1);
        var _text = assignments.join('\n' + _indent);
        this.insert(this.contentEnd, '\n' + _indent + _text);
      }
    }
  }]);
  return FunctionPatcher;
}(NodePatcher);

var NormalizeStage = function (_TransformCoffeeScrip) {
  inherits(NormalizeStage, _TransformCoffeeScrip);

  function NormalizeStage() {
    classCallCheck(this, NormalizeStage);
    return possibleConstructorReturn(this, (NormalizeStage.__proto__ || Object.getPrototypeOf(NormalizeStage)).apply(this, arguments));
  }

  createClass(NormalizeStage, [{
    key: 'patcherConstructorForNode',
    value: function patcherConstructorForNode(node) {
      switch (node.type) {
        case 'ArrayInitialiser':
          return ArrayInitialiserPatcher$2;

        case 'MemberAccessOp':
          return MemberAccessOpPatcher$2;

        case 'Block':
          return BlockPatcher$2;

        case 'BoundFunction':
        case 'Function':
          return FunctionPatcher$2;

        case 'Conditional':
          return ConditionalPatcher$2;

        case 'ForIn':
          return ForInPatcher$2;

        case 'ForOf':
          return ForOfPatcher$2;

        case 'FunctionApplication':
        case 'NewOp':
        case 'SoakedFunctionApplication':
          return FunctionApplicationPatcher$2;

        case 'While':
          return WhilePatcher$2;

        case 'Class':
          return ClassPatcher$2;

        case 'AssignOp':
        case 'ClassProtoAssignOp':
          return AssignOpPatcher$2;

        case 'Program':
          return ProgramPatcher$2;

        case 'DefaultParam':
          return DefaultParamPatcher$2;

        case 'ObjectInitialiser':
          return ObjectInitialiserPatcher$2;

        case 'ObjectInitialiserMember':
          return ObjectInitialiserMemberPatcher$2;

        default:
          return PassthroughPatcher;
      }
    }
  }], [{
    key: 'outputExtension',
    get: function get() {
      return '.coffee';
    }
  }]);
  return NormalizeStage;
}(TransformCoffeeScriptStage);

/**
 * Convert the given code to use the specified newline string, either '\n' or
 * '\r\n'.
 *
 * 
 */
function convertNewlines(source, newlineStr) {
  if (newlineStr === '\n') {
    return source.replace(/\r\n/g, '\n');
  } else if (newlineStr === '\r\n') {
    source = source.replace(/\r\n/g, '\n');
    return source.replace(/\n/g, '\r\n');
  } else {
    throw new Error('Unexpected newling string to convert to: ' + JSON.stringify(newlineStr));
  }
}

/**
 * Determine the most common newline string in the given code, either '\n' or
 * '\r\n'. Prefer '\n' in the case of a tie.
 *
 * 
 */
function detectNewlineStr(source) {
  var numLFs = 0;
  var numCRLFs = 0;
  for (var i = 0; i < source.length; i++) {
    if (source[i] === '\n' && (i === 0 || source[i - 1] !== '\r')) {
      numLFs++;
    }
    if (source.slice(i, i + 2) === '\r\n') {
      numCRLFs++;
    }
  }
  return numCRLFs > numLFs ? '\r\n' : '\n';
}

/**
 * Display a range of code, e.g. for a token or an AST node.
 *
 * The line and column are displayed as 1-indexed, to agree with most editors,
 * and the actual 0-indexed code index is also displayed.
 *
 * For example, if a program is just "foo", then the "foo" token has this range:
 * [1:1(0)-1:4(3)]
 */
function formatRange(startIndex, endIndex, context) {
  return "[" + formatIndex(startIndex, context) + "-" + formatIndex(endIndex, context) + "]";
}

function formatIndex(index, context) {
  if (index > context.source.length) {
    index = context.source.length;
  }

  var _context$linesAndColu = context.linesAndColumns.locationForIndex(index);

  var line = _context$linesAndColu.line;
  var column = _context$linesAndColu.column;

  return line + 1 + ":" + (column + 1) + "(" + index + ")";
}

function formatCoffeeLexTokens(context) {
  var tokens$$1 = context.sourceTokens;
  var resultLines = tokens$$1.map(function (token) {
    return formatRange(token.start, token.end, context) + ': ' + token.type.name;
  });
  return resultLines.map(function (line) {
    return line + '\n';
  }).join('');
}

function formatCoffeeScriptLocationData(locationData, context) {
  var first_line = locationData.first_line;
  var first_column = locationData.first_column;
  var last_line = locationData.last_line;
  var last_column = locationData.last_column;

  var firstIndex = context.linesAndColumns.indexForLocation({ line: first_line, column: first_column });
  var lastIndex = context.linesAndColumns.indexForLocation({ line: last_line, column: last_column }) + 1;
  return formatRange(firstIndex, lastIndex, context);
}

function formatCoffeeScriptAst(context) {
  var resultLines = formatAstNodeLines(context.ast, context);
  return resultLines.map(function (line) {
    return line + '\n';
  }).join('');
}

function formatAstNodeLines(node, context) {
  var propLines = [];
  var blacklistedProps = ['locationData'];
  // Show the non-node children first.
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(node)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      var value = node[key];
      if (shouldTraverse(value) || blacklistedProps.indexOf(key) !== -1) {
        continue;
      }
      var valueText = void 0;
      try {
        valueText = JSON.stringify(value);
      } catch (e) {
        valueText = '(error)';
      }
      propLines.push(key + ': ' + valueText);
    }

    // Then show the node children.
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = Object.keys(node)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _key = _step2.value;

      var _value = node[_key];
      if (!shouldTraverse(_value)) {
        continue;
      }

      if (Array.isArray(_value) && _value.length === 0) {
        propLines.push(_key + ': []');
      } else if (Array.isArray(_value)) {
        propLines.push(_key + ': [');
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = _value[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var child = _step3.value;

            propLines.push.apply(propLines, toConsumableArray(formatAstNodeLines(child, context).map(function (s) {
              return '  ' + s;
            })));
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        propLines.push(']');
      } else {
        var childLines = formatAstNodeLines(_value, context);
        childLines[0] = _key + ': ' + childLines[0];
        propLines.push.apply(propLines, toConsumableArray(childLines));
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return [node.constructor.name + ' ' + formatCoffeeScriptLocationData(node.locationData, context) + ' {'].concat(toConsumableArray(propLines.map(function (s) {
    return '  ' + s;
  })), ['}']);
}

function shouldTraverse(value) {
  if (Array.isArray(value)) {
    return value.length === 0 || isNode(value[0]);
  }
  return isNode(value);
}

/**
 * CoffeeScript AST nodes are always instances of a custom class, so use the
 * constructor name to distinguish between node children and non-node children.
 */
function isNode(value) {
  if (!value) {
    return false;
  }
  return ['String', 'Number', 'Boolean', 'Array', 'Object'].indexOf(value.constructor.name) === -1;
}

function formatCoffeeScriptLexerTokens(tokens$$1, context) {
  var resultLines = tokens$$1.map(function (_ref) {
    var _ref2 = slicedToArray(_ref, 3);

    var tag = _ref2[0];
    var value = _ref2[1];
    var locationData = _ref2[2];
    return formatCoffeeScriptLocationData(locationData, context) + ': ' + tag + ': ' + JSON.stringify(value);
  });
  return resultLines.map(function (line) {
    return line + '\n';
  }).join('');
}

function formatDecaffeinateParserAst(ast) {
  var resultLines = formatAstNodeLines$1(ast, ast.context);
  return resultLines.map(function (line) {
    return line + '\n';
  }).join('');
}

function formatAstNodeLines$1(node, context) {
  var propLines = [];
  var childPropNames = childPropertyNames(node);
  var blacklistedProps = childPropNames.concat(['raw', 'line', 'column', 'type', 'range', 'virtual', 'scope', 'parentNode', 'context']);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(node)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      if (blacklistedProps.indexOf(key) !== -1) {
        continue;
      }
      var valueText = void 0;
      try {
        valueText = JSON.stringify(node[key]);
      } catch (e) {
        valueText = '(error)';
      }
      propLines.push(key + ': ' + valueText);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = childPropNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var childProp = _step2.value;

      var value = node[childProp];
      if (value === null) {
        propLines.push(childProp + ': null');
      } else if (Array.isArray(value) && value.length === 0) {
        propLines.push(childProp + ': []');
      } else if (Array.isArray(value)) {
        propLines.push(childProp + ': [');
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = value[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var child = _step3.value;

            propLines.push.apply(propLines, toConsumableArray(formatAstNodeLines$1(child, context).map(function (s) {
              return '  ' + s;
            })));
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        propLines.push(']');
      } else {
        var childLines = formatAstNodeLines$1(value, context);
        childLines[0] = childProp + ': ' + childLines[0];
        propLines.push.apply(propLines, toConsumableArray(childLines));
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var rangeStr = void 0;
  if (node.virtual) {
    rangeStr = '(virtual)';
  } else {
    rangeStr = formatRange(node.range[0], node.range[1], context);
  }
  return [node.type + ' ' + rangeStr + ' {'].concat(toConsumableArray(propLines.map(function (s) {
    return '  ' + s;
  })), ['}']);
}

/**
 * If the given exception is an error with code location information, extract
 * its start and end position and return a PatchError to use in its place.
 * Otherwise, return null.
 */
function resolveToPatchError(err, content, stageName) {
  var makePatchError = function makePatchError(start, end, source) {
    return new PatchError(stageName + ' failed to parse: ' + err.message, source, start, end);
  };

  if (err.pos) {
    // Handle JavaScript parse errors.
    var pos = err.pos;

    if (pos === content.length) {
      pos--;
    }
    // In most cases, we can use the source code we already have, but for
    // esnext, the code might be an intermediate code state, so use that from
    // the exception if possible.
    var source = err.source || content;
    return makePatchError(pos, pos + 1, source);
  } else if (err.syntaxError) {
    // Handle CoffeeScript parse errors.
    var _err$syntaxError$loca = err.syntaxError.location;
    var first_line = _err$syntaxError$loca.first_line;
    var first_column = _err$syntaxError$loca.first_column;
    var last_line = _err$syntaxError$loca.last_line;
    var last_column = _err$syntaxError$loca.last_column;

    var lineMap = new LinesAndColumns(content);
    var firstIndex = lineMap.indexForLocation({ line: first_line, column: first_column });
    var lastIndex = lineMap.indexForLocation({ line: last_line, column: last_column }) + 1;
    if (firstIndex !== null && firstIndex !== undefined && lastIndex !== null && lastIndex !== undefined) {
      return makePatchError(firstIndex, lastIndex, content);
    }
  }
  return null;
}

/* eslint-disable no-process-exit */

/**
 * Run the script with the user-supplied arguments.
 */
function run$1(args) {
  var options = parseArguments(args);

  if (options.paths.length) {
    runWithPaths(options.paths);
  } else {
    runWithStream('stdin', process.stdin, process.stdout);
  }
}

function parseArguments(args) {
  var paths = [];

  for (var i = 0; i < args.length; i++) {
    var arg = args[i];
    switch (arg) {
      case '-h':
      case '--help':
        usage();
        process.exit(0);
        break;

      default:
        paths.push(arg);
        break;
    }
  }

  return { paths: paths };
}

/**
 * Run decaffeinate on the given paths, changing them in place.
 */
function runWithPaths(paths) {
  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var errors = [];
  var pending = paths.slice();

  function processPath(path$$1) {
    fs.stat(path$$1, function (err, info) {
      if (err) {
        errors.push(err);
      } else if (info.isDirectory()) {
        processDirectory(path$$1);
      } else {
        processFile(path$$1);
      }
    });
  }

  function processDirectory(path$$1) {
    fs.readdir(path$$1, function (err, children) {
      if (err) {
        errors.push(err);
      } else {
        pending.unshift.apply(pending, toConsumableArray(children.filter(function (child) {
          return path.extname(child) === '.coffee';
        }).map(function (child) {
          return path.join(path$$1, child);
        })));
      }
      processNext();
    });
  }

  function processFile(path$$1) {
    var outputPath = path.join(path.dirname(path$$1), path.basename(path$$1, path.extname(path$$1))) + '.js';
    console.log(path$$1 + ' \u2192 ' + outputPath);
    runWithStream(path$$1, fs.createReadStream(path$$1, { encoding: 'utf8' }), fs.createWriteStream(outputPath, { encoding: 'utf8' }), function (err) {
      if (err) {
        errors.push(err);
      }
      processNext();
    });
  }

  function processNext() {
    if (pending.length > 0) {
      processPath(pending.shift());
    } else if (callback) {
      callback(errors);
    }
  }

  processNext();
}

/**
 * Run decaffeinate reading from input and writing to corresponding output.
 */
function runWithStream(name, input, output) {
  var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var error = null;
  var data = '';

  input.setEncoding('utf8');

  input.on('data', function (chunk) {
    return data += chunk;
  });

  input.on('end', function () {
    var converted = void 0;
    try {
      converted = convert$1(data);
    } catch (err) {
      if (PatchError.detect(err)) {
        console.error(name + ': ' + PatchError.prettyPrint(err));
        process.exit(1);
      } else {
        throw err;
      }
    }
    if (converted) {
      var _converted = converted;
      var code = _converted.code;

      output.end(code, function () {
        if (callback) {
          callback(error);
        }
      });
    }
  });

  output.on('error', function (err) {
    return error = err;
  });
}

/**
 * Print usage help.
 */
function usage() {
  var exe = path.basename(process.argv[1]);
  console.log('%s [OPTIONS] PATH [PATH …]', exe);
  console.log('%s [OPTIONS] < INPUT', exe);
  console.log();
  console.log('Move your CoffeeScript source to JavaScript using modern syntax.');
  console.log();
  console.log('OPTIONS');
  console.log();
  console.log('  -h, --help     Display this help message.');
  console.log();
  console.log('EXAMPLES');
  console.log();
  console.log('  # Convert a .coffee file to a .js file.');
  console.log('  $ decaffeinate index.coffee');
  console.log();
  console.log('  # Pipe an example from the command-line.');
  console.log('  $ echo "a = 1" | decaffeinate');
  console.log();
  console.log('  # On OS X this may come in handy:');
  console.log('  $ pbpaste | decaffeinate | pbcopy');
  console.log();
  console.log('  # Process everything in a directory.');
  console.log('  $ decaffeinate src/');
  console.log();
  console.log('  # Redirect input from a file.');
  console.log('  $ decaffeinate < index.coffee');
}

/**
 * Convert CoffeeScript source code into modern JavaScript preserving comments
 * and formatting.
 */
function convert$1(source) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var originalNewlineStr = detectNewlineStr(source);
  source = convertNewlines(source, '\n');
  var stages = [NormalizeStage, MainStage, AddVariableDeclarationsStage, SemicolonsStage, EsnextStage];
  var runToStage = options.runToStage;
  if (runToStage !== null && runToStage !== undefined) {
    var stageIndex = stages.findIndex(function (stage) {
      return stage.name === runToStage;
    });
    if (stageIndex !== -1) {
      stages = stages.slice(0, stageIndex + 1);
    } else {
      return convertCustomStage(source, runToStage);
    }
  }
  var result = runStages(source, options.filename || 'input.coffee', stages);
  result.code = convertNewlines(result.code, originalNewlineStr);
  return result;
}

function runStages(initialContent, initialFilename, stages) {
  var maps = [];
  var content = initialContent;
  var filename = initialFilename;
  stages.forEach(function (stage) {
    var _runStage = runStage(stage, content, filename);

    var code = _runStage.code;
    var map = _runStage.map;

    if (code !== content) {
      maps.push(map);
      content = code;
      filename = map.file;
    }
  });
  return { code: content, maps: maps };
}

function runStage(stage, content, filename) {
  try {
    return stage.run(content, filename);
  } catch (err) {
    var patchError = resolveToPatchError(err, content, stage.name);
    if (patchError !== null) {
      throw patchError;
    }
    throw err;
  }
}

function convertCustomStage(source, stageName) {
  var ast = parse$2(source);
  if (stageName === 'coffeescript-lexer') {
    return {
      code: formatCoffeeScriptLexerTokens(decaffeinateCoffeescript.tokens(source), ast.context),
      maps: []
    };
  } else if (stageName === 'coffeescript-parser') {
    return {
      code: formatCoffeeScriptAst(ast.context),
      maps: []
    };
  } else if (stageName === 'coffee-lex') {
    return {
      code: formatCoffeeLexTokens(ast.context),
      maps: []
    };
  } else if (stageName === 'decaffeinate-parser') {
    return {
      code: formatDecaffeinateParserAst(ast),
      maps: []
    };
  } else {
    throw new Error('Unrecognized stage name: ' + stageName);
  }
}

exports.PatchError = PatchError;
exports.convert = convert$1;
exports.run = run$1;
//# sourceMappingURL=decaffeinate.js.map
